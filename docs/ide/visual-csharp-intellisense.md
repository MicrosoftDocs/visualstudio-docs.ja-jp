---
title: C# IntelliSense
description: C# プロジェクトのコーディング中に使用できるいくつかの IntelliSense 機能について説明します。
ms.custom: SEO-VS-2020
ms.date: 06/01/2021
ms.topic: conceptual
helpviewer_keywords:
- C#, IntelliSense
- IntelliSense [C#]
author: mikadumont
ms.author: midumont
manager: jmartens
ms.workload:
- dotnet
ms.openlocfilehash: 3156b1236a130478d83fe82c8fa462a1144a8e6a
ms.sourcegitcommit: f50bbdb15c4f9fca0fa245ca765183c378960cc5
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/03/2021
ms.locfileid: "111351956"
---
# <a name="c-intellisense"></a>C# IntelliSense

C# IntelliSense は、エディターでコーディングする際、および[イミディエイト モード](../ide/reference/immediate-window.md) コマンド ウィンドウでデバッグしている間に使用可能です。

## <a name="completion-lists"></a>入力候補一覧

C# での IntelliSense コンプリート リストには、メンバーの一覧や入力候補などからのトークンが含まれています。 コンプリート リストでは、以下にすばやくアクセスできます。

- 型または名前空間のメンバー

- 変数、コマンド、関数の名前

- コード スニペット

- 言語キーワード

- 拡張メソッド

また、C# の入力候補一覧は、コンテキストに基づいて無関係なトークンを除外したり、トークンを事前に選択したりもできます。 詳細については、[フィルター処理されたコンプリート リスト](#filtered-completion-lists)に関するページを参照してください。

### <a name="code-snippets-in-completion-lists"></a>コンプリート リストのコード スニペット

C# のコンプリート リストには、コード スニペットが含まれており、事前に定義されたコードの本体をプログラムに簡単に挿入できます。 コード スニペットは、スニペットの[ショートカット テキスト](../ide/code-snippets-schema-reference.md#shortcut-element)としてコンプリート リストに表示されます。 既定で C# で利用できるコード スニペットの詳細については、「[C# のコード スニペット](../ide/visual-csharp-code-snippets.md)」を参照してください。

### <a name="language-keywords-in-completion-lists"></a>コンプリート リストの言語キーワード

C# のコンプリート リストには、言語キーワードも含まれています。 C# の言語キーワードの詳細については、「[C# のキーワード](/dotnet/csharp/language-reference/keywords/index)」を参照してください。

### <a name="extension-methods-in-completion-lists"></a>コンプリート リストでの拡張メソッド

C# のコンプリート リストには、スコープ内にある拡張メソッドが含まれます。

> [!NOTE]
> Visual C# のコンプリート リストでは、<xref:System.String> オブジェクトのすべての拡張メソッドが表示されるわけではありません。

拡張メソッドでは、インスタンス メソッドとは異なるアイコンが使用されます。 リスト アイコンのリファレンス ガイドについては、「[[クラス ビュー] ウィンドウとオブジェクト ブラウザーのアイコン](../ide/class-view-and-object-browser-icons.md)」をご覧ください。 同じ名前のインスタンス メソッドと拡張メソッドが両方ともスコープ内にある場合、コンプリート リストには拡張メソッドのアイコンが表示されます。

### <a name="filtered-completion-lists"></a>フィルター処理されたコンプリート リスト

IntelliSense では、フィルターを使用して、不要なメンバーをコンプリート リストから削除します。 C# では、次の項目用に表示されるコンプリート リストをフィルター処理します。

- **インターフェイスと基本クラス**: IntelliSense では、クラス宣言の基本およびインターフェイス リストおよび制約リストの両方で、インターフェイスおよび基本クラスのコンプリート リストから項目を自動的に削除します。 たとえば、列挙型は基本クラスのコンプリート リストには表示されません。これは、列挙型が基本クラスで使用できないためです。 基本クラスのコンプリート リストには、インターフェイスおよび名前空間だけが含まれます。 リストで項目を選択し、コンマを入力すると、IntelliSense によりコンプリート リストから基本クラスが削除されます。これは、C# では多重継承がサポートされていないためです。 制約句の場合も、同様の動作になります。

- **属性**: 属性を型に適用した場合、コンプリート リストはフィルター処理され、<xref:System.Attribute> などそれらの型を含む名前空間からの型だけがリストに残ります。

- **Catch 句**

- **オブジェクト初期化子**: 初期化できるメンバーだけがコンプリート リストに表示されます。

- **新しいキーワード**: 「`new`」と入力し、**Space** キーを押すと、コンプリート リストが表示されます。 コードの状況に応じて、リストの項目が自動的に選択されます。  たとえば、メソッドの宣言用と return ステートメント用の項目がコンプリート リストで自動的に選択されます。

- **enum キーワード**: 列挙型 (Enum) の割り当ての等号 (=) の次に **Space** キーを押すと、コンプリート リストが表示されます。 コードの状況に応じて、リストの項目が自動的に選択されます。  たとえば、キーワード return の入力後や、宣言の作成時に、コンプリート リストで項目が自動的に選択されます。

- **as 演算子と is 演算子**: `as` または `is` のキーワードを入力してから **Space** キーを押すと、フィルター処理されたコンプリート リストが自動的に表示されます。

- **イベント**: キーワード `event` を入力した場合、コンプリート リストにはデリゲート型のみが含まれます。

- パラメーターを入力すると、パラメーターに一致するメソッド オーバーロードが先頭になるよう、**パラメーター ヘルプ** によって自動的に並べ替えが行われます。 複数のメソッド オーバーロードを使用できる場合は、上向きまたは下向きの矢印を使用し、一覧で次に使用できるオーバーロードに移動できます。

### <a name="most-recently-used-members"></a>最近使用したメンバー

IntelliSense は、オブジェクト名の自動補完のために、ポップアップ [メンバーの一覧](../ide/using-intellisense.md)ボックスで最近選択したメンバーを記憶します。 次に **メンバーの一覧** を使用するときに、最近使用したメンバーが上部に表示されます。 最近使用したメンバーの履歴は、Visual Studio の各セッションの間に消去されます。

### <a name="override"></a>override

[override](/dotnet/csharp/language-reference/keywords/override) と入力してから **Space** キーを押すと、オーバーライドできる有効な基本クラス メンバーすべてが IntelliSense によりポップアップ リスト ボックスに表示されます。 `override` の後ろにメソッドの戻り値の型を入力すると、同じ型を返すメソッドのみが表示されます。 一致が見つからなかった場合はすべての基本クラスのメンバーが表示されます。

### <a name="ai-enhanced-intellisense"></a>AI で強化された IntelliSense

[Visual Studio IntelliCode](/visualstudio/intellicode/intellicode-visual-studio) では、人工知能で強化された IntelliSense 入力候補の一覧が提供されます。 IntelliCode では、ただ API の一覧がアルファベット順に提示されるのではなく、使用する可能性が最も高い API が予測されます。 現在のコードのコンテキストとパターンに基づいて、一覧が動的に提供されます。

## <a name="automatic-code-generation"></a>自動コード生成

### <a name="add-using"></a>using を追加します。

IntelliSense の **using 追加** 操作では、必須の `using` ディレクティブがコード ファイルに自動的に追加されます。 この機能によって、作成中のコードにだけ集中できるので、それ以外の部分に注意を払う必要がなくなります。

**using の追加** 操作を実行するには、解決できない型参照にカーソルを置きます。 たとえば、コンソール アプリケーションを作成し、`Main` メソッドの本体に `XmlReader` を追加すると、コードのその行に赤い波線が表示されます。型参照が解決できないためです。 **クイック アクション** で **using の追加** を呼び出すことができます。 **クイック アクション** は、バインドされていない型の上にカーソルが置かれた場合にのみ表示されます。

![using の追加、クイック アクションの展開イメージ](../ide/media/addusing-quickaction.png)

エラー電球アイコンをクリックし、**[using System.Xml;]** を選択すると using ディレクティブが自動的に追加されます。

### <a name="add-missing-using-directives-on-paste"></a>不足している using ディレクティブを貼り付け時に追加する

IntelliSense では、型をコード ファイルに貼り付けるとき、足りない `using` ディレクティブをコードに自動追加できます。 この機能によって、型をファイルに貼り付けるとき、足りない using ディレクティブを追加する作業を自動化することで時間が節約されます。 **[ツール]**  >  **[オプション]**  >  **[テキスト エディター]**  >  **[C#]** または **[基本]**  >  **[詳細設定]** でこの機能を有効にし、 **[不足している using ディレクティブを貼り付け時に追加する]** を選択します。

### <a name="remove-and-sort-usings"></a>using の削除と並べ替え

**[using の削除と並べ替え]** オプションは、ソース コードの動作を変更することなく、`using` と `extern` の宣言を並べ替えおよび削除します。 時間の経過に伴い、不要で整理されていない `using` ディレクティブのために、ソース ファイルが肥大化して読みにくくなる場合があります。 **[using の削除と並べ替え]** オプションは、使用されない `using` ディレクティブを削除してソース コードをコンパクトにし、並べ替えて読みやすくします。 **[編集]** メニューで、**[IntelliSense]** を選択し、**[using の整理]** を選択します。

### <a name="implement-interface"></a>インターフェイスの実装

IntelliSense を使用すると、コード エディターでの作業中に[インターフェイス](/dotnet/csharp/language-reference/keywords/interface)を簡単に実装できます。 通常、インターフェイスを適切に実装するには、クラス内で、インターフェイスのすべてのメンバーについてメソッド宣言を作成する必要があります。 IntelliSense を使用した場合、クラス宣言でインターフェイスの名前を入力すると、**クイック アクション** の電球が表示されます。 この電球には、インターフェイスを自動的に実装する際のオプションが表示され、名前付けを明示的に行うか、暗黙的に行うかを選択できます。 明示的な名前付けでは、メソッドの宣言にインターフェイスの名前が含まれます。 暗黙的な名前付けでは、メソッドの宣言に、それが属するインターフェイスが示されません。 明示的に名前付けされたインターフェイス メソッドには、インターフェイスのインスタンスからアクセスすることしかできず、クラスのインスタンスからアクセスすることはできません。 詳細については、「[明示的なインターフェイスの実装](/dotnet/csharp/programming-guide/interfaces/explicit-interface-implementation)」を参照してください。

インターフェイスの実装機能では、そのインターフェイスに必要な最小の数のメソッド スタブが生成されます。 基本クラスにインターフェイスの一部だけが実装される場合、これらのスタブは再生成されません。

### <a name="implement-abstract-base-class"></a>抽象基本クラスの実装

IntelliSense には、コード エディターでの作業中、抽象基本クラスのメンバーを自動的に実装するためのオプションが用意されています。 通常、抽象基本クラスのメンバーを実装するには、派生クラスで抽象基本クラスのメソッドごとに新しいメソッド定義を作成する必要があります。 IntelliSense を使用した場合、クラス宣言で抽象基本クラスの名前を入力すると、**クイック アクション** の電球が表示されます。 この電球で、基本クラスのメソッドを自動的に実装するためのオプションを選択できます。

**抽象基本クラスの実装** 機能によって生成されるメソッド スタブは、*MethodStub.snippet* ファイルで定義されたコード スニペットがベースになります。 コード スニペットは変更できます。 詳細については、「[チュートリアル: コード スニペットを作成する](../ide/walkthrough-creating-a-code-snippet.md)」を参照してください。

### <a name="generate-from-usage"></a>使用法から生成

**[使用法から生成]** 機能では、クラスとメンバーを定義する前にそれらを使用することができます。 使用されますが、まだ定義されていないクラス、コンストラクター、メソッド、プロパティ、フィールド、または列挙型に対してスタブを生成することができます。 コード内の現在の場所を離れずに、新しい型とメンバーを生成することができます。 これにより、ワークフローの中断を最小限にします。

未定義の識別子の下にそれぞれ、波状の赤い下線が表示されます。 識別子の上にマウス ポインターを置くと、ヒントにエラー メッセージが表示されます。 適切なオプションを表示するには、次の手順のいずれかを使用することができます。

- 未定義の識別子をクリックします。 **クイック アクション** のエラー電球が識別子の下に表示されます。 エラー電球をクリックします。

- 未定義の識別子をクリックし、**Ctrl**+ **.** (**Ctrl** + ピリオド) を押します。

- 未定義の識別子を右クリックして、**[クイック アクションとリファクタリング]** をクリックします。

表示されるオプションは、次のとおりです。

- **プロパティの生成**

- **フィールドの生成**

- **メソッドの生成**

- **クラスの生成**

- **新しい型の生成** (クラス、構造体、インターフェイス、または列挙型)

## <a name="generate-event-handlers"></a>イベント ハンドラーの生成

コード エディターで、IntelliSense はイベント フィールドにメソッド (イベント ハンドラー) をフックするのに役立ちます。

*.cs* ファイルのイベント フィールドの後に `+=` 演算子を入力すると、IntelliSense では **Tab** キーを押すオプションの使用が求められます。 これで、イベントを処理するメソッドを示すデリゲートの新しいインスタンスを挿入します。

![オート フック ボタン](../ide/media/vxautohookup.gif)

**Tab** キーを押すと、IntelliSense は自動的にステートメントを完了し、コード エディターに選択されたテキストとしてイベント ハンドラーの参照を表示します。 自動イベント フックアップを完了するには、IntelliSense はイベント ハンドラーの空のスタブを作成するために、もう一度 **Tab** キーを押すように要求します。

![イベント ハンドラーの作成](../ide/media/vxgenerateeventhandler.gif)

> [!NOTE]
> IntelliSense によって作成された新しいデリゲートが既存のイベント ハンドラーを参照する場合、IntelliSense はヒントのこの情報と通信します。 その後、この参照を変更できます。テキストはコード エディターで既に選択されています。 それ以外の場合、自動イベント フックアップはこの時点で完了します。

**Tab** キーを押すと、IntelliSense は正しいシグネチャでメソッドをスタブして、イベント ハンドラーの本体にカーソルを置きます。

> [!NOTE]
> **[ビュー]** メニュー (**Ctrl**+ **-** ) の **[戻る]** コマンドを使用して、イベント フックアップ ステートメントに戻ります。

## <a name="see-also"></a>関連項目

- [IntelliSense を使用する](../ide/using-intellisense.md)
- [Visual Studio IDE](../get-started/visual-studio-ide.md)
