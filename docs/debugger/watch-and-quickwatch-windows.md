---
title: "ウォッチ ウィンドウと [クイック ウォッチ] ウィンドウ | Microsoft Docs"
ms.custom: ""
ms.date: "12/03/2016"
ms.prod: "visual-studio-dev14"
ms.reviewer: ""
ms.suite: ""
ms.technology: 
  - "vs-ide-debug"
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vs.debug.watch"
dev_langs: 
  - "FSharp"
  - "VB"
  - "CSharp"
  - "C++"
  - "JScript"
helpviewer_keywords: 
  - "デバッグ [Visual Studio]、ウォッチ ウィンドウ"
  - "式 [デバッガー]、評価"
  - "変数 [デバッガー]、評価"
  - "式の評価"
  - "登録、評価"
  - "デバッグ [Visual Studio]、式の評価"
ms.assetid: d5c18377-2a0e-4819-a645-407e24ccc58c
caps.latest.revision: 45
caps.handback.revision: 44
author: "mikejo5000"
ms.author: "mikejo"
manager: "ghogen"
---
# ウォッチ ウィンドウと [クイック ウォッチ] ウィンドウ
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

**\[ウォッチ\]** \(**\[デバッグ\]\/\[ウィンドウ\]\/\[ウォッチ\]\/\[ウォッチ \(1、2、3、4\)\]**\) および **\[クイック ウォッチ\]** \(**\[デバッグ\]\/\[クイック ウォッチ\]**\) ウィンドウを使用すると、デバッグ中に変数と式を監視できます。 この 2 つのウィンドウの違いは、**ウォッチ** ウィンドウでは複数の変数を表示できますが、**\[クイック ウォッチ\]** ウィンドウでは一度に 1 つの変数しか表示できないことです。  
  
## \[クイック ウォッチ\] での 1 つの変数の観察  
 **\[クイック ウォッチ\]** ウィンドウでは、1 つの変数を観察できます。 たとえば、次のようなコードがあるとします。  
  
```c#  
static void Main(string[] args) { int a, b; a = 1; b = 2; for (int i = 0; i < 10; i++) { a = a + b; } }  
```  
  
 \[クイック ウォッチ\] ウィンドウで変数を観察するには、以下のようにします。  
  
1.  `a = a + b;` の行にブレークポイントを設定します。  
  
2.  デバッグを開始します。 ブレークポイントで実行が停止します。  
  
3.  **\[クイック ウォッチ\]** ウィンドウを開きます \(a を右クリックして **\[デバッグ\]\/\[クイック ウォッチ\]** を選択するか、**Shift \+ F9** キーを押します\)。ウィンドウが開いたら、**\[式\]** ウィンドウに変数を追加して、**\[再評価\]** をクリックします。**\[値\]** ウィンドウに、値が 2 の変数 a が表示されるはずです。  
  
4.  **\[クイック ウォッチ\]** ウィンドウはモーダル ダイアログ ウィンドウであるため、このウィンドウが開いている限り、デバッグを続行することはできません。 変数を**ウォッチ** ウィンドウに追加するには、**\[ウォッチ式の追加\]** をクリックします。  
  
5.  **\[クイック ウォッチ\]** ウィンドウを閉じます。 これで、**ウォッチ** ウィンドウで値を観察しながら、デバッグを続行できます。  
  
## ウォッチ ウィンドウでの複数の変数の観察  
 **ウォッチ** ウィンドウでは、複数の変数を観察できます。 たとえば、次のようなコードがあるとします。  
  
```c#  
static void Main(string[] args) { int a, b, c; a = 1; b = 2; c = 0; for (int i = 0; i < 10; i++) { a++; b *= 2; c = a + b; } }  
  
```  
  
 次のように、ウォッチ ウィンドウに 3 つの変数の値を追加します。  
  
1.  `c = a + b;` の行にブレークポイントを設定します。  
  
2.  デバッグを開始します \(**F5**\)。 ブレークポイントで実行が停止します。  
  
3.  ウォッチ ウィンドウを開きます \(**\[デバッグ\]\/\[ウィンドウ\]\/\[ウォッチ\]\/\[ウォッチ 1\]**、または **Ctrl \+ Alt \+ W、1**\)。  
  
4.  最初の行に `a` 変数を追加し、2 番目の行に `b` 変数、3 番目の行に `c` 変数を追加します。  
  
5.  デバッグを続行します。  
  
 `for` ループの反復処理に伴って、表示される変数の値が変わっていくはずです。  
  
 ネイティブ コードでプログラミングしている場合、変数名や変数名を含む式のコンテキストを修飾することが必要になる場合があります。 コンテキストとは、変数が配置される、関数、ソース ファイル、およびモジュールです。 この場合、コンテキスト演算子の構文を使用できます。 詳細については、「式 \(C\+\+\)」を参照してください。  
  
## ウォッチ ウィンドウでの式の観察  
 今度は、代わりに式を使用してみましょう。 デバッガーによって認識される有効な式であれば、どの式でも追加できます。  
  
 たとえば、前のセクションに記載したコードでは、次のようにして 3 つの値の平均を取得できます。  
  
 ![WatchExpression](~/debugger/media/watchexpression.png "WatchExpression")  
  
 一般に、**ウォッチ** ウィンドウで式を評価する場合の規則は、コーディング言語で式を評価する場合の規則と同じです。 式に構文エラーがある場合は、コード エディターで表示されるものと同じコンパイラ エラーを受け取るはずです。 次に例を示します。  
  
 ![WatchExpressionError](~/debugger/media/watchexpressionerror.png "WatchExpressionError")  
  
##  <a name="bkmk_refreshWatch"></a> 古いウォッチ値の更新  
 特定の状況では、**ウォッチ** ウィンドウで式を評価しているときに、更新アイコン \(2 本の矢印の円、または 2 本の波線の円\) が表示されることがあります。  たとえば、プロパティの評価 \(**\[ツール\]\/\[オプション\]\/\[デバッグ\]\/\[プロパティの評価とその他の暗黙的な関数の呼び出しを常に有効にする\]**\) がオフになっていて、次のコードがある場合です。  
  
```c#  
static void Main(string[] args) { List<string> list = new List<string>(); list.Add("hello"); list.Add("goodbye"); }  
  
```  
  
 このリストの `Count` プロパティにウォッチを設定すると、次のようなものが表示されます。  
  
 ![RefreshWatch](../debugger/media/refreshwatch.png "RefreshWatch")  
  
 これは、エラーまたは古い値を示します。 通常はこのアイコンをクリックして値を更新できますが、状況によっては、値を更新したくない場合があるはずです。 まず、値が評価されなかった理由を知る必要があります。  
  
 このアイコンをポイントすると、式が評価されなかった理由がツールヒントに表示されます。 弧を描く矢印が表示された場合、式が評価されなかった理由は次のいずれかです。  
  
-   •	式の評価中にエラーが発生しました。 たとえば、タイムアウトが発生した場合や、変数がスコープ外になった場合などです。  
  
-   •	式に、アプリケーションに副作用を発生させる関数呼び出しが含まれています \([副作用と式](#bkmk_sideEffects) を参照\)。  
  
-   デバッガーによるプロパティの自動評価と暗黙的な関数呼び出し \(**\[ツール\]\/\[オプション\]\/\[デバッグ\]\/\[プロパティの評価とその他の暗黙的な関数の呼び出しを常に有効にする\]**\) がオフにされているため、式を自動的に評価できません。  
  
 値を更新するには、更新アイコンをクリックするか、Space キーを押します。 デバッガーで、式の再評価が試行されます。 プロパティの自動評価と暗黙的な副作用が無効になっていたために更新アイコンが表示された場合は、式を評価できるようになります。  
  
 スレッドを表す 2 本の波線を含む円のアイコンが表示された場合、式が評価されなかった理由は、スレッドの間に依存関係があるためです。 つまり、コードを評価するには、アプリケーションの他のスレッドを一時的に実行することが必要になります。 中断モードの場合、通常、アプリケーションのすべてのスレッドは停止されます。 他のスレッドを一時的に実行できるようにすると、プログラムの状態に予測できない影響を及ぼすことがあり、ブレークポイントやスレッドに対する例外のスローなどのイベントがデバッガーで無視される可能性があります。  
  
##  <a name="bkmk_sideEffects"></a> 副作用と式  
 式を評価すると、変数の値が変わる場合や、プログラムの状態に影響が及ぶ場合があります。 たとえば、次の式を評価すると、`var1` の値が変わります。  
  
```  
var1 = var2  
```  
  
 これを[副作用](https://en.wikipedia.org/wiki/Side_effect_\(computer_science\))と呼びます。 副作用によってプログラムの動作方法が変わると、デバッグがさらに困難になります。  
  
 副作用をもたらすことが既知となっている式は、最初に入力したときに 1 回だけ評価されます。 以降の評価は無効になります。 値の横に表示される更新アイコンをクリックして、手動でこの動作をオーバーライドできます。  
  
 すべての副作用を回避する 1 つの方法は、関数の自動評価 \(**\[ツール\]\/\[オプション\]\/\[デバッグ\]\/\[プロパティの評価とその他の暗黙的な関数の呼び出しを常に有効にする\]**\) をオフにすることです。  
  
 プロパティの評価または暗黙的な関数呼び出しがオフに設定されている場合でも、**ac** 書式修飾子を使用して、強制的に評価できます \(C\# の場合のみ\)。 「[C\# の書式指定子](../debugger/format-specifiers-in-csharp.md)」を参照してください。  
  
## ウォッチ ウィンドウでのオブジェクト ID の使用 \(C\# および Visual Basic\)  
 特定のオブジェクトの動作を観察しなければならないことがあります。その一例は、ローカル変数がスコープ外になった後、その変数が参照するオブジェクトを追跡する必要がある場合です。 C\# と Visual Basic では、参照型の特定のインスタンスのオブジェクト ID を作成し、それらの ID をウォッチ ウィンドウやブレークポイントの条件で使用できます。 オブジェクト ID は、共通言語ランタイム \(CLR\) のデバッグ サービスで生成されて、オブジェクトに関連付けられます。  
  
> [!NOTE]
>  オブジェクト ID による参照は弱参照であり、これによって、オブジェクトがガベージ コレクションの対象から外れることはありません。 オブジェクト ID は、現在のデバッグ セッションでのみ有効です。  
  
 次のコードでは、あるメソッドがローカル変数を使用して `Person` を作成しますが、別のメソッドでの `Person` の名前を調べる必要があります。  
  
```c#  
class Person { public Person(string name) { Name = name; } public string Name { get; set; } } public class Program { List<Person> _people = new List<Person>(); public static void Main(string[] args) { MakePerson(); DoSomething(); } private static void MakePerson() { var p = new Person("Bob"); _people.Add(p); } private static void DoSomething() { // more processing Console.WriteLine("done"); } }  
  
```  
  
 **ウォッチ** ウィンドウでその `Person` オブジェクトへの参照を追加するには、次のようにします。  
  
1.  コードで、オブジェクトが作成されてからしばらく経った時点にブレークポイントを設定します。  
  
2.  デバッグを開始し、ブレークポイントで実行が停止したら、**\[ローカル\]** ウィンドウで対象の変数を見つけて右クリックし、**\[オブジェクト ID の作成\]** を選択します。  
  
3.  **\[ローカル\]** ウィンドウに、**$** が付いた番号が表示されるはずです。 これが、オブジェクト ID です。  
  
4.  このオブジェクト ID をウォッチ ウィンドウに追加します。  
  
5.  オブジェクトの動作を観察する場所にブレークポイントを設定します。  上記のコードで、その場所に該当するのは `DoSomething()` メソッドです。  
  
6.  デバッグを続行します。`DoSomething()` メソッドで実行が停止すると、**ウォッチ** ウィンドウに `Person` オブジェクトが表示されます。  
  
> [!NOTE]
>  オブジェクトのプロパティ \(上記の例では `Person.Name` など\) を確認する必要がある場合、プロパティの評価を有効にしておく必要があります。  
  
## ウォッチ ウィンドウでのレジスタの使用 \(C\+\+ のみ\)  
 ネイティブ コードをデバッグしている場合、変数名と同様に、 **$\<register name\>** または **@\<register name\>** を使用してレジスタ名も追加できます。  詳細については、「[擬似変数](../debugger/pseudovariables.md)」を参照してください。  
  
## 動的ビューとウォッチ ウィンドウ  
 一部のスクリプト言語 \(JavaScript や Python など\) は動的型付けまたは[ダック タイピング](https://en.wikipedia.org/wiki/Duck_typing)を使用しています。また、.NET 言語 \(バージョン 4.0 以降\) は、表示できないランタイム プロパティやメソッドを持つために通常のデバッグ ウィンドウでは観察が困難なオブジェクトをサポートしています。  
  
 [IDynamicMetaObjectProvider インターフェイス](../Topic/IDynamicMetaObjectProvider%20Interface.md) を実装する型から作成されたオブジェクトをウォッチ ウィンドウで表示すると、デバッガーによって特殊な**動的ビュー** ノードが **\[自動変数\]** 表示に追加されます。 このノードには動的オブジェクトの動的メンバーが表示されますが、そのメンバーの値を編集することはできません。  
  
 **動的ビュー**の任意の子を右クリックして **\[ウォッチ式の追加\]** を選択すると、デバッガーはオブジェクトを動的オブジェクトにキャストする新しいウォッチ変数を挿入します。 つまり、**オブジェクト名**が **\(\(動的\) オブジェクト\).名前**になります。  
  
 **動的ビュー**のメンバーを評価すると、副作用が発生する場合があります。 副作用の詳細については、「[副作用と式](#bkmk_sideEffects)」を参照してください。 C\# の場合、コード行の新しいステップに移行したときに、**動的ビュー**に表示される値をデバッガーが自動的に再評価することはありません。 Visual Basic の場合、**動的ビュー**を通じて追加された式は自動的に最新の情報に更新されます。  
  
 動的ビューの値を更新する方法については、「[古いウォッチ値の更新](#bkmk_refreshWatch)」を参照してください。  
  
 あるオブジェクトに対してのみ**動的ビュー**を表示するには、次のように **dynamic** 書式指定子を使用します。  
  
-   C\#: **ObjectName, dynamic**  
  
-   Visual Basic:: **$dynamic, ObjectName**  
  
 **動的ビュー**は、COM オブジェクトのデバッグ機能も強化します。 デバッガーは **System.\_\_ComObject** にラップされた COM オブジェクトを検出すると、そのオブジェクトの**動的ビュー** ノードを追加します。  
  
## 参照  
 [デバッガー ウィンドウ](../debugger/debugger-windows.md)