---
title: Visual Studio での変数にウォッチを設定 |Microsoft Docs
ms.custom: H1Hack27Feb2017
ms.date: 10/11/2018
ms.technology: vs-ide-debug
ms.topic: conceptual
f1_keywords:
- vs.debug.watch
helpviewer_keywords:
- debugging [Visual Studio], Watch window
- expressions [debugger], evaluating
- variables [debugger], evaluating
- expression evaluation
- registers, evaluating
- debugging [Visual Studio], expression evaluation
author: mikejo5000
ms.author: mikejo
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: ad08799c0dce3792e096291dfaf62d52e2515df4
ms.sourcegitcommit: 48bc8492973e93612e5afaba3b47d0f98aecf97c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/15/2018
ms.locfileid: "49325017"
---
# <a name="set-a-watch-on-variables-using-the-watch-and-quickwatch-windows-in-visual-studio"></a>Visual Studio のウォッチ ウィンドウや [クイック ウォッチ] のウィンドウを使用して変数にウォッチを設定します。

使用することができます、デバッグ中、**ウォッチ**と **[クイック ウォッチ]** 変数と式をウォッチする windows。  この 2 つのウィンドウの違いは、 **ウォッチ** ウィンドウでは複数の変数を表示できますが、 **[クイック ウォッチ]** ウィンドウでは一度に 1 つの変数しか表示できないことです。

Windows はデバッグ セッション中にのみ使用できます。 開くには、**ウォッチ**ウィンドウで、選択**デバッグ** > **Windows** > **ウォッチ**を選択し**ウォッチ 1**、 **2 を見る**、 **3 を見る**、または**4 を見る**します。 開くには、 **クイック ウォッチ**ウィンドウで、いずれかの変数を右クリックし  **クイック ウォッチ**、かのみを選んで**デバッグ** > **クイック ウォッチ**.

## <a name="observe-variables-with-the-watch-window"></a>[ウォッチ] ウィンドウで変数を観察します。

複数の変数を観察できます、**ウォッチ**ウィンドウ。 たとえば、次のようなコードがあるとします。

```C++
int main()
{
    int a, b, c;
    a = 1;
    b = 2;
    c = 0;

    for (int i = 0; i < 10; i++)
    {
        a++;
        b *= 2;
        c = a + b;
    }

    return 0;
}

```

3 つの変数の値を追加、**ウォッチ**ウィンドウとして次のとおりです。

1. 選択、`c = a + b;`行。

2. ブレークポイントを設定 (を選択して**デバッグ** > **ブレークポイントの切り替え**か、F9 キーを押す) します。

3. デバッグ (F5) を起動します。 ブレークポイントで実行が停止します。

4. 開く、**ウォッチ**ウィンドウ (選択して**デバッグ** > **Windows** > **ウォッチ** >  **ウォッチ 1**、または Ctrl + Alt + W、1 を押す) します。

5. 空の行を選択し、変数を入力`a`します。 変数のでも同じ処理を行って`b`と`c`します。

   ![変数のウォッチ](../debugger/media/watchvariables.png "WatchVariables")

6. F11 キーを押して、デバッガーを進める必要に応じて、デバッグを続行します。

`for` ループの反復処理に伴って、表示される変数の値が変わっていくはずです。

ネイティブ コードでプログラミングしている場合は、変数名または変数の名前を持つ式のコンテキストを修飾する必要がある場合があります。 コンテキストとは、変数が配置される、関数、ソース ファイル、およびモジュールです。 コンテキストを修飾する場合は、コンテキスト演算子の構文を使用することができます。 詳細については、次を参照してください。 [Context operator (C++)](../debugger/context-operator-cpp.md)します。

## <a name="observe-expressions-with-the-watch-window"></a>ウォッチ ウィンドウで式を確認します。

これで式を代わりを使用してみましょう。 デバッガーによって認識される有効な式であれば、どの式でも追加できます。

たとえば、前のセクションに記載されているコードがある場合は、この式を使用して 3 つの値の平均値を取得できます。

![式をウォッチ](../debugger/media/watchexpression.png "WatchExpression")

式を評価する規則、**ウォッチ**ウィンドウは、通常は、コーディング言語で式を評価するための規則と同じです。 式に構文エラーがある場合は、コード エディターで表示されるのと同じコンパイラ エラーを想定します。 次に例を示します。

![ウォッチ式のエラー](../debugger/media/watchexpressionerror.png "WatchExpressionError")

## <a name="bkmk_refreshWatch"></a> 古いウォッチ値を更新します。

式を評価と、更新アイコン (円形の矢印) が表示される、**ウォッチ**ウィンドウ。 プロパティの評価をオフにした場合 (選択して**ツール** > **オプション** > **デバッグ** >  **一般的な**をオフにし**プロパティの評価とその他の暗黙的な関数呼び出しを有効にする**)、次のコードを記述したとします。

```csharp
static void Main(string[] args)
{
    List<string> list = new List<string>();
    list.Add("hello");
    list.Add("goodbye");
}

```

表示されるはずは次の図のようにウォッチを設定した場合、`Count`リストのプロパティ。

![RefreshWatch](../debugger/media/refreshwatch.png "RefreshWatch")

前の図は、エラーまたは古い値を示します。 一般に、アイコンを選択して値を更新することができますが、場合によってはそれを更新したく可能性があります。 まず、値が評価されなかった理由を把握する必要があります。

ツールヒントは、アイコンをポイントする場合、式が評価されなかった理由に関する情報を提供します。 弧を描く矢印が表示されない場合、式は、次の理由の 1 つの評価されませんでした。

- 式の評価中にエラーが発生しました。 たとえば、タイムアウトが発生した場合や、変数がスコープ外になった場合などです。

- 式には、アプリケーションでの副作用を発生させることが、関数の呼び出し (を参照してください、[副作用と式](#bkmk_sideEffects)セクション)。

- プロパティの自動評価をオフになっているし、暗黙的な関数がデバッガーによって呼び出し (選択して**ツール** > **オプション** > **デバッグ** > **全般**、オフにし**プロパティの評価とその他の暗黙的な関数呼び出しを有効にする**)。 式に自動的に評価できませんします。

値を更新するには、更新アイコンを選択するか、space キーを押します。 デバッガーで、式の再評価が試行されます。 プロパティとその他の暗黙的な関数呼び出しの自動評価をオフにされたので、更新アイコンがあります。 この場合、デバッガーは、式を評価することができます。

アイコンが表示スレッドに似た 2 本の波線の円である可能性があります。 このアイコンは、デバッガーは、潜在的なスレッド間の依存関係のため、式を評価しないことを意味します。 つまり、コードを評価するには、アプリケーションの他のスレッドを一時的に実行することが必要になります。 中断モードの場合、通常、アプリケーションのすべてのスレッドは停止されます。 他のスレッドを一時的に実行できるようにすると、プログラムの状態に予測できない影響を及ぼすことがあり、ブレークポイントやスレッドに対する例外のスローなどのイベントがデバッガーで無視される可能性があります。

## <a name="bkmk_sideEffects"></a> 副作用と式

式を評価すると、変数の値が変わる場合や、プログラムの状態に影響が及ぶ場合があります。 たとえば、次の式を評価すると、 `var1`の値が変わります。

```csharp
var1 = var2
```

このコードが発生することができます、[副作用](https://en.wikipedia.org/wiki/Side_effect_\(computer_science\))します。 副作用によってプログラムの動作方法が変わると、デバッグがさらに困難になります。

副作用がある既知の式は、最初に入力するときに 1 回だけ評価されます。 さらに評価が無効です。 この動作は、値の横に表示される更新アイコンを選択して手動でオーバーライドできます。

すべての副作用を回避する方法の 1 つは、関数の自動評価をオフにする (選択して**ツール** > **オプション** > **デバッグ** > **全般**、オフにし**プロパティの評価とその他の暗黙的な関数呼び出しを有効にする**)。

プロパティの評価または暗黙的な関数呼び出しがオフに設定されている場合でも、 **ac** 書式修飾子を使用して、強制的に評価できます (C# の場合のみ)。 参照してください[書式指定子 (C#)](../debugger/format-specifiers-in-csharp.md)します。

## <a name="bkmk_objectIds"></a> オブジェクト Id を使用して、ウォッチ ウィンドウ (c# および Visual Basic)

特定のオブジェクトの動作を確認することがあります。 たとえば、その変数がスコープ外になった後、ローカル変数で参照先オブジェクトを追跡したい場合があります。 C# および Visual Basic の場合は、参照型の特定のインスタンスのオブジェクト Id を作成してそれらを使用して、**ウォッチ**ウィンドウおよびブレークポイントの条件でします。 オブジェクト ID は、共通言語ランタイム (CLR) のデバッグ サービスで生成されて、オブジェクトに関連付けられます。

> [!NOTE]
> オブジェクト Id は、ガベージ コレクションの対象からオブジェクトを防ぐことはできませんの弱い参照を作成します。 オブジェクト ID は、現在のデバッグ セッションでのみ有効です。

次のコードで 1 つのメソッドを作成、`Person`点について説明しますが、ローカル変数を使用して、`Person`の名前が別のメソッドには。

```csharp
class Person
{
    public Person(string name)
    {
        Name = name;
    }
    public string Name { get; set; }
}

public class Program
{
    static List<Person> _people = new List<Person>();
    public static void Main(string[] args)
    {
        MakePerson();
        DoSomething();
    }

    private static void MakePerson()
    {
        var p = new Person("Bob");
        _people.Add(p);
    }

    private static void DoSomething()
    {
        // more processing
         Console.WriteLine("done");
    }
}

```

`Person` ウォッチ **ウィンドウでその** オブジェクトへの参照を追加するには、次のようにします。

1. オブジェクトが作成されたに発生するコードでは、行を選択します。

2. ブレークポイントを設定 (を選択して**デバッグ** > **ブレークポイントの切り替え**か、F9 キーを押す) します。

3. デバッグを開始します。

4. 実行がブレークポイントで停止したら、開く、**ローカル**ウィンドウ (選択して**デバッグ** > **Windows** > **[ローカル]**) では、変数を右クリックし、選択**オブジェクト ID の作成**です。

   ドル記号を表示する必要があります (**$**) の数値でさらに、**ローカル**ウィンドウで、オブジェクト ID です。

   > [!NOTE]
   > オブジェクトのプロパティを表示する`Person.Name`を選択してプロパティの評価を有効にする必要があります**ツール** > **オプション** >  **デバッグ** > **全般**を設定し、**プロパティの評価とその他の暗黙的な関数呼び出しを有効にする**します。

5. オブジェクト ID を追加、**ウォッチ**ウィンドウには、ドル記号と番号を右クリックし、選択**ウォッチ式の追加**します。

6. オブジェクトの動作を観察するブレークポイントを設定します。  上記のコードであるが、`DoSomething()`メソッド。

7. デバッグを続行します。 実行が停止するときに、`DoSomething()`メソッド、**ウォッチ**ウィンドウが表示されます、`Person`オブジェクト。

## <a name="use-registers-in-the-watch-window-c-only"></a>[ウォッチ] ウィンドウ (C++ のみ) でのレジスタを使用します。

レジスタ名と変数の名前を使用して追加できます **$\<登録&nbsp;名 >** または **@\<登録&nbsp;名 >** ネイティブ コードのデバッグ中にします。 詳細については、「 [Pseudovariables](../debugger/pseudovariables.md)」を参照してください。

## <a name="dynamic-view-and-the-watch-window"></a>動的ビューとウォッチ ウィンドウ

一部のスクリプト言語 (JavaScript や Python など) を使用して、動的または[アヒル](https://en.wikipedia.org/wiki/Duck_typing)、(バージョン 4.0 以降) での .NET 言語サポートのために通常のデバッグ ウィンドウを使用して観察が困難なオブジェクトと、ランタイム プロパティやメソッドを表示できない場合があります。

**ウォッチ**ウィンドウを実装する型から作成される、動的オブジェクトを表示可能性があります、<xref:System.Dynamic.IDynamicMetaObjectProvider>インターフェイス。 デバッガーが特殊なを追加してこのオブジェクトが表示されたら、**動的ビュー**を開く場合は、オブジェクト名の子ノード、 **[自動変数]** ウィンドウ (選択して**デバッグ** >  **Windows** > **[自動変数]**)。 このノードは、動的オブジェクトの動的メンバーを示していますが、メンバーの値の編集を許可しません。

新しいウォッチを挿入するには、変数をキャスト動的オブジェクトをオブジェクトに。

1. 任意の子を右クリックし、**動的ビュー**します。
2. 選択**ウォッチ式の追加**します。 `object.name`なります`((dynamic) object).name`します。

**動的ビュー** のメンバーを評価すると、副作用が発生する場合があります。 副作用の詳細については、次を参照してください。、[副作用と式](#bkmk_sideEffects)セクション。 C# の場合、デバッガーは自動的に再評価に表示される値、**動的ビュー**コードの新しい行をステップ実行する場合。 Visual Basic の場合、 **動的ビュー** を通じて追加された式は自動的に最新の情報に更新されます。

更新する方法については、**動的ビュー**値を参照してください、[最新の更新のウォッチ値](#bkmk_refreshWatch)セクション。

のみを表示する場合、**動的ビュー**オブジェクトは、使用することができます、**動的**書式指定子で、**ウォッチ**ウィンドウ。

- C#: `ObjectName, dynamic`
- Visual Basic: `$dynamic, ObjectName`

**動的ビュー** は、COM オブジェクトのデバッグ機能も強化します。 デバッガーにラップされた COM オブジェクトを取得します**System.__ComObject**、追加、**動的ビュー**オブジェクトのノード。

## <a name="observe-a-single-variable-or-expression-with-quickwatch"></a>1 つの変数または クイック ウォッチの式を確認します。

**[クイック ウォッチ]** ウィンドウでは、1 つの変数を観察できます。 たとえば、次のようなコードがあるとします。

```csharp
static void Main(string[] args)
{
    int a, b;
    a = 1;
    b = 2;
    for (int i = 0; i < 10; i++)
    {
        a = a + b;
    }
}
```

内の変数を観察できます、 **[クイック ウォッチ]** ウィンドウとして次のとおりです。

1. `a = a + b;` の行にブレークポイントを設定します。

2. デバッグを開始します。 ブレークポイントで実行が停止します。

3. 変数を選択`a`します。

4. 選択するか**デバッグ** > **[クイック ウォッチ]** またはキーを押します**shift + f9**します。 **[クイック ウォッチ]** ウィンドウが表示されます。 **値**ボックスで、 `a` 1 の値を持つ変数を表示します。

   ![[クイック ウォッチ] 変数](../debugger/media/quickwatchvariable.png "QuickWatchVariable")

   入力式など、変数を使用して、式を評価する`a + b`を**式**ボックスし、をクリックして**再評価**します。

   ![[クイック ウォッチ] 式](../debugger/media/quickwatchexpression.png "QuickWatchExpression")

   変数または式を追加する、**ウォッチ**からウィンドウ **[クイック ウォッチ]**、選択**ウォッチ式の追加**します。

   > [!NOTE]
   > **[クイック ウォッチ]** ウィンドウは、モーダル ダイアログ ウィンドウで開いている限り、デバッグを続行することはできません。

5. **[クイック ウォッチ]** ウィンドウを閉じます。 これで、 **[ウォッチ]** ウィンドウを閉じます。

## <a name="see-also"></a>関連項目

[デバッガー ウィンドウ](../debugger/debugger-windows.md)
