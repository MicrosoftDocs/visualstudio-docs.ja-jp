---
title: コード マップ
description: コード マップを使用して、コードがどのように整合するかをファイルやコード行に目を通さずに確認する方法について説明します。
ms.custom: SEO-VS-2020
ms.date: 05/16/2018
ms.topic: how-to
f1_keywords:
- vs.progression.codemap
- vs.progression.standardgraphsdialog
helpviewer_keywords:
- DGML
- graph documents
- code visualization [Visual Studio]
- dependencies, visualizing
- dependency graphs
author: JoshuaPartlow
ms.author: joshuapa
manager: jmartens
ms.workload:
- multiple
ms.openlocfilehash: 9723fd44aedf4950b99a49b62d421230b43d55fc
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/08/2021
ms.locfileid: "99946528"
---
# <a name="map-dependencies-with-code-maps"></a>コード マップを使用して依存関係をマップする

コード マップを作成すると、コード全体の依存関係を視覚化できます。 コード マップは、コードがどのように整合するかをファイルやコード行に目を通さずに確認する場合に役立ちます。

![Visual Studio でコード マップを使用して依存関係を表示する](../modeling/media/codemapsmainintro.png)

コード マップの作成および編集には、Visual Studio Enterprise エディションが必要です。 Visual Studio Community および Professional エディションでは、Enterprise エディションで生成されたダイアグラムを開くことはできますが、編集することはできません。

> [!NOTE]
> Visual Studio Enterprise で生成されたマップを、Visual Studio Professional を使用する他のユーザーと 共有する前に、マップ上のすべての項目 (非表示の項目、展開されたグループ、グループ間リンクなど) が表示されていることを確認してください。

次の言語でコードの依存関係をマップできます。

- ソリューションまたはアセンブリ ( *.dll* または *.exe*) の Visual C# または Visual Basic

- Visual C++ プロジェクト、ヘッダー ファイル ( *.h* または `#include`)、またはバイナリのネイティブまたはマネージド C コードまたは C++ コード

- Microsoft Dynamics AX の .NET モジュールから作られた X++ プロジェクトおよびアセンブリ

> [!NOTE]
> C# または Visual Basic 以外のプロジェクトの場合、コード マップを開始したり、既存のコード マップに項目を追加したりするためのオプションは少なくなります。 たとえば、C++ プロジェクトのテキスト エディター内のオブジェクトを右クリックすることも、コード マップにそのオブジェクト追加することもできません。 ただし、**ソリューション エクスプローラー**、**クラス ビュー**、および **オブジェクト ブラウザー** から、個々のコード要素またはファイルをドラッグ アンド ドロップできます。

## <a name="install-code-map-and-live-dependency-validation"></a>コード マップとライブ依存関係検証をインストールする

Visual Studio でコード マップを作成するには、最初に **コード マップ** と **ライブ依存関係検証** の各コンポーネントをインストールします。

1. **Visual Studio インストーラー** を開きます。 これは、Windows の [スタート] メニューから開くことも、Visual Studio 内で **[ツール]**  >  **[ツールと機能の取得]** の順に選択して開くこともできます。

1. **[個々のコンポーネント]** タブを選択します。

1. **[コード ツール]** セクションまで下にスクロールして、 **[コード マップ]** と **[ライブ依存関係検証]** を選択します。

   ![Visual Studio インストーラーでのコード マップとライブ依存関係検証のコンポーネント](media/modeling-components.png)

1. **[変更]** を選択します。

   **コード マップ** と **ライブ依存関係検証** の各コンポーネントのインストールが開始します。 Visual Studio を閉じるように求められる場合があります。

## <a name="add-a-code-map"></a>コード マップを追加する

空のコード マップを作成し、それにアセンブリ参照、ファイル、フォルダーなどの項目をドラッグすることも、ソリューションの全体または一部のコード マップを生成することもできます。

空のコード マップを追加するには:

1. **ソリューション エクスプローラー** で、最上位のソリューション ノードのショートカット メニューを表示します。 **[追加]**  >  **[新しい項目]** の順に選択します。

2. **[新しい項目の追加]** ダイアログで、 **[インストール済み]** の下の **[全般]** カテゴリを選択します。

3. **[有向グラフのドキュメント (.dgml)]** テンプレートを選択してから、 **[追加]** を選択します。

   > [!TIP]
   > このテンプレートはアルファベット順に表示されないことがあるため、確認できない場合はテンプレート一覧の最後まで下にスクロールします。

   空のマップが、現在のソリューションの **[ソリューション項目]** フォルダーに表示されます。

同様に、ソリューションに追加せずに新しいコード マップ ファイルを作成するには、 **[アーキテクチャ]**  >  **[新しいコード マップ]** または **[ファイル]**  >  **[新規作成]**  >  **[ファイル]** の順に選択します。

## <a name="generate-a-code-map-for-your-solution"></a>ソリューションのコード マップを生成する

ソリューション内のすべての依存関係を表示するには:

1. メニュー バーで、 **[アーキテクチャ]**  >  **[ソリューションのコード マップを生成]** の順に選択します。 前回のビルド以降にコードを変更していない場合は、 **[アーキテクチャ]**  >  **[ビルドなしでソリューションのコード マップを生成]** を選択できます。

   ![コード マップ生成コマンド](../modeling/media/codemapsarchitecturemenu.png)

   最上位レベル アセンブリとそれらの間の集約されたリンクを示すマップが生成されます。 集約リンクを広げると、表される依存関係が多くなります。

2. コード マップ ツールバーの **[凡例]** ボタンを使用して、プロジェクトの種類のアイコン (テスト プロジェクト、Web プロジェクト、Phone プロジェクトなど)、コード項目 (クラス、メソッド、プロパティなど)、および関係の種類 (継承元、実装、呼び出しなど) のリストを表示または非表示にします。

   ![アセンブリの最上位の依存関係グラフ](../modeling/media/dependencygraph_toplevelassemblies.png)

   このソリューション例には、ソリューション フォルダー (**[テスト]** と **[コンポーネント]**)、テスト プロジェクト、Web プロジェクト、およびアセンブリが含まれています。 既定では、コンテインメイト リレーションシップはすべて、展開および折りたたみができる *グループ* として表示されます。 **[外部]** グループには、プラットフォームの依存関係など、ソリューションの外部のものがすべて含まれます。 外部アセンブリには、使用中の項目のみが表示されます。 既定では、視認性を高めるため、システムの基本型はマップに表示されません。

3. マップをドリル ダウンするには、プロジェクトおよびアセンブリを表すグループを展開します。 **CTRL キーを押しながら A キー** を押してすべてのノードを選択し、ショートカット メニューから **[グループ]**、 **[展開]** の順に選択すると、すべてを展開できます。

   ![コード マップ内のすべてのグループを展開する](../modeling/media/codemapsexpandallgroups.png)

4. ただし、これは大規模なソリューションには不向きな場合があります。 実際、複雑なソリューションでは、メモリ制限のためにすべてのグループを展開できない場合があります。 代わりに、個々のノードを展開して内部を表示します。 マウス ポインターをノード上に移動し、シェブロン (下矢印) が表示されたらクリックします。

   ![コード マップ内のノードを展開する](../modeling/media/dependencygraph_containment.png)

   または、キーボードを使用して項目を選択し、プラス キー ( **+** ) を押します。 さらに深いレベルのコードを確認するには、名前空間、型、およびメンバーに対して同じ操作を行います。

   > [!TIP]
   > マウス、キーボード、およびタッチを使用したコード マップ操作の詳細については、「[コード マップの参照および再配置](../modeling/browse-and-rearrange-code-maps.md)」を参照してください。

5. マップを簡略化し個々の部分に注目するには、コード マップ ツールバーで **[フィルター]** を選択し、必要なノードおよびリンクの種類だけを選択します。 たとえば、すべてのソリューション フォルダーとアセンブリのコンテナーを非表示にできます。

   ![コンテナーをフィルター処理して、マップを簡略化する](../modeling/media/codemapsfilterfoldersassemblies.png)

   個々のグループおよび項目をマップで非表示にしたりマップから削除したりして、マップを簡略化できます。この操作は、基のソリューション コードには影響を与えません。

6. 項目間のリレーションシップを表示するには、マップでそれらを選択します。 リンクの色は、 **[凡例]** ウィンドウの表示に対応しており、リレーションシップの種類を表しています。

   ![ソリューション間の依存関係を表示する](../modeling/media/codemapsmainintro.png)

   この例で、紫色のリンクは呼び出し、点線のリンクは参照、および薄青色のリンクはフィールド アクセスを表しています。 緑色のリンクは継承を表す場合もありますが、複数のリレーションシップ (または *カテゴリ* ) の種類を表す *集約リンク* の可能性もあります。

   > [!TIP]
   > 緑色のリンクが表示されている場合、単に継承関係の存在のみを示しているわけではない可能性があります。 メソッドの呼び出しも存在する場合がありますが、これらは継承関係によって非表示になっています。 特定の種類のリンクを表示するには、 **[フィルター]** ウィンドウ内のチェック ボックスを使用して、必要のない種類を非表示にします。

7. 項目またはリンクに関する詳細情報を確認するには、ポインターをその項目の上に移動してツールヒントを表示します。 これにより、コード要素またはリンクが表すカテゴリの詳細が表示されます。

   ![リレーションシップのカテゴリを表示する](../modeling/media/codemapsshowlinkcatgories.png)

8. 集約リンクによって表される項目と依存関係を調べるには、最初にリンクを選択して、そのショートカット メニューを開きます。 **[寄与するリンクの表示]** または **[新しいコード マップ上の寄与するリンクの表示]** をクリックします。 これにより、リンクの両端のグループが展開され、リンクに関係する項目と依存関係のみが表示されます。

9. マップの特定の部分に注目するために、必要のない項目を継続的に削除することができます。 たとえば、クラス ビューとメンバー ビューを詳細表示するには、 **[フィルター]** ウィンドウですべての名前空間ノードをフィルター処理するだけです。

   ![クラスとメンバーのレベルまでグループをドリルダウンする](../modeling/media/dependencygraph_expandedselectedgroups_2012.png)

10. 複雑なソリューション マップで必要な項目に注目するもう 1 つの方法は、既存のマップから、選択した項目を含む新しいマップを生成することです。 **Ctrl** キーを押しながら注目する項目を選択し、ショートカット メニューを開き、 **[選択項目から新しいグラフを作成]** をクリックします。

    ![選択された項目を新しいコード マップに表示する](../modeling/media/codemapsshowonnewmap.png)

11. 含んでいるコンテキストは、新しいマップに引き継がれます。 **[フィルター]** ウィンドウを使用して、ソリューション フォルダーや表示する必要のない他のすべてのコンテナーを非表示にします。

    ![コンテナーをフィルター処理してビューを簡略化する](../modeling/media/codemapsexpandnewgroups.png)

12. グループを展開し、リレーションシップを表示するマップ内の項目を選択します。

    ![リレーションシップを表示する項目を選択する](../modeling/media/codemapsviewnewrelationships.png)

こちらもご覧ください。

- [コード マップの参照および再配置](../modeling/browse-and-rearrange-code-maps.md)
- [DGML ファイルを編集してコード マップをカスタマイズする](../modeling/customize-code-maps-by-editing-the-dgml-files.md)
- [アナライザーを実行](../modeling/find-potential-problems-using-code-map-analyzers.md)してコード内の潜在的な問題を検索する

## <a name="view-specific-dependencies-in-a-code-map"></a>特定の依存関係をコード マップに表示する

保留中の変更が含まれるいくつかのファイルでコード レビューを行うとします。 これらの変更の依存関係を表示するため、これらのファイルからコード マップを作成できます。

   ![特定の依存関係をコード マップに表示する](../modeling/media/codemapsspecificdependenciesintro.png)

1. **ソリューション エクスプローラー** で、マップするプロジェクト、アセンブリ参照、フォルダー、ファイル、型、またはメンバーを選択します。

   ![マップする項目を選択する](../modeling/media/codemapsselectinsolutionexplorer.png)

1. **ソリューション エクスプローラー** のツールバーで、 **[コード マップに表示]** ![[選択したノードから新しいグラフを作成] ボタン](../modeling/media/createnewgraphfromselectedbutton.gif) をクリックします。 または、1 つまたは 1 グループの項目のショートカット メニューを開き、 **[コード マップに表示]** をクリックします。

   **ソリューション エクスプローラー**、**クラス ビュー**、または **オブジェクト ブラウザー** から[新規](#add-a-code-map)または既存のコード マップに項目をドラッグすることもできます。 項目の親階層を含めるには、**Ctrl** キーを押したまま項目をドラッグするか、コード マップ ツールバーで **[親を含める]** ボタンを使用して既定のアクションを指定します。 また、Visual Studio の外部 (**Windows エクスプローラー** など) からアセンブリ ファイルをドラッグすることもできます。

   > [!NOTE]
   > Windows Phone または Microsoft ストアなどの複数のアプリで共有されるプロジェクトから項目を追加すると、その項目は、現在アクティブなアプリ プロジェクトと共にマップに表示されます。 コンテキストを別のアプリ プロジェクトに変更し、共有プロジェクトからさらに項目を追加した場合、その項目は、新しくアクティブになったアプリ プロジェクトと共に表示されます。 マップ上の項目に実行する操作は、同じコンテキストを共有する項目にのみ適用されます。

3. アセンブリ内の選択した項目がマップに表示されます。

   ![マップでグループとして表示するように選択された項目](../modeling/media/codemapsshowitemsfromsolnexplorer.png)

4. 項目を確認するには、その項目を展開します。 マウス ポインターを項目の上に移動し、シェブロン (下矢印) アイコンが表示されたらクリックします。

   ![コード マップ内のノードを展開する](../modeling/media/dependencygraph_containment.png)

   すべての項目を展開するには、**Ctrl**+**A** キーを使用してそれらを選択してから、マップのショートカット メニューを開いて、 **[グループ]**  >  **[展開]** の順にクリックします。 ただし、すべてのグループを展開すると使用に適さないマップになったりメモリの問題が発生したりする場合、このオプションは使用できません。

5. 確認したい項目を、必要に応じてクラスやメンバーのレベルまで展開します。

   ![クラスとメンバーのレベルにグループを展開する](../modeling/media/codemapsexpandtoclassandmember.png)

   コードに含まれているのにマップに表示されていないメンバーを表示するには、グループの左上にある **[子の再フェッチ]** アイコン ![[子の再フェッチ] アイコン](../modeling/media/dependencygraph_deletednodesicon.png) をクリックします。

6. マップ上の項目に関連する項目をさらに表示するには、1 つを選択し、コード マップ ツールバーで **[関連表示]** を選択して、マップに追加する関連項目の種類を選択します。 あるいは、1 つまたは複数の項目を選択し、ショートカット メニューを開いてから、マップに追加する関連項目の種類の **[表示]** オプションを選択します。 次に例を示します。

    **アセンブリ** の場合、次のように選択します。

    |オプション|説明|
    |-|-|
    |**参照されるアセンブリの表示**|このアセンブリの参照先のアセンブリを追加します。 外部アセンブリは **[外部]** グループに表示されます。|
    |**参照元のアセンブリの表示**|このアセンブリを参照するソリューション内のアセンブリを追加します。|

    **名前空間** の場合、表示されていなければ、 **[含んでいるアセンブリの表示]** をクリックします。

    **クラス** または **インターフェイス** の場合は、次から選択します。

    |オプション|説明|
    |-|-|
    |**基本型の表示**|クラスの場合、基底クラスおよび実装されたインターフェイスを追加します。<br /><br /> インターフェイスの場合、基本インターフェイスを追加します。|
    |**派生型の表示**|クラスの場合、派生クラスを追加します。<br /><br /> インターフェイスの場合、派生インターフェイスと、実装するクラスまたは構造体を追加します。|
    |**参照される型の表示**|すべてのクラスと、このクラスが使用するメンバーを追加します。|
    |**参照元の型の表示**|すべてのクラスと、このクラスを使用するメンバーを追加します。|
    |**含んでいる名前空間の表示**|親の名前空間を追加します。|
    |**含んでいる名前空間とアセンブリの表示**|親コンテナーの階層を追加します。|
    |**すべての基本型の表示**|基底クラスまたはインターフェイス階層を再帰的に追加します。|
    |**すべての派生型の表示**|クラスの場合、すべての派生クラスを再帰的に追加します。<br /><br /> インターフェイスの場合、すべての派生インターフェイスと、実装するクラスまたは構造体を再帰的に追加します。|

     **メソッド** の場合、次から選択します。

    |オプション|説明|
    |-|-|
    |**呼び出されるメソッドの表示**|このメソッドが呼び出すメソッドを追加します。|
    |**参照されるフィールドの表示**|このメソッドが参照するフィールドを追加します。|
    |**含んでいる型の表示**|親の型を追加します。|
    |**含んでいる型、名前空間、およびアセンブリの表示**|親コンテナーの階層を追加します。|
    |**オーバーライドされたメソッドの表示**|他のメソッドをオーバーライドするか、インターフェイスのメソッドを実装するメソッドの場合、オーバーライドされた基底クラスのすべての抽象メソッドまたは仮想メソッド、および実装されたインターフェイスのメソッドがある場合はそのメソッドを追加します。|

     **フィールド** または **プロパティ** の場合、次から選択します。

    |オプション|説明|
    |-|-|
    |**含んでいる型の表示**|親の型を追加します。|
    |**含んでいる型、名前空間、およびアセンブリの表示**|親コンテナーの階層を追加します。|

    ![このメンバーによって呼び出されるメソッドを表示する](../modeling/media/codemapsshowrelatedmethods.png)

7. マップには、リレーションシップが表示されます。 この例では、`Find` メソッドによって呼び出されるメソッド、およびそれらのメソッドの場所 (ソリューション内あるいは外部) がマップに表示されます。

   ![特定の依存関係をコード マップに表示する](../modeling/media/codemapsspecificdependenciesintro.png)

8. マップを簡略化し個々の部分に注目するには、コード マップ ツールバーで **[フィルター]** を選択し、必要なノードおよびリンクの種類だけを選択します。 たとえば、ソリューション フォルダー、アセンブリ、および名前空間の表示をオフにします。

   ![フィルター ペインを使用して表示を簡略化する](../modeling/media/almcodemapfilterpane.png)

## <a name="see-also"></a>関連項目

- [ビデオ: Visual Studio 2015 コード マップを使用してコードからのデザインを理解する](https://channel9.msdn.com/Events/Visual-Studio/Connect-event-2015/502)
- [コード マップを使用してアプリケーションをデバッグする](../modeling/use-code-maps-to-debug-your-applications.md)
- [デバッグを行うときの呼び出し履歴に対するメソッドのマップ](../debugger/map-methods-on-the-call-stack-while-debugging-in-visual-studio.md)
- [コード マップ アナライザーを使用して潜在的な問題を検索する](../modeling/find-potential-problems-using-code-map-analyzers.md)
- [コード マップの参照および再配置](../modeling/browse-and-rearrange-code-maps.md)
- [DGML ファイルを編集してコード マップをカスタマイズする](../modeling/customize-code-maps-by-editing-the-dgml-files.md)
