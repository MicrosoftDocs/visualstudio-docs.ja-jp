---
title: "要素作成処理および要素移動処理のカスタマイズ | Microsoft Docs"
ms.custom: ""
ms.date: "12/15/2016"
ms.prod: "visual-studio-tfs-dev14"
ms.reviewer: ""
ms.suite: ""
ms.tgt_pltfrm: ""
ms.topic: "article"
f1_keywords: 
  - "vs.dsltools.dsldesigner.elementmergedirective"
helpviewer_keywords: 
  - "ドメイン固有言語、要素マージ ディレクティブ"
ms.assetid: cbd28f15-dfd7-46bd-ab79-5430e3ed83c8
caps.latest.revision: 36
caps.handback.revision: 36
author: "alancameronwills"
ms.author: "awills"
manager: "douge"
---
# 要素作成処理および要素移動処理のカスタマイズ
[!INCLUDE[vs2017banner](../code-quality/includes/vs2017banner.md)]

要素をツールボックスまたは貼り付けでは、別にドラッグするか、操作を移動することができます。 指定したリレーションシップを使用して移動した要素をターゲット要素にリンクされていることができます。  
  
 要素マージ ディレクティブ (EMD) は、1 つのモデル要素が場合の動作を指定 *結合* 別のモデル要素にします。 これは、発生時にします。  
  
-   ユーザーは、ツールボックスから図や図形にドラッグします。  
  
-   ユーザーは、エクスプ ローラーまたはコンパートメント シェイプで、[追加] メニューを使用して要素を作成します。  
  
-   ユーザーは、1 つのレーンから項目を移動します。  
  
-   ユーザーは、要素を貼り付けます。  
  
-   プログラム コードでは、要素マージ ディレクティブを呼び出します。  
  
 作成操作は、コピー操作を異なる見えますが、動作は同じ方法でが実際に表示。 要素が追加されると、次に例をツールボックスから、そのプロトタイプはレプリケートされます。 プロトタイプは、モデルの別の部分からコピーされた要素と同じ方法で、モデルにマージされます。  
  
 EMD の責任では、どのオブジェクトまたはオブジェクトのグループにマージするモデルの特定の場所を決定します。 具体的には、モデルに結合されたグループにリンクするどのようなリレーションシップをインスタンス化する必要がありますを決定します。 プロパティを設定して、その他のオブジェクトを作成することをカスタマイズすることもできます。  
  
 ![DSL & #45 です。EMD & #95 です。マージ](../modeling/media/dsl-emd_merge.png "DSL-EMD_Merge")  
要素マージ ディレクティブの役割  
  
 EMD は、埋め込みリレーションシップを定義するときに自動的に生成されます。 この既定 EMD は、親の子の新しいインスタンスを追加すると、リレーションシップのインスタンスを作成します。 これら既定入力例: は、カスタム コードを追加することで次に例を変更できます。  
  
 ユーザーがドラッグするか、マージされた側と受信側のクラスのさまざまな組み合わせを貼り付けできるように、DSL 定義で、独自の入力例: を追加することもできます。  
  
## <a name="defining-an-element-merge-directive"></a>要素マージ ディレクティブを定義します。  
 ドメイン クラス、ドメイン リレーションシップ、図形、コネクタ、図へ要素マージ ディレクティブを追加することができます。 追加したり、受信側のドメイン クラスの下の DSL エクスプ ローラーで確認できます。 受信側のクラスは、モデルでは、新規またはコピーした要素をマージするのには、既に要素のドメイン クラス。  
  
 ![DSL & #45 です。EMD &#95; の詳細](../modeling/media/dsl-emd_details.png "DSL-EMD_Details")  
  
  **クラスのインデックス作成** 受信側のクラスのメンバーに結合できる要素のドメイン クラスです。 設定していない場合も、インデックス作成クラスのサブクラスのインスタンスをマージによってこの EMD が **サブクラスに適用されます** を False にします。  
  
 マージ ディレクティブの 2 つの種類があります。  
  
-   A **プロセス マージ** ディレクティブがツリーに新しい要素をリンクする必要がありますのリレーションシップを指定します。  
  
-   A **フォワード マージ** ディレクティブでは、新しい要素を別の受信側要素、親では通常にリダイレクトします。  
  
 ディレクティブを結合するカスタム コードを追加することができます。  
  
-   設定 **使用してカスタム受け入れ** インデックスの要素の特定のインスタンスを対象となる要素にマージするかどうかを決定するコードを追加します。 ユーザーは、ツールボックスからドラッグした、コードが、マージを許可しません「無効」ポインターが表示されます。  
  
     たとえば、受信側の要素が特定の状態になっている場合にのみ、マージを許可可能性があります。  
  
-   設定 **使用してカスタムのマージ** を追加する、マージが実行されるときに、モデルに加えられた変更を定義する独自のコードを指定します。  
  
     たとえば、モデル内の新しい場所からデータを使用してマージされた要素のプロパティを設定する可能性があります。  
  
> [!NOTE]
>  カスタムのマージのコードを記述する場合は、この EMD を使用して実行される唯一の結合に影響します。 他の入力の例: 同じ種類のオブジェクトをマージする場合、または、EMD を使用せずにこれらのオブジェクトを作成するその他のカスタム コードがある場合は、し、それらは受けません、カスタムのマージのコードです。  
>   
>  新しい要素または新しいリレーションシップが、カスタム コードで処理は常にことを確認する場合は、定義することを検討してください、 `AddRule` 埋め込みリレーションシップに対して、 `DeleteRule` 要素のドメイン クラスにします。 詳細については、次を参照してください。 [ルール反映されるまで変更内で、モデル](../modeling/rules-propagate-changes-within-the-model.md)します。  
  
## <a name="example-defining-an-emd-without-custom-code"></a>例: カスタム コードがなくても EMD を定義します。  
 次の例では、既存の図形には、ツールボックスからドラッグして、同時に要素およびコネクタを作成できます。 例では、DSL 定義に EMD を追加します。 この変更を行ってから図に、既存の図形の上にないユーザーがツールをドラッグすることができます。  
  
 ユーザーでは、その他の要素に要素を貼り付けることもできます。  
  
#### <a name="to-let-users-create-an-element-and-a-connector-at-the-same-time"></a>ユーザーが同時に、要素とコネクタを作成できるようにするには  
  
1.  使用して新規 DSL を作成、 **最小言語** ソリューション テンプレートです。  
  
     この DSL を実行すると、図形と図形間のコネクタを作成することができます。 新しいをドラッグすることはできません **ExampleElement** 既存の図形には、ツールボックスから図形です。  
  
2.  ユーザーが上に要素をマージできるように `ExampleElement` 図形に新しい EMD の作成、 `ExampleElement` ドメイン クラス。  
  
    1.   **DSL エクスプ ローラー**, 、展開 **ドメイン クラス**します。 右クリック `ExampleElement` ] をクリックし、 **新しい要素マージ ディレクティブの追加**します。  
  
    2.  確認して、 **DSL 詳細** 新しい EMD の詳細を表示できるように、ウィンドウが開いています。 (メニュー: **表示**, 、**他の Windows**, 、**DSL 詳細**.)  
  
3.  設定、 **クラスをインデックス作成** DSL 詳細] ウィンドウの上にマージできる要素のクラスを定義する `ExampleElement` オブジェクトです。  
  
     この例では、選択 `ExampleElements`, 、ユーザーは、既存の要素に新しい要素をドラッグできるようにします。  
  
     インデックス作成クラスになる EMD DSL エクスプ ローラーでの名前に注意してください。  
  
4.   **へのリンクを作成することでプロセス マージ**, 、2 つのパスを追加します。  
  
    1.  1 つのパスは、新しい要素を親モデルにリンクします。 パス式を入力する必要があるが移動既存の要素からの埋め込みリレーションシップ親モデルにします。 最後に、新しい要素の割り当て先となる新しいリンクで、ロールを指定します。 パスは次のとおりです。  
  
         `ExampleModelHasElements.ExampleModel/!ExampleModel/.Elements`  
  
    2.  もう一方のパスは、新しい要素を既存の要素にリンクします。 パス式では、参照リレーションシップと、新しい要素の割り当てられた役割を指定します。 このパスは次のとおりです。  
  
         `ExampleElementReferencesTargets.Sources`  
  
     パスのナビゲーション ツールを使用して、各パスを作成することができます。  
  
    1.  [ **パスにあるリンクを作成することでプロセス マージ**, 、] をクリックして **\< パスを追加>**します。  
  
    2.  リスト アイテムの右側にドロップダウン矢印をクリックします。 ツリー ビューが表示されます。  
  
    3.  指定するパスを形成するツリーのノードを展開します。  
  
5.  DSL をテストします。  
  
    1.  F5 キーを押して、ソリューションを再構築および実行します。  
  
         再構築がかかります通常よりも、新しい DSL 定義に準拠するように、テキスト テンプレートから生成されたコードが更新されるため。  
  
    2.  時の実験用インスタンス [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)] が開始されると、DSL のモデル ファイルを開きます。 いくつかの例の要素を作成します。  
  
    3.  ドラッグして、 **例要素** 既存の図形の上にツールです。  
  
         新しい図形が表示され、既存のコネクタと図形へのリンクがします。  
  
    4.  既存の図形をコピーします。 別の図形を選択し、貼り付けます。  
  
         最初の図形のコピーが作成されます。  新しい名前と、コネクタで 2 番目の図形へのリンクができます。  
  
 このプロシージャから、次の点に注意してください。  
  
-   要素マージ ディレクティブを作成すると、その他のまま使用する要素の任意のクラスを許可できます。 受信側のドメイン クラスで、EMD を作成し、承認済みドメイン クラスがで指定された、 **Index クラス** フィールドです。  
  
-   パスを定義すると、どのようなリンクにする必要がありますを指定できます、既存のモデルに新しい要素の接続に使用します。  
  
     指定したリンクは、1 つの埋め込みリレーションシップを含める必要があります。  
  
-   EMD は、両方の作成からツールボックス ペインとも貼り付け操作に影響します。  
  
     使用して、EMD を明示的に呼び出す新しい要素を作成するカスタム コードを記述する場合、 `ElementOperations.Merge` メソッドです。 これにより、コードが、その他の操作と同じ方法でモデルに新しい要素をリンクすることを確認します。 詳細については、次を参照してください。 [コピー動作のカスタマイズ](../modeling/customizing-copy-behavior.md)します。  
  
## <a name="example-adding-custom-accept-code-to-an-emd"></a>例: EMD へカスタム受け入れコードを追加します。  
 に EMD をカスタム コードを追加するには、より複雑な結合の動作を定義できます。 この簡単な例では、ユーザーが要素の固定数よりも多く、ダイアグラムに追加できなくなります。 例では、既定の埋め込みリレーションシップに付属している EMD を変更します。  
  
#### <a name="to-write-custom-accept-code-to-restrict-what-the-user-can-add"></a>追加できるユーザーを制限するカスタム受け入れのコードを記述するには  
  
1.  使用して DSL を作成、 **最小言語** ソリューション テンプレートです。 DSL 定義図を開きます。  
  
2.  DSL エクスプ ローラーで、 **ドメイン クラス**, 、`ExampleModel`, 、**要素マージ ディレクティブ**します。 要素マージ ディレクティブという名前を選択して `ExampleElement`します。  
  
     この EMD は、ユーザーを新規作成方法を制御 `ExampleElement` 、ツールボックスからドラッグして、たとえば、モデル内のオブジェクト。  
  
3.   **DSL 詳細** ウィンドウで、 **使用してカスタム受け入れ**します。  
  
4.  ソリューションをリビルドします。 モデルから生成されたコードが更新されるため、通常より時間がかかります。  
  
     報告された場合と同様に、ビルド エラーが表示されます:「Company.ElementMergeSample.ExampleElement 値を含まない定義 CanMergeExampleElement の...」  
  
     メソッドを実装する必要があります `CanMergeExampleElement`します。  
  
5.  新しいコード ファイルを作成、 **Dsl** プロジェクトです。 その内容を次のコードに置き換え、プロジェクトの名前空間の名前空間を変更します。  
  
    ```c#  
    using Microsoft.VisualStudio.Modeling;  
  
    namespace Company.ElementMergeSample // EDIT.  
    {  
      partial class ExampleModel  
      {  
        /// <summary>  
        /// Called whenever an ExampleElement is to be merged into this ExampleModel.  
        /// This happens when the user pastes an ExampleElement  
        /// or drags from the toolbox.  
        /// Determines whether the merge is allowed.  
        /// </summary>  
        /// <param name="rootElement">The root element in the merging EGP.</param>  
        /// <param name="elementGroupPrototype">The EGP that the user wants to merge.</param>  
        /// <returns>True if the merge is allowed</returns>  
        private bool CanMergeExampleElement(ProtoElementBase rootElement, ElementGroupPrototype elementGroupPrototype)  
        {  
          // Allow no more than 4 elements to be added:  
          return this.Elements.Count < 4;  
        }  
      }  
    }  
  
    ```  
  
     この簡単な例では、親モデルに結合できる要素数を制限します。 さらに興味深い条件は、メソッドは任意のプロパティと受信側のオブジェクトのリンクを検査できます。 含まれる、結合の要素のプロパティを確認しても、 <xref:Microsoft.VisualStudio.Modeling.ElementGroupPrototype>します。 詳細については `ElementGroupPrototypes`, を参照してください [コピー動作のカスタマイズ](../modeling/customizing-copy-behavior.md)します。 モデルを読み取るコードを記述する方法に関する詳細については、次を参照してください。 [ナビゲートおよびプログラム コードでモデルを更新](../modeling/navigating-and-updating-a-model-in-program-code.md)します。  
  
6.  DSL をテストします。  
  
    1.  F5 キーを押して、ソリューションをリビルドします。 時の実験用インスタンス [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)] が開き、DSL のインスタンスを開きます。  
  
    2.  いくつかの方法で新しい要素を作成します。  
  
        1.  ドラッグして、 **例要素** ツールを図にします。  
  
        2.   **例モデル エクスプ ローラー**, ルート ノードを右クリックし、[クリックして **新しい例の Add 要素**します。  
  
        3.  コピーし、図上の要素を貼り付けます。  
  
    3.  モデルに複数の 4 つの要素を追加する方法はこれらのいずれか使用できないことを確認します。 これは、要素マージ ディレクティブを使用するためです。  
  
## <a name="example-adding-custom-merge-code-to-an-emd"></a>例: EMD へカスタムのマージのコードを追加します。  
 カスタムのマージのコードでは、ユーザーがツールをドラッグまたは要素に貼り付けますときの動作を定義できます。 カスタムのマージを定義する 2 つの方法があります。  
  
1.  設定 **を使用してカスタム マージ** し、必要なコードを指定します。 コードでは、生成されたマージのコードを置き換えます。 マージの実行内容を完全に再定義する場合は、このオプションを使用します。  
  
2.  オーバーライド、 `MergeRelate` メソッド、および必要に応じて、 `MergeDisconnect` メソッドです。 これを行うには、設定する必要があります、 **Double Derived の生成** ドメイン クラスのプロパティです。 コードでは、基本クラスで生成されたマージのコードを呼び出すことができます。 マージが実行された後に、追加の操作を実行する場合は、このオプションを使用します。  
  
 これらの方法では、この EMD を使用して実行されるマージのみ影響します。 定義する別の方法は、マージされた要素を作成できますすべての方法に影響する場合、 `AddRule` 埋め込みリレーションシップに対して、 `DeleteRule` マージされたドメイン クラスにします。 詳細については、次を参照してください。 [ルール反映されるまで変更内で、モデル](../modeling/rules-propagate-changes-within-the-model.md)します。  
  
#### <a name="to-override-mergerelate"></a>MergeRelate をオーバーライドするには  
  
1.  DSL 定義では、コードを追加する EMD が定義されていることを確認します。 パスを追加して定義できる場合は、ユーザー設定は、前のセクションで説明したようにコードをそのまま使用します。  
  
2.  DslDefinition 図では、マージの受信側のクラスを選択します。 通常は埋め込みリレーションシップのソース end クラスです。  
  
     たとえば、最小言語ソリューションから生成された DSL で次のように選択します。 `ExampleModel`します。  
  
3.   **プロパティ** ウィンドウで、設定 **Double Derived の生成** に **true**します。  
  
4.  ソリューションをリビルドします。  
  
5.  内容を調べる **Dsl\Generated Files\DomainClasses.cs**します。 という名前のメソッドの検索 `MergeRelate` の内容を調べる。 独自のバージョンを作成するのに役立ちます。  
  
6.  新しいコード ファイルで、受信側のクラスの部分クラスを記述し、オーバーライド、 `MergeRelate` メソッドです。 基本メソッドを呼び出すようにしてください。 例:  
  
    ```c#  
    partial class ExampleModel  
    {  
      /// <summary>  
      /// Called when the user drags or pastes an ExampleElement onto the diagram.  
      /// Sets the time of day as the name.  
      /// </summary>  
      /// <param name="sourceElement">Element to be added</param>  
      /// <param name="elementGroup">Elements to be merged</param>  
      protected override void MergeRelate(ModelElement sourceElement, ElementGroup elementGroup)  
      {  
        // Connect the element according to the EMD:  
        base.MergeRelate(sourceElement, elementGroup);  
  
        // Custom actions:   
        ExampleElement mergingElement = sourceElement as ExampleElement;  
        if (mergingElement != null)  
        {  
          mergingElement.Name = DateTime.Now.ToLongTimeString();  
        }  
      }  
    }  
  
    ```  
  
#### <a name="to-write-custom-merge-code"></a>カスタムのマージのコードを記述するには  
  
1.   **Dsl\Generated Code\DomainClasses.cs**, 、という名前のメソッドを調べる `MergeRelate`します。 これらのメソッドは、新しい要素と、既存のモデル間のリンクを作成します。  
  
     またという名前のメソッドを調べて `MergeDisconnect`します。 これらのメソッドには、それを削除するときに、モデルの要素がリンクを解除します。  
  
2.   **DSL エクスプ ローラー**, を選択するかをカスタマイズする要素マージ ディレクティブを作成します。  **DSL 詳細** ウィンドウで、設定 **を使用してカスタム マージ**します。  
  
     このオプションを設定すると、 **プロセス マージ** と **フォワード マージ** オプションは無視されます。 コードは、代わりに使用されます。  
  
3.  ソリューションをリビルドします。 モデルから生成されたコード ファイルが更新されますので通常よりも長くかかります。  
  
     エラー メッセージが表示されます。 生成されたコードで説明するエラー メッセージをダブルクリックします。 次の手順では、2 つの方法を提供するよう求められます `MergeRelate`*YourDomainClass* と `MergeDisconnect`*YourDomainClass*  
  
4.  別のコード ファイルの部分クラス定義でメソッドを記述します。 例では、前の手順を検査する必要がありますおくべきことをお勧めします。  
  
 カスタムのマージのコードを直接オブジェクトとリレーションシップを作成するコードには影響せず、その他の入力例: には影響しません。 要素を作成する方法に関係なく、追加の変更が実装されていることを確認するには、書き込みを検討してください。、 `AddRule` と `DeleteRule` 代わりにします。 詳細については、次を参照してください。 [ルール反映されるまで変更内で、モデル](../modeling/rules-propagate-changes-within-the-model.md)します。  
  
## <a name="redirecting-a-merge-operation"></a>マージ操作をリダイレクトします。  
 前方のマージ ディレクティブは、マージ操作の対象をリダイレクトします。 通常、新しいターゲットは、最初のターゲットの埋め込みの親です。  
  
 たとえば、コンポーネント図のテンプレートを使用して作成された、DSL では、ポートはコンポーネントに埋め込まれます。 ポートは、コンポーネント図形の端にある小さなシェイプとして表示されます。 ユーザーは、コンポーネント図形にポート ツールをドラッグして、ポートを作成します。 場合によっては、ユーザーが誤って、コンポーネントの代わりに、既存のポートにポート ツールをドラッグし、操作は失敗します。 これは、いくつかの既存のポートがある場合の簡単なミスです。 ユーザーをこの妨害を回避するために、既存のポートにドラッグすることが、親コンポーネントにリダイレクト操作がある場合にポートを許可できます。 操作は、対象となる要素が、コンポーネントであるかのように動作します。  
  
 前方のマージ ディレクティブは、コンポーネント モデル ソリューションに作成できます。 コンパイルして、元のソリューションを実行するはずのユーザーが任意の数をドラッグできます **入力ポートは** または **出力ポート** からの要素、 **ツールボックス** に、 **コンポーネント** 要素。 ただし、既存のポートにポートをドラッグすることができません。 利用不可のポインターは、この移動が有効でないことに警告します。 されるよう、ポートを意図せずに、前方のマージ ディレクティブを作成するただし、削除、既存の **入力ポートは** に転送、 **コンポーネント** 要素。  
  
#### <a name="to-create-a-forward-merge-directive"></a>前方のマージ ディレクティブを作成するには  
  
1.  作成、 [!INCLUDE[dsl](../modeling/includes/dsl_md.md)] コンポーネント モデル テンプレートを使用してソリューションです。  
  
2.  表示、 **DSL エクスプ ローラー** DslDefinition.dsl を開きます。  
  
3.   **DSL エクスプ ローラー**, 、展開 **ドメイン クラス**します。  
  
4.   **ComponentPort** 抽象ドメイン クラスは両方の基本クラス **InPort** と **OutPort**します。 右クリック **ComponentPort** ] をクリックし、 **新しい要素マージ ディレクティブの追加**します。  
  
     新しい **要素マージ ディレクティブ** ノードのもとで、 **要素マージ ディレクティブ** ノードです。  
  
5.  選択、 **要素マージ ディレクティブ** ノードとオープン、 **DSL 詳細** ウィンドウです。  
  
6.  インデックス作成クラスの一覧で選択 **ComponentPort**します。  
  
7.  選択 **別のドメイン クラスへのマージを転送**します。  
  
8.  パスの選択] ボックスの一覧で [ **ComponentPort**, 、展開 **ComponentHasPorts**, 、し、[ **コンポーネント**します。  
  
     新しいパスは、このようになります。  
  
     **ComponentHasPorts.Component/!Component**  
  
9. ソリューションを保存し、右端にあるボタンをクリックして、テンプレートの変換、 **ソリューション エクスプ ローラー** ツールバーです。  
  
10. ソリューションをビルドして実行します。 新しいインスタンス [!INCLUDE[vsprvs](../code-quality/includes/vsprvs_md.md)] が表示されます。  
  
11.  **ソリューション エクスプ ローラー**, 、Sample.mydsl を開きます。 図は、および **ComponentLanguage ツールボックス** が表示されます。  
  
12. ドラッグ、 **入力ポートは** から、 **ツールボックス** 間 **入力ポートです。** 次に、ドラッグ、 **OutputPort** に、 **InputPort** にもう **OutputPort**します。  
  
     利用不可ポインターが表示しないようにし、新しいを削除することができます **入力ポートは** 既存のものにします。 新しい選択 **入力ポートは** の別のポイントにドラッグして、 **コンポーネント**します。  
  
## <a name="see-also"></a>参照  
 [移動して、プログラム コードでモデルを更新します。](../modeling/navigating-and-updating-a-model-in-program-code.md)   
 [ツールおよびツールボックスのカスタマイズ](../modeling/customizing-tools-and-the-toolbox.md)   
 [回路図のサンプル DSL](http://code.msdn.microsoft.com/Visualization-Modeling-SDK-763778e8)