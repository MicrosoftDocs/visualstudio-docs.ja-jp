---
title: Python の混合モードのデバッグ
description: 環境間のステップ実行、値の表示、式の評価など、Visual Studio で C++ と Python を同時にデバッグします。
ms.date: 11/12/2018
ms.topic: conceptual
author: JoshuaPartlow
ms.author: joshuapa
manager: jillfra
ms.custom: seodec18
ms.workload:
- python
- data-science
ms.openlocfilehash: bc90d659a32c14f92e1eff058dd22d4a17d0b1cb
ms.sourcegitcommit: cc841df335d1d22d281871fe41e74238d2fc52a6
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/18/2020
ms.locfileid: "75679001"
---
# <a name="debug-python-and-c-together"></a>Python と C++ を同時にデバッグする

ほとんどの標準的 Python デバッガーは、Python コードのみのデバッグをサポートします。 ただし、実際には、高パフォーマンスやプラットフォーム API の直接呼び出しが必要なシナリオでは、Python と、C または C++ が併用されています。 (チュートリアルについては、「[Python 用 C++ 拡張機能の作成](working-with-c-cpp-python-in-visual-studio.md)」を参照してください)。

Visual Studio インストーラーの **Python 開発**ワークロードで **[Python ネイティブ開発ツール]** オプションが選択されていると、Visual Studio で Python とネイティブの C/C++ 向けに統合された同時混合モードのデバッグ機能が提供されます。

> [!Note]
> Visual Studio 2015 以前では、混合モードのデバッグは、Python Tools for Visual Studio 1.x では使用できません。

混合モード デバッグ機能には、この記事で説明するような次の特色があります。

- 結合された呼び出し履歴
- Python とネイティブ コード間でのステップ実行
- 両方の種類のコード内のブレークポイント
- Python のオブジェクト表現をネイティブ フレームに表示する機能 (逆も可能)
- Python プロジェクトまたは C++ プロジェクトのコンテキスト内でのデバッグ

![Visual Studio での Python の混合モードのデバッグ](media/mixed-mode-debugging.png)

|   |   |
|---|---|
| ![ビデオのムービー カメラ アイコン](../install/media/video-icon.png "ビデオを見る") | Visual Studio でのネイティブ C モジュールのビルド、テスト、デバッグの概要については、「[Deep Dive: Create Native Modules](https://youtu.be/D9RlT06a1EI)」 (詳細情報: ネイティブ モジュールを作成する) (youtube.com、9 分 9 秒) をご覧ください。 ビデオは、Visual Studio 2015 と 2017 の両方に適用されます。 |

## <a name="enable-mixed-mode-debugging-in-a-python-project"></a>Python プロジェクトでの混合モード デバッグの有効化

1. **ソリューション エクスプローラー**で Python プロジェクトを右クリックして、 **[プロパティ]** 、 **[デバッグ]** タブの順に選択し、 **[ネイティブ コードのデバッグを有効にする]** をオンにします。 このオプションで、すべてのデバッグ セッションで、混合モードが有効になります。

    ![ネイティブ コードのデバッグの有効化](media/mixed-mode-debugging-enable-native.png)

    > [!Tip]
    > ネイティブ コードのデバッグを有効にすると、プログラムが通常の **[続行するには、任意のキーを押してください]** で一時停止せずに完了した場合に、Python の出力ウィンドウがすぐに消えることがあります。 強制的に一時停止するには、ネイティブ コードのデバッグを有効にするときに、 **[デバッグ]** タブの **[実行]**  >  **[インタープリターの引数]** フィールドに、`-i` オプションを追加します。 この引数を使用すると、Python インタープリターはコード終了後に対話モードになり、この時点でユーザーが **Ctrl**+**Z** > **Enter** キーを押して終了するのを待機します。

1. 混合モードのデバッガーを既存のプロセスにアタッチ ( **[デバッグ]**  >  **[プロセスにアタッチ]** の順に選択) したら、 **[選択]** ボタンを使って **[コードの種類の選択]** ダイアログを開きます。 **[次のコードの種類をデバッグする]** オプションをオンにし、一覧の **[ネイティブ]** と **[Python]** の両方を選択します。

    ![コードの種類 ([ネイティブ] と [Python]) の選択](media/mixed-mode-debugging-code-type.png)

    コードの種類の設定は永続的であるため、後で別のプロセスにアタッチするときに混合モードのデバッグを無効にする場合は、**Python** コードの種類の選択を解除します。

    **[ネイティブ]** に加えて、またはその代わりとして他のコードの種類を選択できます。 たとえば、CPython をホストしてネイティブ拡張モジュールを使用するマネージド アプリケーションで、3 つすべてをデバッグする場合は、 **[Python]** 、 **[ネイティブ]** 、および **[マネージド]** をまとめて選択すると、結合された呼び出し履歴と 3 つすべてのランタイム間でのステップ実行を含む統合されたデバッグ エクスペリエンスを得ることができます。

1. 混合モードのデバッグを初めて開始したときに、**Python シンボルが必要である**ことを示すダイアログが表示される可能性があります (「[混合モード デバッグのシンボル](debugging-symbols-for-mixed-mode-c-cpp-python.md)」をご覧ください)。 どの Python 環境でも、シンボルは 1 回だけインストールする必要があります。 Visual Studio のインストーラーで Python のサポートをインストールすると、シンボルが自動的に組み込まれます (Visual Studio 2017 以降)。

1. デバッグ中に使用できる標準的な Python 自体のソース コードを作成するには、[https://www.python.org/downloads/source/](https://www.python.org/downloads/source/) にアクセスして、ご利用のバージョンに適したアーカイブをダウンロードして、フォルダーに展開します。 要求されたら、そのフォルダーの特定のファイルを Visual Studio で参照します。

## <a name="enable-mixed-mode-debugging-in-a-cc-project"></a>C/C++ プロジェクトでの混合モード デバッグの有効化

Visual Studio (2017 バージョン 15.5 以降) は、C/C++ プロジェクトの混合モード デバッグをサポートしています (たとえば、[python.org で説明されているように、別のアプリケーションに Python を埋め込む](https://docs.python.org/3/extending/embedding.html)場合など)。 混合モード デバッグを有効にするには、次のようにして、**Python/ネイティブ デバッグ**を起動するように C/C++ プロジェクトを構成します。

1. **ソリューション エクスプローラー**で C/C++ プロジェクトを右クリックして、 **[プロパティ]** を選択します。
1. **[デバッグ]** タブを選択し、 **[起動するデバッガー]** から **[Python/ネイティブ デバッグ]** を選びます。次に、 **[OK]** を選択します。

    ![C/C++ プロジェクトで [Python/ネイティブ デバッグ] を選択する](media/mixed-mode-debugging-select-cpp-debugger.png)

> [!Note]
> **[Python/ネイティブ デバッグ]** を選択するオプションがない場合は、まずは VS インストーラーを使用して **Python ネイティブ開発ツール**をインストールする必要があります。 これは、Python 開発ワークロード内のオプションとして存在します。 詳細については、「[Windows に Visual Studio の Python サポートをインストールする方法](installing-python-support-in-visual-studio.md)」を参照してください。

このメソッドを使用する場合、デバッガーがアタッチされない子の *python.exe* プロセスが生成されるため、*py.exe* ランチャー自体はデバッグできないことに注意してください。 引数を使用して *python.exe* を直接起動する場合は、 **[Python/ネイティブ デバッグ]** プロパティの **[コマンド]** オプションを *python.exe* の完全なパスが指定されるように変更し (前の画像を参照)、 **[コマンド引数]** に引数を指定します。

### <a name="attaching-the-mixed-mode-debugger"></a>混合モード デバッガーのアタッチ

Visual Studio の以前のすべてのバージョンでは、混合モードの直接のデバッグは Visual Studio で Python プロジェクトを起動するときにしか有効になりませんでした。これは、C/C++ プロジェクトがネイティブ デバッガーのみを使用するためです。 ただし、個別にデバッガーをアタッチすることはできます。

1. デバッグなしで C++ プロジェクトを開始します ( **[デバッグ]**  >  **[デバッグなしで開始]** を選択するか、**Ctrl**+**F5** キーを押す)。
1. **[デバッグ]**  >  **[プロセスにアタッチ]** の順に選択します。 表示されるダイアログで適切なプロセスを選んだ後、 **[選択]** ボタンを使って **[コードの種類の選択]** ダイアログを開きます。ここで、 **[Python]** を選ぶことができます。

    ![デバッガーをアタッチするときにデバッグの種類として Python を選ぶ](media/mixed-mode-debugging-attach-type.png)

1. **[OK]** を選んでダイアログを閉じた後、 **[アタッチ]** を選んでデバッガーを起動します。
1. デバッガーをアタッチするチャンスを得る前にデバッグ対象の Python が呼び出されないように、適切な一時停止または遅延を C++ アプリに組み込むことが必要になる場合があります。

## <a name="mixed-mode-specific-features"></a>混合モード固有の機能

- [結合された呼び出し履歴](#combined-call-stack)
- [Python とネイティブ コード間でのステップ実行](#step-between-python-and-native-code)
- [ネイティブ コード内の PyObject 値の表示](#pyobject-values-view-in-native-code)
- [Python コード内のネイティブ値の表示](#native-values-view-in-python-code)

### <a name="combined-call-stack"></a>結合された呼び出し履歴

**[呼び出し履歴]** ウィンドウには、ネイティブと Python のスタック フレームの両方が、2 つの間の遷移情報を挟んで交互に表示されます。

![結合された呼び出し履歴と混合モード デバッグ](media/mixed-mode-debugging-call-stack.png)

**[ツール]**  >  **[オプション]**  >  **[デバッグ]**  >  **[全般]**  >  **[マイ コードのみを有効にする]** オプションが設定されている場合、遷移情報は **[外部コード]** として表示され、遷移の方向は示されません。

呼び出しフレームをダブルクリックすると、それがアクティブになり、適切なソース コードが開きます (可能な場合)。 ソース コードが入手できない場合でも、フレームはアクティブになり、ローカル変数を調べることができます。

### <a name="step-between-python-and-native-code"></a>Python とネイティブ コード間でのステップ実行

**[ステップ イン]** (**F11** キー) コマンドまたは **[ステップ アウト]** (**Shift**+**F11** キー) コマンドを使用した場合、混合モードのデバッガーでコードの種類の変更が正しく処理されます。 たとえば、C で実装されている型のメソッドをPython で呼び出しているときに、そのメソッドへの呼び出しにステップ インすると、実行は、メソッドを実装しているネイティブ関数の先頭で停止します。 同様に、ネイティブ コードが Python API 関数を呼び出しているときは、呼び出されている Python コードで停止します。 たとえば、Python で定義された関数値の `PyObject_CallObject` にステップ インすると、Python 関数の先頭で停止します。 Python からネイティブへのステップ インは、Python から [ctypes](https://docs.python.org/3/library/ctypes.html) 経由で呼び出されるネイティブ関数でもサポートされています。

### <a name="pyobject-values-view-in-native-code"></a>ネイティブ コード内の PyObject 値の表示

ネイティブ (C または C++) フレームがアクティブのときは、そのローカル変数がデバッガーの **[ローカル]** ウィンドウに表示されます。 ネイティブの Python 拡張モジュールでは、これらの変数の多くは `PyObject` 型 (`_object` の typedef) であり、いくつかがその他の基本的な Python 型です (下の一覧を参照してください)。 混合モードのデバッグでは、これらの値は、 **[Python ビュー]** というラベルが付いた追加の子ノードに表示されます。 このノードを展開すると、変数の Python 表現が表示されます。これは、同じオブジェクトを参照しているローカル変数が Python フレームに存在している場合に表示されるものと同じです。 このノードの子は編集可能です。

![[ローカル] ウィンドウの Python ビュー](media/mixed-mode-debugging-python-view.png)

この機能を無効にするには、 **[ローカル]** ウィンドウ内を右クリックし、 **[Python]**  >  **[Python ビュー ノードを表示]** メニュー オプションを切り替えます。

![[ローカル] ウィンドウの Python ビューを有効にする](media/mixed-mode-debugging-enable-python-view.png)

**[Python ビュー]** ノードを表示する C 型 (有効な場合):

- `PyObject`
- `PyVarObject`
- `PyTypeObject`
- `PyByteArrayObject`
- `PyBytesObject`
- `PyTupleObject`
- `PyListObject`
- `PyDictObject`
- `PySetObject`
- `PyIntObject`
- `PyLongObject`
- `PyFloatObject`
- `PyStringObject`
- `PyUnicodeObject`

自分で作成した型は、 **[Python ビュー]** に自動的に表示されることはありません。 Python 3.x での拡張機能の作成では、すべてのオブジェクトに最終的には上記のいずれかの型の `ob_base` フィールドが存在し、それによって **[Python ビュー]** に表示されるため、通常、この欠落は問題になりません。

ただし、Python 2.x では、通常は、各オブジェクト型でヘッダーをインライン フィールドのコレクションとして宣言するため、カスタム作成された型と `PyObject` の間には、C/C++ コードの型システム レベルでの関連付けがありません。 このようなカスタム型に対して **[Python ビュー]** ノードを有効にするには、[Python ツールのインストール ディレクトリ](installing-python-support-in-visual-studio.md#install-locations)の *PythonDkm.natvis* ファイルを編集して、C 構造体または C++ クラスの XML に別の要素を追加します。

別の (より優れた) 方法は、[PEP 3123](https://www.python.org/dev/peps/pep-3123/) に従って、`PyObject_HEAD` の代わりに明示的な `PyObject ob_base;` フィールドを使用することです。ただし、旧バージョンとの互換性の点で、この方法は常に可能であるとは限りません。

### <a name="native-values-view-in-python-code"></a>Python コード内のネイティブ値の表示

前のセクションと似ていますが、Python フレームがアクティブのときに、ネイティブ値を **[ローカル]** ウィンドウに表示する **[C++ ビュー]** を有効にできます。 この機能は既定では有効になっていないため、 **[ローカル]** ウィンドウ内を右クリックし、 **[Python]**  >  **[C++ ビュー ノードを表示]** メニュー オプションを切り替えることで有効にします。

![[ローカル] ウィンドウの C++ ビューを有効にする](media/mixed-mode-debugging-enable-cpp-view.png)

**[C++ ビュー]** ノードでは、値の基になる C/C++ 構造体の表現が提供されます (これはネイティブ フレームに表示されるものと同じです)。 たとえば、Python の長整数型の `_longobject` インスタンス (その `PyLongObject` は typedef です) が表示され、カスタム作成されたネイティブ クラスの型の推測が試行されます。 このノードの子は編集可能です。

![[ローカル] ウィンドウの C++ ビュー](media/mixed-mode-debugging-cpp-view.png)

オブジェクトの子フィールドが `PyObject` 型であるか、サポートされているその他の型のいずれかである場合は、 **[Python ビュー]** ノードが表示され (表示が有効な場合)、リンクが Python に直接公開されていないオブジェクト グラフに移動することができます。

Python オブジェクトのメタデータを使用してオブジェクトの型を特定する **[Python ビュー]** ノードとは異なり、 **[C++ ビュー]** には同じように信頼性の高いメカニズムはありません。 一般的に言えば、Python 値 (つまり `PyObject` 参照) が与えられた場合、そのバックにある C/C++ 構造体はどれかを確実に判断することはできません。 混合モードのデバッガーは、関数ポインターの型があるオブジェクトの型のさまざまなフィールドを調べて、型を推測しようとします (たとえば `ob_type` フィールドによって参照されている `PyTypeObject`)。 関数ポインターのいずれかが解決可能な関数を参照し、その関数に `PyObject*` よりも型が明確な `self` パラメーターがあれば、その型はバッキング型であるとみなされます。 たとえば、特定のオブジェクトの `ob_type->tp_init` が次の関数をポイントしている場合、

```c
static int FobObject_init(FobObject* self, PyObject* args, PyObject* kwds) {
    return 0;
}
```

デバッガーは、オブジェクトの C の型は `FobObject` であることを正しく推測できます。 `tp_init` から正確な型を判別できない場合は、他のフィールドに移動します。 どのフィールドからも型を推測できない場合、オブジェクトは **[C++ ビュー]** ノードに `PyObject` インスタンスとして表示されます。

カスタム作成した型の有用な表現を常に取得する最善の方法は、型を登録するときに少なくとも 1 つの特殊な関数を登録し、厳密に型指定された `self` パラメーターを使用することです。 ほとんどの型は問題なくこの要件を満たしますが、当てはまらない場合、この目的で使用するための最も便利なエントリは、通常は `tp_init` です。 デバッガーの型推測を可能にするためにのみ存在する `tp_init` 型のダミー実装は、上のコード サンプルに示すように、すぐにゼロを返すことができます。

## <a name="differences-from-standard-python-debugging"></a>Python の標準的なデバッグとの違い

混合モードのデバッガーは、追加機能がいくつか導入されていますが、Python に関連するいくつかの機能が欠けているという点で、[標準的な Python のデバッガー](debugging-python-in-visual-studio.md)とは区別されます。

- サポートされていない機能: 条件付きブレークポイント、**Debug Interactive** ウィンドウ、プラットフォーム間のリモート デバッグ。
- **イミディエイト** ウィンドウ: 使用できますが、その機能はサブセットに制限され、ここに記載されている制限もすべて適用されます。
- サポートされている Python のバージョン:CPython 2.7 と 3.3+ のみ。
- Visual Studio Shell:Visual Studio Shell で Python を使用する場合 (たとえば、統合インストーラーを使用してインストールした場合)、Visual Studio では C++ プロジェクトを開くことができません。また、C++ ファイルの編集方法は、基本的なテキスト エディターでの編集と同様です。 ただし、C/C++ のデバッグと混合モードでのデバッグは Shell で完全にサポートされ、ソース コード、ネイティブ コードのステップ イン、およびデバッガー ウィンドウでの C++ 式の評価を実行できます。
- オブジェクトの表示と展開:デバッガー ツールの **[ローカル]** ウィンドウと **[ウォッチ]** ウィンドウに Python オブジェクトを表示するとき、混合モードのデバッガーでは、オブジェクトの構造のみが表示されます。 プロパティの自動評価や計算される属性の表示は行われません。 コレクションでは、組み込みコレクション型 (`tuple`、`list`、`dict`、`set`) の要素のみを表示します。 カスタム コレクション型は、組み込みコレクション型から継承される場合を除き、コレクションとして視覚化されません。
- 式の評価: 下記を参照してください。

### <a name="expression-evaluation"></a>式の評価

標準的な Python デバッガーでは、デバッグ対象のプロセスは、I/O 操作またはその他の同様のシステム呼び出しでブロックされていない限り、コード内のどのポイントで一時停止された場合でも、 **[ウォッチ]** ウィンドウと **[イミディエイト]** ウィンドウで任意の Python 式を評価することができます。 混合モード デバッグの場合、Python コードで式が停止したとき、ブレークポイントの後、またはコードをステップ実行するときにのみ、任意の式を評価できます。 式は、ブレークポイントまたはステップ実行操作が発生したスレッドでのみ評価できます。

ネイティブコード内、または上記の条件が適用されない Python コード内で停止した (ステップ アウト操作の後や異なるスレッド上などで停止した) 場合、式の評価は、現在選択されているフレームのスコープ内のローカル変数とグローバル変数へのアクセス、それらのフィールドへのアクセス、および組み込みコレクション型のリテラルによるインデックス作成に限定されます。 たとえば、次の式は、すべてのコンテキストで評価できます (すべての識別子が既存の変数と適切な型のフィールドを参照していることを条件とします)。

```python
foo.bar[0].baz['key']
```

混合モードのデバッガーも、このような式を異なる方法で解決します。 すべてのメンバー アクセス操作は、直接的にオブジェクトの一部であるフィールド (`__dict__` または `__slots__` 内のエントリや、`tp_members` 経由で Python に公開されているネイティブ構造体のフィールドなど) のみを検索し、すべての `__getattr__`、`__getattribute__`、または記述子ロジックを無視します。 同様に、すべてのインデックス作成操作は `__getitem__` を無視して、コレクションの内部データ構造に直接アクセスします。

整合性を保つため、任意の式が現在の停止ポイントで評価できるかどうかに関係なく、制限された式の評価に対する制約と一致するすべての式に対して、この名前解決スキームが使用されます。 フル機能のエバリュエーターを使用できるときに Python の適切なセマンティクスを適用するには、式をかっこで囲みます。

```python
(foo.bar[0].baz['key'])
```
