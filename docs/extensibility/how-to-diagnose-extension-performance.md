---
title: '方法: 拡張機能のパフォーマンスを診断する |Microsoft Docs'
description: Visual Studio は、低速な拡張機能をユーザーに通知します。 拡張機能の影響がどのように計算されるか、および拡張機能の影響をローカルで分析する方法について説明します。
ms.custom: SEO-VS-2020
ms.date: 11/08/2016
ms.topic: how-to
ms.assetid: 46b0a1e3-7e69-47c9-9d8d-a1815d6c3896
author: BertanAygun
ms.author: bertaygu
manager: jmartens
ms.workload:
- bertaygu
ms.openlocfilehash: 05dda944ab2aecd429386e0e4c40646d21e9a3d4
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/08/2021
ms.locfileid: "99966410"
---
# <a name="measuring-extension-impact-in-startup"></a>起動における拡張機能の影響の測定

## <a name="focus-on-extension-performance-in-visual-studio-2017"></a>Visual Studio 2017 での拡張機能のパフォーマンスに焦点を当てる

お客様からのフィードバックに基づいて、Visual Studio 2017 リリースの対象領域の1つが起動され、ソリューションの読み込みパフォーマンスが向上しています。 Visual Studio プラットフォームチームは、起動とソリューションの読み込みパフォーマンスの向上に取り組んでいます。 一般に、インストールされている拡張機能は、これらのシナリオに大きな影響を与える可能性があります。

ユーザーがこの影響を理解できるように、Visual Studio に新しい機能が追加され、低速な拡張機能をユーザーに通知しました。 場合によっては、ソリューションの読み込みまたは起動の速度が低下する新しい拡張機能が Visual Studio によって検出されることがあります。 遅延が検出されると、IDE でユーザーに通知が表示され、新しい [Visual Studio のパフォーマンスの管理] ダイアログが表示されます。 このダイアログには、以前に検出された拡張機能を参照するために、いつでも [ヘルプ] メニューからアクセスできます。

![Visual Studio のパフォーマンスの管理](media/manage-performance.png)

このドキュメントでは、拡張機能の影響の計算方法を記述することによって拡張機能の開発者を支援します。 このドキュメントでは、拡張機能の影響をローカルで分析する方法についても説明します。 拡張機能の影響をローカルで分析すると、拡張機能がパフォーマンスに影響する拡張機能として表示されるかどうかが決まります。

> [!NOTE]
> このドキュメントでは、拡張機能が起動時とソリューションの負荷に与える影響に焦点を当てています。 また、拡張機能は、UI が応答しなくなったときに Visual Studio のパフォーマンスにも影響します。 このトピックの詳細については、「 [方法: 拡張機能による UI の遅延の診断](how-to-diagnose-ui-delays-caused-by-extensions.md)」を参照してください。

## <a name="how-extensions-can-impact-startup"></a>拡張機能が起動時に与える影響

起動時のパフォーマンスに影響を与える拡張機能の最も一般的な方法の1つは、NoSolutionExists や ShellInitialized などの既知のスタートアップ UI コンテキストのいずれかで自動読み込みを選択することです。 これらの UI コンテキストは、起動時にアクティブ化されます。 `ProvideAutoLoad`これらのコンテキストを持つ定義に属性を含むパッケージは、その時点で読み込まれ、初期化されます。

拡張機能の影響を測定する際には、主に、上記のコンテキストで自動読み込みを選択する拡張機能によって費やされた時間に重点を置いています。 測定される時間には次のものが含まれますが、これに限定されません。

* 同期パッケージの拡張機能アセンブリの読み込み
* 同期パッケージのパッケージクラスコンストラクターに費やされた時間
* 同期パッケージの package Initialize (または SetSite) メソッドで費やされた時間
* 非同期パッケージの場合、上記の操作はバックグラウンドスレッドで実行されます。  そのため、操作は監視から除外されます。
* パッケージの初期化中に、メインスレッドで実行されるようにスケジュールされている任意の非同期作業に費やされた時間
* イベントハンドラーで費やされた時間 (具体的にはシェルで初期化されたコンテキストのアクティブ化またはシェルのゾンビ状態の変更)
* Visual Studio 2017 Update 3 以降では、シェルが初期化される前に、アイドル状態の呼び出しに費やされた時間の監視も開始します。 アイドルハンドラーでの長時間の操作も、IDE に応答しなくなり、ユーザーが認識する起動時間に寄与します。

Visual Studio 2015 から開始される多くの機能を追加しました。 これらの機能を使用すると、パッケージを自動的に読み込む必要がなくなります。 また、この機能により、パッケージをより具体的なケースに読み込む必要がなくなります。 このような場合には、ユーザーが拡張機能を使用したり、自動的に読み込みを行うときに拡張機能の影響を軽減したりすることがより適切である例があります。

これらの機能の詳細については、次のドキュメントを参照してください。

[ルールベースの ui コンテキスト](how-to-use-rule-based-ui-context-for-visual-studio-extensions.md): ui コンテキストを中心に構築された高度なルールベースのエンジンを使用すると、プロジェクトの種類、フレーバー、属性に基づいてカスタムコンテキストを作成できます。 カスタムコンテキストを使用すると、より具体的なシナリオでパッケージを読み込むことができます。 これらの特定のシナリオには、スタートアップではなく特定の機能を持つプロジェクトが存在することが含まれます。 カスタムコンテキストでは、プロジェクトコンポーネントまたはその他の使用可能な使用条件に基づいて [、コマンドの可視性をカスタムコンテキストに関連](visibilityconstraints-element.md) 付けることもできます。 この機能により、コマンドステータスクエリハンドラーを登録するためのパッケージを読み込む必要がなくなります。

[非同期パッケージのサポート](how-to-use-asyncpackage-to-load-vspackages-in-the-background.md): visual studio 2015 の新しい asyncpackage 基底クラスを使用すると、パッケージの読み込みが自動読み込み属性または非同期サービスクエリによって要求された場合に、visual studio パッケージをバックグラウンドで非同期的に読み込むことができます。 このバックグラウンド読み込みによって、IDE の応答性を維持できます。 拡張機能がバックグラウンドで初期化されていても、起動やソリューションの負荷が影響を受けないという重要なシナリオには、IDE の応答性が低下します。

[非同期サービス](how-to-provide-an-asynchronous-visual-studio-service.md): 非同期パッケージをサポートすることで、サービスを非同期に照会し、非同期サービスを登録できるようになりました。 さらに重要な点として、非同期クエリをサポートするためにコア Visual Studio サービスを変換して、バックグラウンドスレッドで非同期クエリの処理の大部分が発生するようにしています。 SComponentModel (Visual Studio MEF ホスト) は、拡張機能で非同期読み込みを完全にサポートできるようにする非同期クエリをサポートする主なサービスの1つです。

## <a name="reducing-impact-of-auto-loaded-extensions"></a>自動読み込まれた拡張機能の影響を軽減する

スタートアップ時にパッケージを自動的に読み込む必要がある場合は、パッケージの初期化中に実行される作業を最小限に抑えることが重要です。 パッケージ初期化作業を最小化すると、拡張機能が起動に影響する可能性が低くなります。

パッケージの初期化に負荷がかかる可能性のある例を次に示します。

### <a name="use-of-synchronous-package-load-instead-of-asynchronous-package-load"></a>非同期パッケージ読み込みではなく、同期パッケージ読み込みの使用

既定では、同期パッケージはメインスレッドに読み込まれるため、前に説明したように、非同期パッケージの基本クラスを使用するように自動的に読み込まれたパッケージを持つ拡張機能の所有者をお勧めします。 自動読み込みされたパッケージを変更して非同期読み込みをサポートすることにより、以下の他の問題を簡単に解決できるようになります。

### <a name="synchronous-filenetwork-io-requests"></a>ファイル/ネットワーク IO 要求の同期

メインスレッドでは、同期ファイルまたはネットワーク IO の要求をすべて回避することが理想的です。 影響はコンピューターの状態によって異なり、場合によっては長期間ブロックされることがあります。

非同期パッケージ読み込みと非同期 IO Api を使用すると、パッケージの初期化によってメインスレッドがブロックされないようにする必要があります。 また、ユーザーは、バックグラウンドで i/o 要求が発生しても、Visual Studio との対話を続けることができます。

### <a name="early-initialization-of-services-components"></a>サービス、コンポーネントの初期初期化

パッケージの初期化における一般的なパターンの1つは、によって使用されるサービス、またはパッケージ `constructor` またはメソッドでパッケージによって提供されるサービスを初期化することです `initialize` 。 これにより、サービスを使用できるようになりますが、これらのサービスがすぐに使用されない場合は、パッケージの読み込みに不要なコストを追加することもできます。 このようなサービスは、パッケージの初期化で実行される作業を最小限にするために、オンデマンドで初期化する必要があります。

パッケージによって提供されるグローバルサービスの場合、 `AddService` コンポーネントによって要求された場合にのみ、関数を使用してサービスを遅延初期化するメソッドを使用できます。 パッケージ内で使用されるサービスについては、Lazy \<T> または AsyncLazy を使用し \<T> て、最初の使用時にサービスが初期化または照会されるようにすることができます。

## <a name="measuring-impact-of-auto-loaded-extensions-using-activity-log"></a>アクティビティログを使用して、自動読み込みされた拡張機能の影響を測定する

Visual Studio 2017 Update 3 以降では、Visual Studio アクティビティログに、起動時およびソリューション負荷中のパッケージのパフォーマンスへの影響に関するエントリが含まれるようになりました。 これらの測定値を表示するには、/log スイッチを使用して Visual Studio を開き、 *ActivityLog.xml* ファイルを開く必要があります。

アクティビティログでは、エントリは [Visual Studio のパフォーマンスの管理] ソースの下に表示され、次の例のようになります。

```Component: 3cd7f5bf-6662-4ff0-ade8-97b5ff12f39c, Inclusive Cost: 2008.9381, Exclusive Cost: 2008.9381, Top Level Inclusive Cost: 2008.9381```

この例は、GUID が "3cd7f5bf-6662-4ff0-ade8-97b5ff12f39c" のパッケージが Visual Studio の起動時に2008ミリ秒費やしたことを示しています。 Visual Studio では、パッケージの影響を計算する際に、最上位レベルのコストが主要な数値と見なされることに注意してください。これは、ユーザーがパッケージの拡張機能を無効にしたときに表示される節約額です。

## <a name="measuring-impact-of-auto-loaded-extensions-using-perfview"></a>PerfView を使用した自動読み込み拡張機能の影響の測定

コード分析を使用すると、パッケージの初期化速度が低下する可能性のあるコードパスを特定できますが、PerfView などのアプリケーションを使用してトレースを利用し、Visual Studio の起動時にパッケージの読み込みの影響を理解することもできます。

PerfView は、システム全体のトレースツールです。 このツールを使用すると、CPU 使用率やシステム呼び出しのブロックによって、アプリケーションのホットパスを理解することができます。 次に、 [Microsoft ダウンロードセンター](https://www.microsoft.com/en-us/download/details.aspx?id=28567)で使用できる perfview を使用してサンプル拡張機能を分析する簡単な例を示します。

**コード例:**

この例は、次のサンプルコードに基づいています。これは、一般的な遅延の原因を示すために設計されています。

```csharp
protected override void Initialize()
{
    // Initialize a class from another assembly as an example
    MakeVsSlowServiceImpl service = new MakeVsSlowServiceImpl();

    // Costly work in main thread involving file IO
    string systemPath = Environment.GetFolderPath(Environment.SpecialFolder.Windows);
    foreach (string file in Directory.GetFiles(systemPath))
    {
        DateTime creationDate = File.GetCreationTime(file);
    }

    // Costly work after shell is initialized. This callback executes on main thread
    KnownUIContexts.ShellInitializedContext.WhenActivated(() =>
    {
        DoMoreWork();
    });

    // Start async work on background thread
    DoAsyncWork().Forget();
}

private async Task DoAsyncWork()
{
    // Switch to background thread to do expensive work
    await TaskScheduler.Default;
    System.Threading.Thread.Sleep(500);
}

private void DoMoreWork()
{
    // Costly work
    System.Threading.Thread.Sleep(500);
    // Blocking call to an asynchronous work.
    ThreadHelper.JoinableTaskFactory.Run(async () => { await DoAsyncWork(); });
}
```

**PerfView を使用したトレースの記録:**

拡張機能がインストールされている Visual Studio 環境をセットアップしたら、PerfView を開き、[**収集**] メニューから [**収集**] ダイアログを開くことで、スタートアップのトレースを記録できます。

![perfview の収集メニュー](media/perfview-collect-menu.png)

既定のオプションでは、CPU 使用量の呼び出し履歴が提供されますが、ブロック時間に関心があるため、 **スレッド時間** スタックを有効にする必要もあります。 設定の準備ができたら、[コレクションの **開始** ] をクリックし、記録の開始後に Visual Studio を開きます。

コレクションを停止する前に、Visual Studio が完全に初期化されていること、メインウィンドウが完全に表示されていること、および拡張機能に自動的に表示される UI 要素が含まれていることを確認する必要がある場合は、それらも表示されます。 Visual Studio が完全に読み込まれ、拡張機能が初期化されたら、記録を停止してトレースを分析することができます。

**PerfView を使用したトレースの分析:**

記録が完了すると、PerfView によってトレースと展開のオプションが自動的に開きます。

この例では、主に、[**詳細グループ**] の下にある [**スレッド時間] スタック** ビューに注目します。 このビューには、CPU 時間とブロック時間の両方を含む、スレッドに費やされた合計時間が表示されます。これには、ディスク IO やハンドルでの待機が含まれます。

 ![スレッド時間スタック](media/perfview-thread-time-stacks.png)

 **スレッド時間スタック** ビューを開くときに、解析を開始する **devenv** プロセスを選択する必要があります。

PerfView には、詳細な分析を行うために、独自のヘルプメニューのスレッド時間スタックを読み取る方法についての詳細なガイダンスがあります。 この例では、パッケージモジュール名とスタートアップスレッドを含むスタックだけを含めることで、このビューをさらにフィルター処理します。

1. 既定で追加されたグループを削除するには、 **Groupて s** を空のテキストに設定します。
2. 既存のプロセスフィルターに加えて、アセンブリ名とスタートアップスレッドの一部を含めるように、 **インシデント** を設定します。 この場合は、devenv にする必要があり **ます。スタートアップスレッド;MakeVsSlowExtension**。

これで、ビューには、拡張機能に関連するアセンブリに関連付けられているコストのみが表示されるようになりました。 このビューでは、スタートアップスレッドの [ **包括 (包括コスト)** ] 列の下に表示されるすべての時刻は、フィルター処理された拡張機能に関連し、スタートアップに影響します。

上記の例では、いくつかの興味深い呼び出し履歴は次のようになります。

1. クラスを使用した IO `System.IO` : これらのフレームの包括コストは、トレースではコストが高くならない可能性がありますが、ファイル IO 速度はコンピューターによって異なるため、問題の原因となる可能性があります。

   ![システム io フレーム](media/perfview-system-io-frames.png)

2. 他の非同期作業を待機している呼び出しをブロックする: この場合、包括時間は、非同期処理の完了時にメインスレッドがブロックされた時間を表します。

   ![ブロック (呼び出しフレームを)](media/perfview-blocking-call-frames.png)

影響を判断するのに役立つ、トレース内の他のビューの1つは、 **イメージの読み込みスタック** です。 **スレッド時間スタック** ビューに適用されているものと同じフィルターを適用し、自動的に読み込まれたパッケージによって実行されるコードのために読み込まれたすべてのアセンブリを確認することができます。

パッケージ初期化ルーチン内で読み込まれるアセンブリの数を最小限に抑えることが重要です。これは、追加の各アセンブリに余分なディスク i/o が必要になるためです。これにより、コンピューターの速度が低下する可能性があります。

## <a name="summary"></a>まとめ

Visual Studio の起動は、継続的にフィードバックを受け取る領域の1つです。 前述のように、インストールされているコンポーネントと拡張機能に関係なく、すべてのユーザーが一貫したスタートアップエクスペリエンスを持つことができます。 この目標を達成するために、拡張機能の所有者と協力していただきたいと思います。 上記のガイダンスは、拡張機能が起動時に与える影響を理解し、ユーザーの生産性への影響を最小限に抑えるために、非同期的に読み込みや読み込みを行わずに済むようにする場合に役立ちます。
