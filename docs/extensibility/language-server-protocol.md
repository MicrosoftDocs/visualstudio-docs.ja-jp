---
title: 言語サーバープロトコルの概要 |Microsoft Docs
description: 言語サーバープロトコルによって、さまざまなツールに言語機能を公開するための便利なフレームワークがどのように提供されるかについて説明します。
ms.custom: SEO-VS-2020
ms.date: 11/14/2017
ms.topic: conceptual
ms.assetid: 6a7d93c2-31ea-4bae-8b29-6988a567ddf2
author: acangialosi
ms.author: anthc
manager: jillfra
ms.workload:
- vssdk
ms.openlocfilehash: 2d642d1168cbd2a8bd7abadbcdbd7c1e2851b00e
ms.sourcegitcommit: d485b18e46ec4cf08704b5a8d0657bc716ec8393
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 12/17/2020
ms.locfileid: "97616131"
---
# <a name="language-server-protocol"></a>言語サーバー プロトコル

## <a name="what-is-the-language-server-protocol"></a>言語サーバープロトコルとは

ソースコードオートコンプリートや、エディターまたは IDE でのプログラミング言語の **定義へのジャンプ** など、豊富な編集機能をサポートすることは、従来、非常に困難で時間のかかる作業です。 通常は、エディターまたは IDE のプログラミング言語でドメインモデル (スキャナー、パーサー、型チェッカー、ビルダーなど) を記述する必要があります。 たとえば、eclipse ide 自体は Java で記述されているため、eclipse IDE での C/c + + のサポートを提供する Eclipse CDT プラグインは Java で記述されています。 このアプローチに従うと、TypeScript for Visual Studio コードで C/c + + ドメインモデルを実装し、C# では Visual Studio に個別のドメインモデルを実装することになります。

開発ツールで既存の言語固有のライブラリを再利用できる場合、言語固有のドメインモデルの作成もはるかに簡単になります。 ただし、これらのライブラリは通常プログラミング言語で実装されています (たとえば、c/c + + の適切なドメインモデルは C/c + + で実装されています)。 TypeScript で記述されたエディターに C/c + + ライブラリを統合することは、技術的には可能ですが、実行するのは困難です。

### <a name="language-servers"></a>言語サーバー

別の方法として、ライブラリを独自のプロセスで実行し、プロセス間通信を使用してそのライブラリと通信する方法もあります。 送受信されるメッセージは、プロトコルとして送信されます。 言語サーバープロトコル (LSP) は、開発ツールと言語サーバープロセスの間で交換されるメッセージを標準化するための製品です。 言語サーバーまたはデーモンを使用することは、新たにも斬新なアイデアでもありません。 Vim や Emacs などのエディターは、セマンティックオートコンプリートサポートを提供するために、この処理をしばらく行っています。 LSP の目標は、これらの種類の統合を簡略化し、さまざまなツールに言語機能を公開するための便利なフレームワークを提供することでした。

共通のプロトコルを使用すると、言語のドメインモデルの既存の実装を再利用することにより、プログラミング言語の機能を開発ツールに統合できます。これには、最小限の面倒が必要です。 言語サーバーバックエンドは、PHP、Python、または Java で記述でき、LSP を使用すると、さまざまなツールに簡単に統合できます。 プロトコルは、一般的な抽象化レベルで機能します。これにより、ツールは、基になるドメインモデルに固有の微妙な差異を完全に理解しなくても、豊富な言語サービスを提供できます。

## <a name="how-work-on-the-lsp-started"></a>LSP での作業の開始方法

LSP は時間の経過と共に進化し、現在はバージョン3.0 になっています。 言語サーバーの概念が OmniSharp によって取得されたときに、C# の豊富な編集機能を提供するようになりました。 最初に、OmniSharp は JSON ペイロードで HTTP プロトコルを使用し、 [Visual Studio Code](https://code.visualstudio.com)を含む複数のエディターに統合されています。

同時に、Microsoft は TypeScript 言語サーバーでの作業を開始しました。 Emacs や Sublime テキストなどのエディターで TypeScript をサポートするという考え方があります。 この実装では、エディターは TypeScript サーバープロセスと共に stdin/stdout を介して通信し、要求と応答に V8 debugger プロトコルによって実現される JSON ペイロードを使用します。 Typescript サーバーは、typescript Sublime プラグインに統合されており、豊富な TypeScript 編集用に VS Code ています。

2つの異なる言語サーバーを統合した後、VS Code チームは、エディターと Ide 用の共通言語サーバープロトコルの探索を開始しました。 共通のプロトコルを使用すると、言語プロバイダーは、さまざまな Ide で使用できる単一の言語サーバーを作成できます。 言語サーバーコンシューマーは、プロトコルのクライアント側のみを実装する必要があります。 その結果、言語プロバイダーと言語コンシューマーの両方について、win win の状況が発生します。

言語サーバープロトコルは、TypeScript サーバーによって使用されるプロトコルで開始され、VS Code 言語 API によって強化された言語機能を使用して拡張されています。 このプロトコルは、シンプルさと既存のライブラリにより、リモートでの呼び出しのために JSON-RPC を使用してバックアップされます。

VS Code チームは、ファイルをけば (スキャン) する要求に応答し、検出された警告とエラーのセットを返す複数のリンター言語サーバーを実装することによって、プロトコルのプロトタイプを宣言しました。 この目的は、ユーザーがドキュメントを編集したときにファイルを糸くずさせることでした。つまり、エディターセッション中に多数の要求が行われることになります。 サーバーの稼働を維持し、ユーザーが編集するたびに新しい lint を開始する必要がないようにすることは理にかなっています。 いくつかのリンターサーバーが実装されました。これには VS Code の機能拡張機能や、機能があります。 これら2つのリンターサーバーは両方とも TypeScript/JavaScript に実装され、Node.js で実行されます。 これらは、プロトコルのクライアントおよびサーバー部分を実装するライブラリを共有します。

## <a name="how-the-lsp-works"></a>LSP の動作

言語サーバーは独自のプロセスで実行され、Visual Studio や VS Code などのツールは、JSON を介して言語プロトコルを使用してサーバーと通信します。 専用のプロセスで動作する言語サーバーのもう1つの利点は、単一プロセスモデルに関連するパフォーマンスの問題を回避できることです。 クライアントとサーバーの両方が Node.js に記述されている場合、実際のトランスポートチャネルは、stdio、ソケット、名前付きパイプ、またはノード ipc のいずれかになります。

次に、ルーチンの編集セッション中にツールと言語サーバーが通信する方法の例を示します。

![lsp フロー図](media/lsp-flow-diagram.png)

* **ユーザーは、ツールでファイル (ドキュメントと呼ば** れます) を開きます。ツールは、ドキュメントが開いていること (' textdocument/didOpen ') を言語サーバーに通知します。 今からは、ドキュメントの内容についての事実はファイルシステム上ではなくなりましたが、ツールによってメモリに保持されています。

* **ユーザーが編集を行う**: ツールは、ドキュメントの変更 (' textdocument/didChange ') をサーバーに通知し、プログラムのセマンティック情報は言語サーバーによって更新されます。 このような状況が発生すると、言語サーバーはこの情報を分析し、検出されたエラーと警告 (' textDocument/publishDiagnostics ') をツールに通知します。

* **ユーザーは、エディター内のシンボルに対して [定義へ移動] を実行し** ます。このツールは、2つのパラメーターを持つ ' textdocument/Definition ' 要求を送信します。 (1) ドキュメント URI、(2) サーバーに対して "定義へ移動" 要求が開始された場所からのテキスト位置。 サーバーはドキュメント URI とドキュメント内のシンボル定義の位置を使用して応答します。

* **ユーザーがドキュメント (ファイル) を閉じる** と、ツールから ' textdocument/didClose ' 通知が送信されます。これにより、ドキュメントがメモリ内になくなったことと、現在の内容がファイルシステム上で最新の状態になっていることが言語サーバーに通知されます。

この例では、"定義に進む"、"すべての参照の検索" などのエディター機能レベルで、プロトコルが言語サーバーと通信する方法を示します。 プロトコルで使用されるデータ型は、現在開いているテキストドキュメントやカーソルの位置など、エディターまたは IDE の ' データ型 ' です。 データ型がプログラミング言語のドメインモデルのレベルにありません。通常、抽象構文ツリーとコンパイラシンボル (解決された型、名前空間など) が提供されます。これにより、プロトコルが大幅に簡略化されます。

次に、"textDocument/definition" 要求を詳細に見てみましょう。 次に示すのは、C++ ドキュメントの "定義に進む" 要求のために、クライアントツールと言語サーバーの間で実行されるペイロードです。

要求は次のとおりです。

```json
{
    "jsonrpc": "2.0",
    "id" : 1,
    "method": "textDocument/definition",
    "params": {
        "textDocument": {
            "uri": "file:///p%3A/mseng/VSCode/Playgrounds/cpp/use.cpp"
        },
        "position": {
            "line": 3,
            "character": 12
        }
    }
}
```

応答は次のとおりです。

```json
{
    "jsonrpc": "2.0",
    "id": "1",
    "result": {
        "uri": "file:///p%3A/mseng/VSCode/Playgrounds/cpp/provide.cpp",
        "range": {
            "start": {
                "line": 0,
                "character": 4
            },
            "end": {
                "line": 0,
                "character": 11
            }
        }
    }
}
```

Retrospect では、プログラミング言語モデルのレベルではなく、エディターのレベルでデータ型を記述することは、言語サーバープロトコルが成功した理由の1つです。 さまざまなプログラミング言語で抽象構文ツリーとコンパイラシンボルを標準化する場合と比較して、テキストドキュメント URI またはカーソル位置を標準化する方がはるかに簡単です。

ユーザーがさまざまな言語で作業している場合、VS Code は通常、各プログラミング言語の言語サーバーを起動します。 次の例は、ユーザーが Java および SASS ファイルに対して動作するセッションを示しています。

![java と sass](media/lsp-java-and-sass.png)

### <a name="capabilities"></a>機能

すべての言語サーバーで、プロトコルによって定義されたすべての機能がサポートされるとは限りません。 そのため、クライアントとサーバーは、サポートされている機能セットを ' capabilities ' でアナウンスします。 例として、サーバーは ' textDocument/definition ' 要求を処理できることを示していますが、' workspace/symbol ' 要求を処理できない可能性があります。 同様に、クライアントは、ドキュメントが保存される前に "about to save" 通知を提供できることを知らせることができます。これにより、編集されたドキュメントをサーバーで自動的にフォーマットするためのテキスト編集を計算できます。

## <a name="integrating-a-language-server"></a>言語サーバーの統合

言語サーバーと特定のツールとの実際の統合は、言語サーバープロトコルによって定義されておらず、ツールの実装に残されています。 一部のツールは、任意の種類の言語サーバーを起動して対話できる拡張機能を持つことによって、言語サーバーを一般に統合しています。 また、VS Code のように、言語サーバーごとにカスタム拡張機能を作成することもできます。これにより、拡張機能でいくつかのカスタム言語機能を使用できるようになります。

言語サーバーとクライアントの実装を簡略化するために、クライアントとサーバーの各部分にはライブラリまたは Sdk があります。 これらのライブラリは、さまざまな言語で提供されています。 たとえば、言語サーバーと VS Code 拡張機能との統合を容易にする [言語クライアント npm モジュール](https://www.npmjs.com/package/vscode-languageclient) や、Node.js を使用して言語サーバーを作成するための別の [言語サーバー npm](https://www.npmjs.com/package/vscode-languageserver) モジュールがあります。 これは、サポートライブラリの現在の [一覧](https://github.com/Microsoft/language-server-protocol/wiki/Protocol-Implementations) です。

## <a name="using-the-language-server-protocol-in-visual-studio"></a>Visual Studio での言語サーバープロトコルの使用

* [言語サーバープロトコル拡張機能の追加](adding-an-lsp-extension.md) -言語サーバーを Visual Studio に統合する方法について説明します。
