---
title: Visual Studio のアプリケーション パターン |マイクロソフトドキュメント
ms.date: 04/26/2017
ms.topic: conceptual
ms.assetid: 8ed68602-4e28-46fe-b39f-f41979b308a2
author: madskristensen
ms.author: madsk
manager: jillfra
ms.workload:
- vssdk
ms.openlocfilehash: 55044df3898b452e87ec877f9ae10dd12a2b1110
ms.sourcegitcommit: 95f26af1da51d4c83ae78adcb7372b32364d8a2b
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 03/13/2020
ms.locfileid: "79301591"
---
# <a name="application-patterns-for-visual-studio"></a>Visual Studio のアプリケーション パターン
## <a name="window-interactions"></a><a name="BKMK_WindowInteractions"></a>ウィンドウの相互作用

### <a name="overview"></a>概要
Visual Studio で使用される 2 つのメイン ウィンドウの種類は、ドキュメント エディターとツール ウィンドウです。 まれですが、モードレスダイアログは大きくなります。 これらはすべてシェルではモードレスですが、パターンは根本的に異なります。 ここでは、ドキュメント ウィンドウ、ツール ウィンドウ、モードレス ダイアログの違いについて説明します。 モーダル ダイアログ パターンについては、「[ダイアログ」を参照してください](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Dialogs)。

### <a name="comparing-window-usage-patterns"></a>ウィンドウの使用パターンの比較
**ほとんどの場合、ドキュメント ウィンドウ**はドキュメント内に表示されます。 これにより、ドキュメント エディタは補助的なツール ウィンドウを配置する「センター ステージ」になります。

**ツール ウィンドウ**は、通常、IDE の端に対して縮小された、別の小さなウィンドウとして表示されます。 表示、非表示、または自動非表示を設定できます。 ただし、ウィンドウ**のウィンドウ/ドッキング**プロパティをオフにして、ツール ウィンドウがドキュメント内で適切に表示される場合があります。 これにより、より多くの領域が得られますが、共通の設計上の決定:Visual Studio に統合しようとする場合、機能でツール ウィンドウまたはドキュメント ウィンドウのどちらを表示するかを決定する必要があります。

**モードレス ダイアログは**、Visual Studio では推奨されません。 ほとんどのモードレス ダイアログは、定義上、フローティング ツール ウィンドウであり、そのように実装する必要があります。 モードレス ダイアログは、シェルの側面にドッキングされている通常のツール ウィンドウのサイズが制限されすぎる場合に使用できます。 また、ユーザーがダイアログをセカンダリ モニタに移動する可能性がある場合にも許可されます。

必要なコンテナーの種類について慎重に考えてください。 UI 設計の一般的な使用パターンの考慮事項を次の表に示します。

||ドキュメント ウィンドウ|ツール ウィンドウ|モードレス ダイアログ|
|-|---------------------|-----------------|---------------------|
| **位置** | 常にドキュメント内に配置され、IDE の端にドッキングされません。 メインシェルとは別に浮かぶように「引き離す」ことができます。 | 通常、IDE の端をタブドッキングしますが、フローティング、自動非表示 (固定解除)、またはドキュメント内のドッキングにカスタマイズできます。|IDE とは別の大きなフローティング ウィンドウ。 |
| **コミット モデル** | *遅延コミット*<br /><br /> データをドキュメントに保存するには、[**&gt;ファイルの保存]、[名前**を**付けて保存**]、または **[すべて保存]** を実行する必要があります。 ドキュメントウィンドウには、その中のデータが"dirtied"され、保存コマンドの1つにコミットされるという概念があります。 ドキュメント ウィンドウを閉じると、すべての内容がディスクに保存されるか、または失われます。 | *即時コミット*<br /><br /> 保存モデルはありません。 ファイルの編集を補助するインスペクター ツール ウィンドウの場合、ファイルはアクティブなエディターまたはデザイナーで開いておく必要があり、エディターまたはデザイナーが保存を所有している必要があります。 | *遅延または即時コミット*<br /><br /> 大きなモードレス ダイアログでは、変更をコミットするアクションが必要になり、ダイアログ セッション内で行われた変更をロールバックする "キャンセル" 操作が可能になります。  これにより、モードレス ダイアログとツール ウィンドウのツール ウィンドウが常に即時コミット モデルを持つの間で区別されます。 |
| **表示** | *開く/作成 (ファイル) と閉じる*<br /><br /> ドキュメント ウィンドウを開く場合は、既存のドキュメントを開くか、テンプレートを使用して新しいドキュメントを作成します。 [特定のエディターを\<開く>] コマンドはありません。 | *表示と非表示*<br /><br /> 単一インスタンスツール ウィンドウは、非表示または表示できます。 ツール ウィンドウ内のコンテンツと状態は、表示中でも非表示でも保持されます。 マルチインスタンス ツール ウィンドウは、非表示にして閉じることができます。 マルチインスタンス ツール ウィンドウを閉じると、ツール ウィンドウ内のコンテンツと状態が破棄されます。 | *コマンドから起動*<br /><br /> ダイアログは、タスクベースのコマンドから起動されます。 |
| **インスタンス** | *マルチインスタンス*<br /><br /> 複数のエディタを同時に開いて異なるファイルを編集できますが、一部のエディターでは、同じファイルを複数のエディタで開くことができます **(Window &gt; New Window**コマンドを使用)。<br /><br /> 1 つのエディターで、1 つまたは複数のファイルを同時に編集できます (プロジェクト デザイナー)。 | *単一インスタンスまたは複数インスタンス*<br /><br /> 内容は、コンテキストを反映するように変更されます (プロパティ ブラウザーのように) またはフォーカス/コンテキストを他のウィンドウ (タスク一覧、ソリューション エクスプローラー) にプッシュします。<br /><br /> 単一インスタンスとマルチインスタンスの両方のツール ウィンドウは、必要のない理由がない限り、アクティブ なドキュメント ウィンドウに関連付ける必要があります。 | *単一インスタンス* |
| **例** | **コード エディターのようなテキスト エディター**<br /><br /> **フォーム**デザイナやモデリング サーフェスなどのデザイン サーフェイス<br /><br /> **マニフェスト デザイナーのような、ダイアログに似たコントロール レイアウト** | **ソリューション エクスプローラ**には、ソリューション内に含まれるソリューションとプロジェクトが用意されています。<br /><br /> **サーバー エクスプローラー**には、ユーザーがウィンドウで開くことを選択したサーバーとデータ接続の階層ビューが用意されています。 クエリなどのデータベース階層からオブジェクトを開くと、ドキュメント ウィンドウが開き、ユーザーはクエリを編集できるようになります。<br /><br /> **プロパティ ブラウザ**には、ドキュメント ウィンドウまたは他のツール ウィンドウで選択したオブジェクトのプロパティが表示されます。 プロパティは、階層グリッド ビューまたは複雑なダイアログのようなコントロールに表示され、ユーザーがそれらのプロパティの値を設定できるようにします。 | |

## <a name="tool-windows"></a><a name="BKMK_ToolWindows"></a>ツール ウィンドウ

### <a name="overview"></a>概要
ツール ウィンドウは、ドキュメント ウィンドウで行われるユーザーの作業をサポートします。 これらのオブジェクトは、Visual Studio が提供し、操作できる基本的なルート オブジェクトを表す階層を表示するために使用できます。

IDE で新しいツール ウィンドウを検討する場合、作成者は次の手順を実行する必要があります。

- タスクに適した既存のツール ウィンドウを使用し、同様の機能を持つ新しいツール ウィンドウを作成しないようにします。 新しいツール ウィンドウは、同じようなウィンドウに統合できない、または既存のウィンドウをピボット ハブに変換して、大きく異なる "ツール" または機能を提供する場合にのみ作成する必要があります。

- 必要に応じて、ツール ウィンドウの上部に標準コマンド バーを使用します。

- コントロールの表示やキーボードのナビゲーションのために、他のツール ウィンドウに既に表示されているパターンと一致します。

- 他のツール ウィンドウでのコントロールの表示と一貫性を保つ。

- ドキュメント固有のツール ウィンドウは可能な場合は自動的に表示されるようにし、親ドキュメントがアクティブになったときにのみ表示されるようにします。

- ウィンドウの内容がキーボードでナビゲート可能であることを確認します(矢印キーをサポート)。

#### <a name="tool-window-states"></a>ツール ウィンドウの状態
Visual Studio のツール ウィンドウにはさまざまな状態があり、その一部はユーザーがアクティブ化します (自動非表示機能など)。 自動表示などの他の状態では、ツール ウィンドウを適切なコンテキストで表示し、必要でないときに非表示にできます。 ツール ウィンドウの状態は合計で 5 つあります。

- **ドッキング/固定ツール**ウィンドウは、ドキュメント領域の 4 つの側面のいずれかにアタッチできます。 ツール ウィンドウのタイトル バーに、プッシュピン アイコンが表示されます。 ツール ウィンドウは、シェルや他のツール ウィンドウの端に沿って水平または垂直にドッキングでき、タブリンクすることもできます。

- **自動非表示ツール**ウィンドウのピン留めは解除されます。 ウィンドウは見えないところにスライドし、ドキュメント領域の端にタブ(ツール ウィンドウの名前とアイコン)を残すことができます。 ユーザーがタブの上にカーソルを置くと、ツール ウィンドウがスライドします。

- **自動表示**ツール ウィンドウは、エディタなどの別の UI が起動されたりフォーカスを得たりすると自動的に表示されます。

- **浮動**ツール ウィンドウは IDE の外側に移動します。 これは、マルチモニタ構成に便利です。

- **タブ付きドキュメント**ツール ウィンドウは、ドキュメント内にドッキングできます。 これは、オブジェクト ブラウザのような大きなツール ウィンドウで、フレームの端にドッキングするよりも多くの領域を必要とする場合に便利です。

![Visual Studio でのツール ウィンドウの状態](../../extensibility/ux-guidelines/media/0702-01_toolwindowstates.png "0702-01_ToolWindowStates")<br />Visual Studio でのツール ウィンドウの状態

#### <a name="single-instance-and-multi-instance"></a>単一インスタンスとマルチインスタンス
ツール ウィンドウは、単一インスタンスまたは複数インスタンスのいずれかです。 一部のシングルインスタンス ツール ウィンドウはアクティブ なドキュメント ウィンドウに関連付けられる場合がありますが、複数インスタンスのツール ウィンドウは関連付けできません。 マルチインスタンス ツール ウィンドウは、**ウィンドウ&gt;の新しい**インスタンスを作成することで[ウィンドウの新規作成] コマンドに応答します。 次の図は、ウィンドウのインスタンスがアクティブなときに[新しいウィンドウ]コマンドを有効にするツール ウィンドウを示しています。

![ウィンドウのインスタンスがアクティブな場合に[新しいウィンドウ]コマンドを有効にするツールウィンドウ](../../extensibility/ux-guidelines/media/0702-02_toolwindowenablingcommand.png "0702-02_ToolWindowEnablingCommand")<br />ウィンドウのインスタンスがアクティブな場合に[新しいウィンドウ]コマンドを有効にするツールウィンドウ

単一インスタンス ツール ウィンドウは非表示または表示できますが、複数インスタンス のツール ウィンドウは非表示にしたり、非表示にすることもできます。 すべてのツール ウィンドウは、ドッキング、タブリンク、フローティング、またはマルチドキュメント インターフェイス (MDI) 子ウィンドウとして設定できます (ドキュメント ウィンドウに似ています)。 すべてのツール ウィンドウは、[ウィンドウ] メニューの適切なウィンドウ管理コマンドに応答する必要があります。

![[Visual Studio ウィンドウ] メニューのウィンドウ管理コマンド](../../extensibility/ux-guidelines/media/0702-03_windowmanagementcontrols.png "0702-03_WindowManagementControls")<br />[Visual Studio ウィンドウ] メニューのウィンドウ管理コマンド

#### <a name="document-specific-tool-windows"></a>ドキュメント固有のツール ウィンドウ
一部のツール ウィンドウは、特定の種類のドキュメントに基づいて変更するように設計されています。 これらのウィンドウは、IDE のアクティブなドキュメント ウィンドウに適用される機能を反映するように継続的に更新されます。

選択したエディターを反映するように内容が変更されるツール ウィンドウの例としては、ツールボックスとドキュメント アウトラインがあります。 これらのウィンドウは、ウィンドウにコンテキストを提供しないエディターにフォーカスがあるときにウォーターマークを表示します。

#### <a name="navigable-list-tool-windows"></a>ナビゲーション可能なリスト ツール ウィンドウ
ツール ウィンドウによっては、ユーザーが操作できるナビゲート可能な項目の一覧が表示されます。 このウィンドウでは、ウィンドウが非アクティブな場合でも、リスト内の現在の項目に対するフィードバックが常に存在する必要があります。 リストは、ウィンドウ内で現在選択されている項目を変更することによって **、GoToNextLocation**コマンドと**GoToPrevLocation**コマンドに応答する必要があります。

ナビゲーション可能なリスト ツール ウィンドウの例としては、ソリューション エクスプローラーと [検索結果] ウィンドウがあります。

### <a name="tool-window-types"></a>ツール ウィンドウの種類

#### <a name="common-tool-windows-and-their-functions"></a>一般的なツール ウィンドウとその機能

**階層ツール ウィンドウ**

| ツール ウィンドウ | Function |
| --- | --- |
| ソリューション エクスプローラー | プロジェクト、その他のファイル、およびソリューション項目に含まれるドキュメントの一覧を表示する階層ツリー。 プロジェクト内の項目の表示は、プロジェクトの種類 (参照ベース、ディレクトリベース、混合モードなど) を所有するパッケージによって定義されます。 |
| クラス ビュー | ファイル自体に依存しない、ドキュメントのワーキング セット内のクラスおよびさまざまな要素の階層ツリー。 |
| [サーバー エクスプローラー] | ソリューション内のすべてのサーバーとデータ接続を表示する階層ツリー。 |
| [ドキュメント アウトライン] | アクティブドキュメントの階層構造。 |

**グリッド ツール ウィンドウ**

| ツール ウィンドウ | Function |
| --- | --- |
| Properties | 選択したオブジェクトのプロパティの一覧と、それらのプロパティを編集するための値の選択コントロールを表示するグリッド。 |
| タスク一覧 | ユーザーがタスクやコメントを作成/編集/削除できるグリッド。 |

**コンテンツ ツール ウィンドウ**

| ツール ウィンドウ | Function |
| --- | --- |
| Help | ユーザーが「どのようにしたらいいですか」から、さまざまな方法でヘルプを取得できるウィンドウです。 MSDN フォーラムへのビデオ。 |
| ダイナミック ヘルプを表示する | 現在の選択項目に適用可能なヘルプ トピックへのリンクを表示するツール ウィンドウ。 |
| オブジェクト ブラウザー | 左ペインに階層オブジェクトコンポーネントのリスト、右側の列にオブジェクトのプロパティとメソッドが表示される 2 列のフレームセット。 |

**ダイアログ ツール ウィンドウ**

| ツール ウィンドウ | Function |
| --- | --- |
| Find | ユーザーがソリューション内のさまざまなファイルを検索したり、検索したり置換したりするためのダイアログ。 |
| 高度な検索 | ユーザーがソリューション内のさまざまなファイルを検索したり、検索したり置換したりするためのダイアログ。 |

**その他のツール ウィンドウ**

::: moniker range="vs-2017"

| ツール ウィンドウ | Function |
| --- | --- |
| [ツールボックス] | デザイン サーフェイスにドロップされる要素を格納するために使用されるツール ウィンドウ。 |
| スタート ページ | 開発者向けニュース、Visual Studio ヘルプ、および最近のプロジェクトのフィードにアクセスできる、Visual Studio へのユーザーのポータル。 ユーザーは、StartPage.xaml ファイルを "Common7\IDE\StartPages\" Visual Studio プログラム ファイル ディレクトリから Visual Studio ドキュメント ディレクトリのスタート ページ フォルダーにコピーし、XAML を手作業で編集するか、Visual Studio または別のコード エディターで開くことで、カスタム スタート ページを作成することもできます。 |

::: moniker-end

::: moniker range=">=vs-2019"

| ツール ウィンドウ | Function |
| --- | --- |
| [ツールボックス] | デザイン サーフェイスにドロップされる要素を格納するために使用されるツール ウィンドウ。 |

::: moniker-end

**デバッガー ツール ウィンドウ**

| ツール ウィンドウ | Function |
| --- | --- |
| Autos ||
| 即時 ||
| Output | 出力ウィンドウは、宣言するテキスト イベントまたはステータスがある場合にいつでも使用できます。 |
| メモリ ||
| ブレークポイント ||
| 実行中 ||
| Documents ||
| 呼び出し履歴 ||
| Locals ||
| 時計 ||
| 逆アセンブリ ||
| レジスタ ||
| Threads ||

## <a name="document-editor-conventions"></a><a name="BKMK_DocumentEditorConventions"></a>ドキュメント エディタの規則

### <a name="document-interactions"></a>ドキュメントの相互作用
"ドキュメントウェル" は、IDE 内で最大の領域であり、ユーザーが一般的に、補助ツール ウィンドウによって支援されたタスクを完了するために注意を集中している場所です。 ドキュメント エディターは、ユーザーが Visual Studio 内で開いて保存する作業の基本単位を表します。 ソリューション エクスプローラやその他のアクティブな階層ウィンドウに関連付けられた、強力な選択意識が保持されます。 ユーザーは、これらの階層ウィンドウのいずれかをポイントし、ドキュメントが含まれている場所と、Visual Studio パッケージによって提供されるソリューション、プロジェクト、または別のルート オブジェクトとの関係を把握できる必要があります。

ドキュメントの編集には、一貫したユーザー エクスペリエンスが必要です。 ウィンドウ管理やコマンドの検索ではなく、手元のタスクに集中できるようにするには、ドキュメントの種類を編集するユーザー タスクに最も適したドキュメント ビュー戦略を選択します。

#### <a name="common-interactions-for-the-document-well"></a>ドキュメントの一般的な相互作用

- 一般的な**新規ファイルおよびオープン・ファイル**・エクスペリエンス**Open File**で、一貫した対話モデルを維持します。

- ドキュメント ウィンドウが開いたときに、関連するウィンドウおよびメニューの関連する機能を更新します。

- メニュー コマンドは、**編集**メニュー、**フォーマット**メニュー **、表示メニュー**などの共通メニューに適切に統合されています。 大量の特殊なコマンドが使用可能な場合は、新しいメニューを作成できます。 この新しいメニューは、文書にフォーカスがある場合にのみ表示されます。

- 埋め込みツールバーはエディタの上部に配置できます。 これは、エディタの外に表示される別のツールバーを用意する方が望ましいです。

- ソリューション エクスプローラまたは同様のアクティブ階層ウィンドウで、常に選択を維持します。

- ソリューション エクスプローラでドキュメントをダブルクリックすると、**開く**操作と同じ操作が実行されます。

- ドキュメントタイプに対して複数のエディタを使用できる場合、ファイルを右クリックしてショートカットメニューから[ファイルを**開く**]を選択すると、[**ファイルを開く**]ダイアログボックスを使用して、特定のドキュメントタイプのデフォルトアクションを上書きまたはリセットできます。

- ドキュメント内でウィザードをうまく作成しないでください。

### <a name="user-expectations-for-specific-document-types"></a>特定のドキュメントタイプに対するユーザーの期待
ドキュメント エディタには、いくつかの異なる基本的な種類があり、それぞれが同じ種類の他のエディターと一致する一連の相互作用があります。

- **テキストベースのエディタ:** コードエディタ、ログファイル

- **デザインサーフェイス:** WPF フォーム デザイナー、Windows フォーム

- **ダイアログ スタイルのエディター:** マニフェスト デザイナー、プロジェクト プロパティ

- **モデルデザイナー:** ワークフローデザイナー、コードマップ、アーキテクチャ図、進行

また、ドキュメントをうまく使用する非編集者タイプもいくつかあります。 ドキュメント自体は編集しませんが、ドキュメント ウィンドウの標準の操作に従う必要があります。

- **レポート:** IntelliTrace レポート、Hyper-V レポート、プロファイラー レポート

- **ダッシュボード:** 診断ハブ

#### <a name="text-based-editors"></a>テキストベースのエディタ

- ドキュメントはプレビュー タブ モデルに含まれるため、ドキュメントを開かずにプレビューできます。

- ドキュメントの構造は、ドキュメントアウトラインなどのコンパニオンツールウィンドウ内で表されます。

- IntelliSense (必要な場合) は、他のコード エディターと一貫して動作します。

- ポップアップや支援 UI は、CodeLens などの既存の類似 UI の同様のスタイルとパターンに従います。

- ドキュメントの状態に関するメッセージは、ドキュメントの上部にある情報バー コントロールまたはステータス バーに表示されます。

- ユーザーは、[**ツール] >オプション**ページ(共有フォントと色) ページまたはエディター固有のフォントと色の外観をカスタマイズできる必要があります。

#### <a name="design-surfaces"></a>デザインサーフェイス

- 空のデザイナーには、開始方法を示すウォーターマークが表面に表示されている必要があります。

- ビュー切り替えメカニズムは、ダブルクリックしてコード エディターを開くなどの既存のパターンに従うか、ドキュメント ウィンドウ内のタブを使用して両方のペインと対話できます。

- デザイン サーフェイスに要素を追加するには、高度に固有のツール ウィンドウが必要な場合を除き、ツールボックスを使用して行う必要があります。

- サーフェス上の項目は、一貫した選択モデルに従います。

- 埋め込みツールバーには、文書固有のコマンドのみが含まれ、**保存**などの一般的なコマンドは含まれません。

#### <a name="dialog-style-editors"></a>ダイアログ スタイルのエディター

- コントロール レイアウトは、通常のダイアログ レイアウト規則に従う必要があります。

- エディタ内のタブは、ドキュメントタブの外観と一致しないようにする必要があり、2つの許可された内部タブスタイルの1つと一致する必要があります。

- ユーザーはキーボードのみを使用してコントロールを操作できる必要があります。エディターをアクティブにしてコントロールをタブ移動するか、標準のニーモニックを使用します。

- デザイナーは、共通の保存モデルを使用する必要があります。 他のボタンが適切である場合がありますが、全体的な保存またはコミット ボタンはサーフェス上に配置しないでください。

#### <a name="model-designers"></a>モデルデザイナー

- 空のデザイナーには、開始方法を示すウォーターマークが表面に表示されている必要があります。

- デザイン サーフェイスに要素を追加するには、ツールボックスを使用します。

- サーフェス上の項目は、一貫した選択モデルに従います。

- 埋め込みツールバーには、文書固有のコマンドのみが含まれ、**保存**などの一般的なコマンドは含まれません。

- 凡例は、サーフェス上に、示す記号または透かしのどちらでも表示されます。

- ユーザーは、ツール **>オプション ページ**(共有フォントと色)ページまたはエディタ固有のフォント/色の外観をカスタマイズできる必要があります。

#### <a name="reports"></a>Reports

- レポートは通常情報のみであり、保存モデルには参加しません。 ただし、他の関連情報へのリンクや、展開および縮小するセクションへのリンクなどの相互作用が含まれる場合があります。

- サーフェス上のほとんどのコマンドは、ボタンではなくハイパーリンクにする必要があります。

- レイアウトにはヘッダーを含め、標準のレポート レイアウトガイドラインに従う必要があります。

#### <a name="dashboards"></a>ダッシュボード

- ダッシュボードにはインタラクションモデル自体はありませんが、他のさまざまなツールを提供する手段として機能します。

- 保存モデルには参加しません。

- ユーザーは、エディターをアクティブにしてコントロールをタブ操作するか、標準のニーモニックを使用して、キーボードのみを使用してコントロールを操作できる必要があります。

## <a name="dialogs"></a><a name="BKMK_Dialogs"></a>ダイアログ

### <a name="introduction"></a>はじめに
Visual Studio のダイアログボックスは、通常、ユーザーの作業の 1 つの個別の単位をサポートし、その後、閉じられます。

ダイアログが必要であると判断した場合は、次の 3 つの選択肢を優先順に選択できます。

1. Visual Studio の共有ダイアログのいずれかに機能を統合します。

2. 既存の類似ダイアログで見つかったパターンを使用して、独自のダイアログを作成します。

3. 対話とレイアウトのガイドラインに従って、新しいダイアログを作成します。

このセクションでは、Visual Studio ワークフロー内で正しいダイアログ パターンを選択する方法と、ダイアログ デザインの一般的な規則について説明します。

### <a name="themes"></a>テーマ
Visual Studio のダイアログ ボックスは、次の 2 つの基本的なスタイルのいずれかに従います。

#### <a name="standard-unthemed"></a>標準(テーマなし)
ダイアログの大半は標準のユーティリティ ダイアログボックスであり、テーマを設定しないでください。 共通コントロールの再テンプレートを作成したり、スタイル化された "モダン" ボタンやコントロールを作成したりしないでください。 コントロールとクロムの外観は、[ダイアログ ボックスの Windows デスクトップの標準操作ガイドラインに従います](/windows/desktop/uxguide/win-dialog-box)。

#### <a name="themed"></a>テーマ
特殊な「署名」ダイアログはテーマにしている場合があります。 テーマのダイアログには、スタイルに関連付けられた特別な相互作用パターンも持つ、明確な外観があります。 ダイアログが次の要件を満たしている場合にのみテーマを設定します。

- ダイアログは、よく見られ、使用される一般的なエクスペリエンスです (たとえば、**新しいプロジェクト**ダイアログ)。

- このダイアログには、著名な製品ブランド要素 (アカウント**設定**ダイアログなど) が含まれています。

- ダイアログは、他のテーマを持つダイアログを含む大きなフローの不可欠な部分として表示されます (例:**接続済みサービスの追加**ダイアログ)。

- このダイアログは、製品バージョンのプロモーションまたは差別化において戦略的な役割を果たすエクスペリエンスの重要な部分です。

テーマを設定したダイアログを作成する場合は、適切な環境カラーを使用し、適切なレイアウトと対話パターンに従います。 ([ビジュアルスタジオのレイアウトを](../../extensibility/ux-guidelines/layout-for-visual-studio.md)参照してください。

### <a name="dialog-design"></a>ダイアログの設計
適切に設計されたダイアログでは、次の要素を考慮に入れます。

- サポートされているユーザー タスク

- ダイアログテキストのスタイル、言語、および用語

- コントロールの選択と UI の規則

- 視覚的レイアウト仕様と制御の配置

- キーボード アクセス

#### <a name="content-organization"></a>コンテンツ編成
これらの基本的なタイプのダイアログの違いを考慮してください。

- [単純なダイアログ ボックスは、1](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_SimpleDialogs)つのモーダル ウィンドウにコントロールを表示します。 プレゼンテーションには、フィールド ピッカーやアイコン バーなど、複雑なコントロール パターンのバリエーションが含まれる場合があります。

- [レイヤード ダイアログ](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_LayeredDialogs)は、1 つの UI が複数のコントロール グループで構成されている場合に、画面の領域を最大限に活用するために使用されます。 ダイアログのグループ化はタブ コントロール、ナビゲーション リスト コントロール、またはボタンを通じて "階層化" されるため、ユーザーは任意の時点で表示するグループを選択できます。

- [ウィザードは、](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Wizards)タスクの完了に向けて、ユーザーに論理的な手順を実行させる場合に便利です。 一連の選択肢は、前のパネルで行われた選択に応じて異なるワークフロー(「ブランチ」)を導入する場合があり、シーケンシャルパネルで提供されています。

#### <a name="simple-dialogs"></a><a name="BKMK_SimpleDialogs"></a>シンプルなダイアログ
単純なダイアログは、単一のモーダル ウィンドウでコントロールを表示することです。 このプレゼンテーションには、フィールド ピッカーなどの複雑なコントロール パターンのバリエーションが含まれる場合があります。 単純なダイアログでは、標準の一般レイアウトと、複雑なコントロールのグループ化に必要な特定のレイアウトに従います。

![>厳密な名前キーの作成は、Visual Studio での簡単なダイアログの例です。](../../extensibility/ux-guidelines/media/0704-01_createstrongnamekey.png "0704-01_CreateStrongNameKey")<br />厳密な名前キーの作成は、Visual Studio での簡単なダイアログの例です。

#### <a name="layered-dialogs"></a><a name="BKMK_LayeredDialogs"></a>階層化されたダイアログ
階層化されたダイアログには、タブ、ダッシュボード、埋め込みツリーがあります。 これらは、単一の UI で複数のコントロール グループが提供されている場合に、不動産を最大化するために使用されます。 グループ化は、ユーザーが一度に表示するグループを選択できるように、階層化されます。

最も簡単な場合、グループ化を切り替えるメカニズムはタブ コントロールです。 いくつかの選択肢があります。 最も適切なスタイルを選択する方法については、「優先順位付けとレイヤー」を参照してください。

[**ツール&gt;オプション]** ダイアログボックスは、埋め込みツリーを使用したレイヤ 化されたダイアログの例です。

![ツール> オプションは、Visual Studio の階層化されたダイアログの例です。](../../extensibility/ux-guidelines/media/0704-02_toolsoptions.png "0704-02_ToolsOptions")<br />ツール> オプションは、Visual Studio の階層化されたダイアログの例です。

#### <a name="wizards"></a><a name="BKMK_Wizards"></a>ウィザード
ウィザードは、タスクの完了時にユーザーに一連の手順を実行させる場合に便利です。 一連の選択肢は、順次パネルで提供され、ユーザーは次のステップに進む前に、各ステップを続行する必要があります。 十分なデフォルトが使用可能になると、[**完了]** ボタンが有効になります。

 モーダル ウィザードは、次のタスクに使用されます。

- ユーザーの選択に応じて異なるパスが提供される分岐を含む

- ステップ間の依存関係を含む (後続のステップは前のステップからのユーザー入力に依存する)

- UI を使用して、提供される選択肢と各ステップで可能な結果を説明する必要がある十分に複雑です。

- トランザクション型であり、変更がコミットされる前に一連の手順を完了する必要がある

### <a name="common-conventions"></a>一般的な規則
ダイアログで最適な設計と機能を実現するには、ダイアログ のサイズ、位置、標準、制御の構成と配置、UI テキスト、タイトル バー、コントロール ボタン、およびアクセス キーに関する次の規則に従います。

レイアウト固有のガイドラインについては、「 [Visual Studio のレイアウト](../../extensibility/ux-guidelines/layout-for-visual-studio.md)」を参照してください。

#### <a name="size"></a>Size
ダイアログは、最小解像度 1024x768 の画面解像度に収まるようにし、初期ダイアログ サイズは 900 x 700 ピクセルを超えないようにする必要があります。 ダイアログは変更可能な場合がありますが、必須ではありません。

変更可能なダイアログには、次の 2 つの推奨事項があります。

1. 最小サイズは、クリッピングなしでコントロール セットに最適化し、適切なローカリゼーションの拡大に対応するように調整するダイアログに定義されています。

2. ユーザースケールのサイズがセッションからセッションに持続すること。 たとえば、ユーザーがダイアログを 150% にスケールすると、その後のダイアログの起動は 150% で表示されます。

#### <a name="position"></a>[位置]
ダイアログは、最初の起動時に IDE の中央に表示される必要があります。 変更できないダイアログの最後の位置は永続化する必要はありません。

サイズ変更可能なダイアログでは、サイズは以降の起動時に保持する必要があります。 モーダル ダイアログの大きさを変更する場合、位置を保持する必要はありません。 IDE 内で中央に表示すると、ユーザーの表示設定が変更されたときに、ダイアログが予期しない位置や使用できない位置に表示される可能性がなくなります。

モードレスダイアログの位置を変更できる場合、ダイアログは大規模なワークフローの不可欠な部分として頻繁に使用される可能性があるため、以降の起動時にユーザーの位置を維持する必要があります。

ダイアログが他のダイアログを生成する必要がある場合、最上位のダイアログは親から右下に重なって表示され、ユーザーが新しい場所に移動したことをユーザーに明らかにします。

#### <a name="modality"></a>モダリティ
モーダルとは、ユーザーが続行する前にダイアログを完了またはキャンセルする必要があることを意味します。 モーダル ダイアログでは、ユーザーが環境の他の部分と対話できないようにするため、機能のタスク フローでは、できるだけ慎重に使用する必要があります。 モーダル操作が必要な場合、Visual Studio には、機能を統合できる多数の共有ダイアログがあります。 新しいダイアログを作成する必要がある場合は、類似した機能を持つ既存のダイアログの対話パターンに従ってください。

新しいコードを記述しているときに[**検索**と**置換]** などの 2 つの操作を一度に実行する必要がある場合、ダイアログ ボックスはモードレスにして、ユーザーが簡単に切り替えられるようにする必要があります。 Visual Studio では、通常、このようなエディターをサポートするリンクされたタスクにツール ウィンドウを使用します。

#### <a name="control-configuration"></a>構成の制御
Visual Studio で同じことを実現する既存のコントロール構成と一貫性を保つ。

#### <a name="title-bars"></a>タイトル バー

- タイトル バーのテキストには、起動したコマンドの名前が反映されている必要があります。

- ダイアログタイトルバーでは、アイコンを使用しないでください。 システムで必要な場合は、Visual Studio ロゴを使用します。

- ダイアログには最小化ボタンまたは最大化ボタンを設定しないでください。

- タイトル バーのヘルプ ボタンは廃止されました。 新しいダイアログに追加しないでください。 存在する場合、タスクに関連する概念的なヘルプ トピックを起動する必要があります。

  ![Visual Studio ダイアログのタイトル バーのガイドラインの仕様](../../extensibility/ux-guidelines/media/0704-03_titlebarspecs.png "0704-03_TitleBarSpecs")<br />Visual Studio ダイアログのタイトル バーのガイドラインの仕様

#### <a name="control-buttons"></a>コントロールボタン
通常、ダイアログの右下隅に **[OK]、[****キャンセル]、[****ヘルプ**] の各ボタンを水平方向に配置する必要があります。 ダイアログ ボックスの下部にコントロール ボタンとの視覚的な混乱を示す他のいくつかのボタンがある場合、代替垂直スタックが許可されます。

![Visual Studio ダイアログボックスでのコントロールボタンの許容可能な構成](../../extensibility/ux-guidelines/media/0704-04_controlbuttonconfig.png "0704-04_ControlButtonConfig")<br />Visual Studio ダイアログボックスでのコントロールボタンの許容可能な構成

ダイアログには、既定のコントロール ボタンが含まれている必要があります。 デフォルトとして使用する最適なコマンドを決定するには、次のオプション (優先順位の順にリスト) から選択します。

- 最も安全で安全なコマンドをデフォルトとして選択します。 つまり、データの損失を防ぎ、意図しないシステム・アクセスを回避する可能性が最も高いコマンドを選択します。

- データの損失とセキュリティが要因でない場合は、利便性に基づいて既定のコマンドを選択します。 最も可能性の高いコマンドを既定として含めると、ダイアログが頻繁にまたは繰り返し実行されるタスクをサポートしている場合に、ユーザーのワークフローが向上します。

デフォルトコマンドに対して永続的に破壊的なアクションを選択しないようにします。 このようなコマンドが存在する場合は、より安全なコマンドをデフォルトとして選択してください。

#### <a name="access-keys"></a>アクセス キー
**[OK]、[****キャンセル]、** または **[ヘルプ**] ボタンにはアクセス キーを使用しないでください。 これらのボタンは、デフォルトでショートカットキーにマップされます。

| ボタン名 | キーボード ショートカット |
| --- | --- |
| [OK] | 次に、 |
| Cancel | Esc |
| Help | F1 |

#### <a name="imagery"></a>画像
ダイアログで画像を控えめに使用します。 大きなアイコンをダイアログで使用してスペースを使い切るだけじゃない。 警告アイコンやステータス アニメーションなど、ユーザーにメッセージを伝える重要な部分である場合にのみ、イメージを使用します。

### <a name="prioritizing-and-layering"></a><a name="BKMK_PrioritizingAndLayering"></a>優先順位付けと階層化

#### <a name="prioritizing-your-ui"></a>UI の優先順位付け
特定の UI 要素を前面に表示し、より高度な動作とオプション (不明瞭なコマンドを含む) をダイアログに配置する必要がある場合があります。 一般的に使用される機能を前面に表示するには、その機能を用意し、ダイアログが表示されたときに UI に既定でテキスト ラベルを付けて表示されるようにします。

#### <a name="layering-your-ui"></a>UI のレイヤー化
ダイアログが必要であると判断した場合、ユーザーに提示する関連機能が単純なダイアログに表示される機能を超えている場合は、UI を重ね合わせておく必要があります。 Visual Studio で使用される最も一般的な層の方法は、タブ、廊下、またはダッシュボードです。 場合によっては、展開や折りたたみが可能な領域が適切な場合があります。 一般に、Visual Studio ではアダプティブ UI はお勧めできません。

タブのようなコントロールを使用して UI を階層化する方法には、さまざまな方法に利点と欠点があります。 以下のリストを確認して、状況に適したレイヤー手法を選択していることを確認してください。

##### <a name="tabbing"></a>タブ

| 切り替え機構 | 利点と適切な使用 | デメリットと不適切な使用 |
| --- | --- | --- |
| タブ コントロール | ダイアログページを関連セットに論理的にグループ化する<br /><br />ダイアログ内の関連するコントロールのページが 5 ページ未満 (またはダイアログ全体に 1 行に収まるタブの数) に便利です。<br /><br />タブラベルは短くする必要があります:コンテンツを簡単に識別できる1つまたは2つの単語<br /><br />共通システム ダイアログ スタイル<br /><br />例:**エクスプローラー&gt;項目のプロパティ** | 説明的な短いラベルを作成することは困難な場合があります<br /><br />一般的に、1 つのダイアログで 5 つのタブを超えるサイズを調整しない<br /><br />1 つの行に対してタブが多すぎる場合は不適切です (別の階層化手法を使用します)。<br /><br />拡張できない |
| サイドバーナビゲーション | タブよりも多くのカテゴリに対応できるシンプルなスイッチングデバイス<br /><br />カテゴリのフラット リスト (階層なし)<br /><br />拡張可能<br /><br />例:**カスタマイズします。コマンド&gt;の追加** | グループが 3 つ未満の場合、水平スペースの使用が良くない<br /><br />タスクはドロップダウンに適している可能性があります。 |
| ツリー コントロール | 無制限のカテゴリを可能にします<br /><br />カテゴリのグループ化および/または階層化を可能にする<br /><br />拡張可能<br /><br />例: **&gt;ツール オプション** | 階層が重くネストされていると、水平方向のスクロールが過剰になる可能性があります。<br /><br />ビジュアル スタジオにはツリー ビューが多く存在します。 |
| ウィザード | タスクベースの順次ステップを通じてユーザーをガイドすることで、タスクの完了に役立ちます: ウィザードは高レベルのタスクを表し、個々のパネルは、タスク全体を達成するために必要なサブタスクを表します<br /><br />タスクが Ui 境界を越える場合に、ユーザーがタスクを完了するために複数のエディターとツール ウィンドウを使用する必要がある場合に便利です。<br /><br />タスクが分岐を必要とする場合に便利です。<br /><br />タスクにステップ間の依存関係が含まれている場合に便利です。<br /><br />1 つの決定分岐を持つ複数の類似したタスクを 1 つのダイアログで表示して、類似した異なるダイアログの数を減らすことができる場合に便利です。 | シーケンシャル ワークフローを必要としないタスクに適していません<br /><br />ユーザーが、手順が多すぎるウィザードに圧倒され、混乱する可能性がある<br /><br />ウィザードは本質的に限られた画面の不動産を持っています |

##### <a name="hallways-or-dashboards"></a>廊下またはダッシュボード
廊下やダッシュボードは、他のダイアログやウィンドウへの起動ポイントとして機能するダイアログまたはパネルです。 適切に設計された 「廊下」は、最も一般的なオプション、コマンド、および設定のみをすぐに表示し、ユーザーが一般的なタスクを容易に実行できるようにします。 現実世界の廊下が、その背後にある部屋にアクセスするための出入り口を提供するように、ここではあまり一般的でない UI が、メインの廊下からアクセスできる関連機能の別々の 「ルーム」(多くの場合は他のダイアログ) に収集されます。

また、あまり一般的でない機能を別の場所にリファクタリングするのではなく、単なるコレクションで使用可能なすべての機能を提供する UI は、単なるダッシュボードです。

![Outlook で追加の UI を公開するための廊下の概念](../../extensibility/ux-guidelines/media/0704-08_hallway.png "0704-08_Hallway")<br />Outlook で追加の UI を公開するための廊下の概念

##### <a name="adaptive-ui"></a>アダプティブ UI
使用法やユーザーの自己報告エクスペリエンスに基づいて UI を表示または非表示にすることは、他の部分を非表示にしながら必要な UI を表示するもう 1 つの方法です。 Visual Studio では、UI の表示と非表示を決定するアルゴリズムは難しい場合があり、一部のケースではルールが間違っている場合もあるため、この方法はお勧めしません。

## <a name="projects"></a><a name="BKMK_Projects"></a>プロジェクト

### <a name="projects-in-the-solution-explorer"></a>ソリューション エクスプローラーのプロジェクト
ほとんどのプロジェクトは、参照ベース、ディレクトリベース、または混合に分類されます。 3 種類のプロジェクトはすべて、ソリューション エクスプローラーで同時にサポートされます。 プロジェクトの操作におけるユーザー エクスペリエンスのルートは、このウィンドウ内で行われます。 異なるプロジェクト ノードは参照、ディレクトリ、または混合モードの種類のプロジェクトですが、プロジェクト固有のユーザー パターンに分岐する前に開始点として適用する必要がある共通の相互作用パターンがあります。

プロジェクトは常に次の手順を実行する必要があります。

- プロジェクトの内容を整理するためにプロジェクトフォルダを追加する機能をサポート

- プロジェクトの永続化のための一貫したモデルを維持する

プロジェクトでは、次の項目について一貫した相互作用モデルを維持する必要があります。

- プロジェクト項目の削除

- ドキュメントの保存

- プロジェクト プロパティの編集

- 代替ビューでのプロジェクトの編集

- ドラッグ アンド ドロップ操作

### <a name="drag-and-drop-interaction-model"></a>ドラッグ アンド ドロップ操作モデル
プロジェクトは通常、参照ベース (ストレージ内のプロジェクト項目への参照のみを保持できる)、ディレクトリベース (プロジェクトの階層内に物理的に保存されたプロジェクト項目のみを保持できる)、または混在 (参照を保持可能) として分類します。または物理的な項目)。 IDE は、ソリューション エクスプローラ内で 3 種類のプロジェクトすべてを同時に取**り込みます**。

ドラッグ アンド ドロップの観点から、**ソリューション エクスプローラー**内のプロジェクトの種類ごとに次の特性が適用されます。

- **参照ベースのプロジェクト:** 重要なポイントは、プロジェクトがストレージ内の項目への参照をドラッグしていることです。 参照ベースのプロジェクトが移動操作のソースとして機能する場合、プロジェクトから項目への参照のみを削除する必要があります。 項目は、実際にはハードドライブから削除しないでください。 参照ベースのプロジェクトが移動 (またはコピー) 操作のターゲットとして機能する場合、そのプロジェクトは、アイテムのプライベート コピーを作成せずに、元のソース アイテムへの参照を追加する必要があります。

- **ディレクトリベースのプロジェクト:** ドラッグ アンド ドロップの観点からは、プロジェクトは参照ではなく物理的な項目を中心にドラッグします。 ディレクトリベースのプロジェクトが移動操作のソースとして機能する場合、最終的に物理項目をハード ドライブから削除し、プロジェクトから削除する必要があります。 ディレクトリベースのプロジェクトが移動 (またはコピー) 操作のターゲットとして機能する場合、ソース項目のコピーをターゲットの場所に作成する必要があります。

- **混合ターゲット プロジェクト:** ドラッグ アンド ドロップの観点から見ると、この種類のプロジェクトの動作は、ドラッグされる項目の性質 (ストレージ内の項目への参照または項目自体) に基づいています。 参照および物理項目の正しい動作は、上記で説明されています。

**ソリューション エクスプローラ**に 1 種類のプロジェクトしか存在しないと、ドラッグ アンド ドロップ操作は簡単です。 各プロジェクト システムには独自のドラッグ アンド ドロップ動作を定義する機能があるため、予測可能なユーザー エクスペリエンスを確保するために、Windows エクスプローラのドラッグ アンド ドロップ動作に基づく特定のガイドラインに従う必要があります。

- **ソリューション エクスプローラ**で変更されていないドラッグ操作 (Ctrl キーも Shift キーも押したままでない場合) は、移動操作になります。

- シフトアンドドラッグ操作も移動操作になります。

- Ctrl キーとドラッグ操作を行うと、コピー操作が行われます。

- 参照ベースのプロジェクト システムと混合プロジェクト システムでは、ソース項目にリンク (または参照) を追加するという概念がサポートされます。 これらのプロジェクトがドラッグ アンド ドロップ操作のターゲットである場合 **(Ctrl + Shift キー**を押しながら押すと)、プロジェクトに追加される項目への参照が作成されます。

すべてのドラッグ アンド ドロップ操作が、参照ベース、ディレクトリ ベース、および混在プロジェクトの組み合わせで意味を持つわけではありません。 特に、移動の完了時にソース ディレクトリ ベースのプロジェクトを削除する必要があるため、ディレクトリ ベースのソース プロジェクトと参照ベースのターゲット プロジェクトの間で移動操作を許可するふりをするのは問題です。 ターゲット参照ベースのプロジェクトは、削除された項目への参照で終了します。

また、ターゲット参照ベースのプロジェクトはソース項目の独立したコピーを作成してはならないため、これらのタイプのプロジェクト間でコピー操作を許可するふりをすると誤解を招く可能性があります。 同様に、ディレクトリベースのプロジェクトは参照を保持できないため、ディレクトリベースのターゲット プロジェクトにドラッグする Ctrl + Shift は許可されません。 ドラッグ アンド ドロップ操作がサポートされていない場合、IDE はドロップを禁止し、ユーザーにノードロップ カーソルを表示する必要があります (下のポインターの表に示します)。

ドラッグ アンド ドロップ動作を適切に実装するには、ドラッグ元のプロジェクトが、その性質をターゲット プロジェクトに伝える必要があります。 (たとえば、参照ベースかディレクトリベースか。この情報は、ソースによって提供されるクリップボード形式で示されます。 ドラッグ (またはクリップボードのコピー操作) のソースとして、プロジェクトが参照`CF_VSREFPROJECTITEMS`ベース`CF_VSSTGPROJECTITEMS`かディレクトリベースかに応じて、プロジェクトがそれぞれまたはそれぞれ提供する必要があります。 どちらの形式も同じデータコンテンツを持っていますが、Windows`CF_HDROP`形式に似ていますが、ファイル名ではなく文字列のリストが文字列の`NULL``Projref`二重終了リスト (返された文字列または`IVsSolution::GetProjrefOfItem``::GetProjrefOfProject`適切な形式) です。

ドロップ (またはクリップボード貼り付け) 操作のターゲットとして、ドラッグ`CF_VSREFPROJECTITEMS``CF_VSSTGPROJECTITEMS`アンド ドロップ操作の正確な処理は、ターゲット プロジェクトとソース プロジェクトの性質によって異なりますが、プロジェクトは両方を受け入れる必要があります。 ソース プロジェクトは、提供するか、`CF_VSREFPROJECTITEMS`または によってその`CF_VSSTGPROJECTITEMS`性質を宣言します。 ドロップのターゲットは、それ自身の性質を理解し、したがって、移動、コピー、またはリンクを実行する必要があるかどうかを決定するのに十分な情報を持っています。 また、Ctrl キー、Shift キー、または Ctrl キーと Shift キーの両方を押して、どのドラッグ アンド ドロップ操作を実行するかを変更します。 ドロップターゲットは、その`DragEnter``DragOver`操作とその方法で事前に実行される操作を適切に示すために重要です。 **ソリューション エクスプローラー**は、ソース プロジェクトとターゲット プロジェクトが同じプロジェクトであるかどうかが自動的に認識されます。

Visual Studio のインスタンス間でプロジェクト項目をドラッグする (たとえば、devenv.exe のインスタンス間) は、特にサポートされていません。 **ソリューション エクスプローラ**でも、この機能は直接無効になります。

ユーザーは、ドラッグ アンド ドロップ操作の効果を常に判断できる必要があります。

| マウス ポインター | command | 説明 |
| :---: | --- | --- |
| ![マウスの [ドロップしない] アイコン](../../extensibility/ux-guidelines/media/0706-01_mousenodrop.png "0706-01_MouseNoDrop") | ドロップなし | 指定した場所にアイテムをドロップできません。 |
| ![マウスの [コピー] アイコン](../../extensibility/ux-guidelines/media/0706-02_mousecopy.png "0706-02_MouseCopy") | コピー | 項目はターゲットの場所にコピーされます。 |
| ![マウスの [移動] アイコン](../../extensibility/ux-guidelines/media/0706-03_mousemove.png "0706-03_MouseMove") | [詳細ビュー] | 項目はターゲットの場所に移動されます。 |
| ![マウスの [参照の追加] アイコン](../../extensibility/ux-guidelines/media/0706-04_mouseaddref.png "0706-04_MouseAddRef") | 参照の追加 | 選択した項目への参照がターゲットの場所に追加されます。 |

#### <a name="reference-based-projects"></a>参照ベースのプロジェクト
 次の表は、ソース項目の性質と、参照ベースのターゲット プロジェクトで押された修飾子キーに基づいて実行する必要があるドラッグ アンド ドロップ操作 (および切り取り/コピー/貼り付け) を示しています。

| 修飾子 | カテゴリ | ソース項目: 参照/リンク | ソース項目: 物理アイテムまたはファイル`CF_HDROP`システム ( ) |
| --- | --- | --- | --- |
| 修飾子なし | アクション | [詳細ビュー] | Link |
| 修飾子なし | 移行先 | 元のアイテムへの参照を追加します。 | 元のアイテムへの参照を追加します。 |
| 修飾子なし | source | 元のアイテムへの参照を削除します | 元のアイテムを保持します |
| 修飾子なし | 結果 | `DROPEFFECT_MOVE`はアクションとして返`::Drop`され、アイテムはストレージ内の元の場所に残ります | `DROPEFFECT_LINK`はアクションとして返`::Drop`され、アイテムはストレージ内の元の場所に残ります |
| Shift キーを押しながらドラッグ | アクション | [詳細ビュー] | ドロップなし |
| Shift キーを押しながらドラッグ | 移行先 | 元のアイテムへの参照を追加します。 | ドロップなし |
| Shift キーを押しながらドラッグ | source | 元のアイテムへの参照を削除します | ドロップなし |
| Shift キーを押しながらドラッグ | 結果 | `DROPEFFECT_MOVE`はアクションとして返`::Drop`され、アイテムはストレージ内の元の場所に残ります | ドロップなし |
| Ctrl キーを押しながらドラッグ | アクション | コピー | ドロップなし |
| Ctrl キーを押しながらドラッグ | 移行先 | 元のアイテムへの参照を追加します。 | ドロップなし |
| Ctrl キーを押しながらドラッグ | source | 元のアイテムへの参照を保持します | ドロップなし |
| Ctrl キーを押しながらドラッグ | 結果 | `DROPEFFECT_COPY`はアクションとして返`::Drop`され、アイテムはストレージ内の元の場所に残ります | ドロップなし |
| Ctrl キーを押しながら Shift キーを押しながらドラッグする | アクション | Link | Link |
| Ctrl キーを押しながら Shift キーを押しながらドラッグする | 移行先 | 元のアイテムへの参照を追加します。 | 元のアイテムへの参照を追加します。 |
| Ctrl キーを押しながら Shift キーを押しながらドラッグする | source | 元のアイテムへの参照を保持します | 元のアイテムを保持します |
| Ctrl キーを押しながら Shift キーを押しながらドラッグする | 結果 | `DROPEFFECT_LINK`はアクションとして返`::Drop`され、アイテムはストレージ内の元の場所に残ります | `DROPEFFECT_LINK`はアクションとして返`::Drop`され、アイテムはストレージ内の元の場所に残ります |
| Ctrl キーを押しながら Shift キーを押しながらドラッグする | Note | Windows エクスプローラでのショートカットのドラッグ アンド ドロップ動作と同じです。 ||
| 切り取り/貼り付け | アクション | [詳細ビュー] | Link |
| 切り取り/貼り付け | 移行先 | 元のアイテムへの参照を追加します。 | 元のアイテムへの参照を追加します。 |
| 切り取り/貼り付け | source | 元のアイテムへの参照を保持します|元のアイテムを保持します |
| 切り取り/貼り付け | 結果 | アイテムはストレージ内の元の場所に残ります | アイテムはストレージ内の元の場所に残ります |
| コピー/貼り付け | アクション | コピー | Link |
| コピー/貼り付け | source | 元のアイテムへの参照を追加します。 | 元のアイテムへの参照を追加します。 |
| コピー/貼り付け | 結果 | 元のアイテムへの参照を保持します | 元のアイテムを保持します |
| コピー/貼り付け | アクション | アイテムはストレージ内の元の場所に残ります | アイテムはストレージ内の元の場所に残ります |

#### <a name="directory-based-projects"></a>ディレクトリベースのプロジェクト
次の表は、ソース項目の性質と、ディレクトリベースのターゲット プロジェクトに対して押された修飾子キーに基づいて実行する必要があるドラッグ アンド ドロップ (および切り取り/コピー/貼り付け) 操作をまとめたものです。

| 修飾子 | カテゴリ | ソース項目: 参照/リンク | ソース項目: 物理アイテムまたはファイル`CF_HDROP`システム ( ) |
|-----------------|----------| - | - |
| 修飾子なし | アクション | [詳細ビュー] | [詳細ビュー] |
| 修飾子なし | 移行先 | アイテムをターゲットの場所にコピーします | アイテムをターゲットの場所にコピーします |
| 修飾子なし | source | 元のアイテムへの参照を削除します | 元のアイテムへの参照を削除します |
| Shift キーを押しながらドラッグ | アクション | [詳細ビュー] | [詳細ビュー] |
| Shift キーを押しながらドラッグ | 移行先 | アイテムをターゲットの場所にコピーします | アイテムをターゲットの場所にコピーします |
| Shift キーを押しながらドラッグ | source | 元のアイテムへの参照を削除します | 元の場所からアイテムを削除します |
| Shift キーを押しながらドラッグ | 結果 | `DROPEFFECT_MOVE`はアクションとして返`::Drop`され、アイテムはストレージ内の元の場所に残ります | `DROPEFFECT_MOVE`はアクションとして返`::Drop`され、アイテムはストレージ内の元の場所に残ります |
| Ctrl キーを押しながらドラッグ | アクション | コピー | コピー |
| Ctrl キーを押しながらドラッグ | 移行先 | アイテムをターゲットの場所にコピーします | アイテムをターゲットの場所にコピーします |
| Ctrl キーを押しながらドラッグ | source | 元のアイテムへの参照を保持します | 元のアイテムへの参照を保持します |
| Ctrl キーを押しながらドラッグ | 結果 | `DROPEFFECT_COPY`はアクションとして返`::Drop`され、アイテムはストレージ内の元の場所に残ります | `DROPEFFECT_COPY`はアクションとして返`::Drop`され、アイテムはストレージ内の元の場所に残ります |
| Ctrl キーを押しながら Shift キーを押しながらドラッグする | | ドロップなし | ドロップなし |
| 切り取り/貼り付け | アクション | [詳細ビュー] | [詳細ビュー] |
| 切り取り/貼り付け | 移行先 | アイテムをターゲットの場所にコピーします | アイテムをターゲットの場所にコピーします |
| 切り取り/貼り付け | source | 元のアイテムへの参照を削除します | 元の場所からアイテムを削除します |
| 切り取り/貼り付け | 結果 | アイテムはストレージ内の元の場所に残ります | アイテムがストレージ内の元の場所から削除されます。 |
| コピー/貼り付け | アクション | コピー | コピー |
| コピー/貼り付け | 移行先 | 元のアイテムへの参照を追加します。 | アイテムをターゲットの場所にコピーします |
| コピー/貼り付け | source | 元のアイテムを保持します | 元のアイテムを保持します |
| コピー/貼り付け | 結果 | アイテムはストレージ内の元の場所に残ります | アイテムは元の場所の ins ストレージに残ります |

#### <a name="mixed-target-projects"></a>混合ターゲット プロジェクト
次の表は、ソース項目の性質と、混合ターゲット プロジェクトで押された修飾子キーに基づいて実行するドラッグ アンド ドロップ操作 (および切り取り/コピー/貼り付け) を示しています。

| 修飾子 | カテゴリ | ソース項目: 参照/リンク | ソース項目: 物理アイテムまたはファイル`CF_HDROP`システム ( ) |
| --- | --- | --- | --- |
| 修飾子なし | アクション | [詳細ビュー] | [詳細ビュー] |
| 修飾子なし | 移行先 | 元のアイテムへの参照を追加します。 | アイテムをターゲットの場所にコピーします |
| 修飾子なし | source | 元のアイテムへの参照を削除します | 元のアイテムへの参照を削除します |
| 修飾子なし | 結果 | `DROPEFFECT_ MOVE`はアクションとして返`::Drop`され、アイテムはストレージ内の元の場所に残ります | `DROPEFFECT_ MOVE`はアクションとして返`::Drop`され、アイテムはストレージ内の元の場所から削除されます |
| Shift キーを押しながらドラッグ | アクション | [詳細ビュー] | [詳細ビュー] |
| Shift キーを押しながらドラッグ | 移行先 | 元のアイテムへの参照を追加します。 | アイテムをターゲットの場所にコピーします |
| Shift キーを押しながらドラッグ | source | 元のアイテムへの参照を削除します | 元の場所からアイテムを削除します |
| Shift キーを押しながらドラッグ | 結果 | `DROPEFFECT_ MOVE`はアクションとして返`::Drop`され、アイテムはストレージ内の元の場所に残ります | `DROPEFFECT_ MOVE`はアクションとして返`::Drop`され、アイテムはストレージ内の元の場所から削除されます |
| Ctrl キーを押しながらドラッグ | アクション | コピー | コピー |
| Ctrl キーを押しながらドラッグ | 移行先 | 元のアイテムへの参照を追加します。 | アイテムをターゲットの場所にコピーします |
| Ctrl キーを押しながらドラッグ | source | 元のアイテムへの参照を保持します | 元のアイテムを保持します |
| Ctrl キーを押しながらドラッグ | 結果 | `DROPEFFECT_ COPY`はアクションとして返`::Drop`され、アイテムはストレージ内の元の場所に残ります | `DROPEFFECT_ COPY`はアクションとして返`::Drop`され、アイテムはストレージ内の元の場所に残ります |
| Ctrl キーを押しながら Shift キーを押しながらドラッグする | アクション | Link | Link |
| Ctrl キーを押しながら Shift キーを押しながらドラッグする | 移行先 | 元のアイテムへの参照を追加します。 | 元のソース項目への参照を追加します。 |
| Ctrl キーを押しながら Shift キーを押しながらドラッグする | source | 元のアイテムへの参照を保持します | 元のアイテムを保持します |
| Ctrl キーを押しながら Shift キーを押しながらドラッグする | 結果 | `DROPEFFECT_ LINK`はアクションとして返`::Drop`され、アイテムはストレージ内の元の場所に残ります | `DROPEFFECT_ LINK`はアクションとして返`::Drop`され、アイテムはストレージ内の元の場所に残ります |
| 切り取り/貼り付け | アクション | [詳細ビュー] | [詳細ビュー] |
| 切り取り/貼り付け | 移行先 | アイテムをターゲットの場所にコピーします | アイテムをターゲットの場所にコピーします |
| 切り取り/貼り付け | source | 元のアイテムへの参照を削除します | 元の場所からアイテムを削除します |
| 切り取り/貼り付け | 結果 | アイテムはストレージ内の元の場所に残ります | アイテムがストレージ内の元の場所から削除されます。 |
| コピー/貼り付け | アクション | コピー | コピー |
| コピー/貼り付け | 移行先 | 元のアイテムへの参照を追加します。 | アイテムをターゲットの場所にコピーします |
| コピー/貼り付け | source | 元のアイテムを保持します | 元のアイテムを保持します |
| コピー/貼り付け | 結果 | アイテムはストレージ内の元の場所に残ります | アイテムはストレージ内の元の場所に残ります |

これらの詳細は、**ソリューション エクスプローラ**でドラッグを実装する際に考慮する必要があります。

- 複数選択シナリオを設計します。

- ファイル名 (完全パス) は、ターゲット プロジェクト全体で一意である必要があります。

- フォルダー名は、ドロップされるレベルで一意 (大文字と小文字を区別しない) 必要があります。

- ドラッグ時に開いているファイルと閉じているファイルの動作の違いがあります (上記のシナリオでは説明していません)。

- 最上位レベルのファイルの動作は、フォルダ内のファイルとは少し異なります。

もう 1 つの問題は、開いているデザイナーまたはエディターを持つアイテムの移動操作を処理する方法です。 想定される動作は次のとおりです (これはすべてのプロジェクトの種類に適用されます)。

1. 開いているエディター/デザイナーに未保存の変更がない場合は、エディター/デザイナー ウィンドウを自動的に閉じる必要があります。

2. 開いているエディター/デザイナーに未保存の変更がある場合、ドラッグのソースはドロップが発生するのを待ってから、次のようなプロンプトでウィンドウを閉じる前に、開いているドキュメントにコミットされていない変更を保存するようにユーザーに要求する必要があります。

    ```
    ==========================================================
         One or more open documents have unsaved changes.
    Do you want to save uncommitted changes before proceeding?
                      [Yes]  [No]  [Cancel]
    ==========================================================
    ```

これにより、ターゲットがコピーを作成する前に、進行中の作業を保存できます。 この処理を`IVsHierarchyDropDataSource2::OnBeforeDropNotify`有効にする新しいメソッドが追加されました。

その後、ターゲットは、アイテムがストレージ内にある状態をコピーします (ユーザーが **[いいえ**] を選択した場合、エディタに未保存の変更は含まれません)。 ターゲットのコピーが完了したら (で`IVsHierarchyDropDataSource::Drop`)、移動操作の削除部分を (で)、ソースに完了する機会が`IVsHierarchyDropDataSource::OnDropNotify`与えられます。

変更が保存されていない編集者は、開いたままにする必要があります。 変更が保存されていないドキュメントの場合、これは移動操作のコピー部分が実行されますが、削除部分は中止されることを意味します。 ユーザーが **[いいえ**] を選択した場合、複数選択のシナリオでは、未保存の変更を含むドキュメントは閉じたり削除したりしないでください。