---
title: "Visual Studio のアプリケーション パターン |Microsoft ドキュメント"
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology:
- vs-ide-sdk
ms.tgt_pltfrm: 
ms.topic: article
ms.assetid: 8ed68602-4e28-46fe-b39f-f41979b308a2
caps.latest.revision: 7
ms.author: gregvanl
manager: ghogen
translation.priority.mt:
- cs-cz
- de-de
- es-es
- fr-fr
- it-it
- ja-jp
- ko-kr
- pl-pl
- pt-br
- ru-ru
- tr-tr
- zh-cn
- zh-tw
translationtype: Machine Translation
ms.sourcegitcommit: 5db97d19b1b823388a465bba15d057b30ff0b3ce
ms.openlocfilehash: 83b586273dcc60f56ad81fd451adce7860df4033
ms.lasthandoff: 02/22/2017

---
# <a name="application-patterns-for-visual-studio"></a>Visual Studio のアプリケーション パターン
##  <a name="a-namebkmkwindowinteractionsa-window-interactions"></a><a name="BKMK_WindowInteractions"></a>ウィンドウの相互作用  
  
### <a name="overview"></a>概要  
 Visual Studio で使用される&2; つのメイン ウィンドウの種類は、ツール ウィンドウとドキュメントのエディターを示します。 まれですが、可能な大規模なモードレス ダイアログ ボックスです。 これらはすべて、シェルでモードレスが、そのパターンは根本的に異なるです。 このトピックでは、ドキュメント、ツール ウィンドウとモードレスのダイアログ ボックスの違いについて説明します。 モーダル ダイアログ パターンは、「[ダイアログ](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Dialogs)します。  
  
### <a name="comparing-window-usage-patterns"></a>ウィンドウの使用状況パターンの比較  
 **ドキュメント ウィンドウ**ほとんど常に内に表示される、ドキュメントもします。 これにより、ドキュメントの編集者"center ステージ"に関する補足的なツール ウィンドウを整列させます。  
  
 A**ツール ウィンドウ**– を表示または非表示、自動非表示することが、小規模な独立したウィンドウは、IDE の端に対する折りたたまれて、最も多く表示されます。 ただし、場合によって示されているでは、ドキュメント内でチェック ボックスをオフ、**ウィンドウとドッキング**ウィンドウのプロパティです。 これは、結果、多くのスペースが、一般的な設計の決定も: Visual Studio に統合しようとすると、ツール ウィンドウまたはドキュメント ウィンドウの機能を表示する必要があるかどうかを決定する必要があります。  
  
 **モードレス ダイアログ**は Visual Studio のことをお勧めします。 多くの場合は – 定義 – 浮動ツール ウィンドウとそのために実装する必要があります。 モードレス ダイアログ ボックスは、ここで、シェルの側にドッキングされている標準のツール ウィンドウのサイズが小さすぎる場合で許可されます。 ユーザーがダイアログ ボックスをセカンダリのモニターに移動する可能性が高いでしょうの場合も許可します。  
  
 慎重にどのコンテナーの種類に関するする必要があると考えてください。 UI 設計のため、共通の使用状況パターンに関する考慮事項は、次の表にされます。  
  
||ドキュメント ウィンドウ|ツール ウィンドウ|モードレス ダイアログ|  
|-|---------------------|-----------------|---------------------|  
|**位置**|常にも、ドキュメント内に位置し、IDE の端にドッキングしません。 これは、ことができます」から取り出す"メイン シェルから個別にフローティングするようです。|IDE の端に一般的にタブ ドッキングが、配置するカスタマイズされた、自動非表示 (固定) でもかまいませんも、ドキュメント内でドッキングします。|IDE から独立した大規模なフローティング ウィンドウです。|  
|**モデルをコミットします。**|*遅延コミット*<br /><br /> ドキュメント内のデータを保存するために、ユーザーは、ファイルを保存、名前を付けて保存またはすべてを保存コマンドを実行する必要があります。 ドキュメント ウィンドウは、保存のいずれかにコミットし、「変更」自体にデータの概念を持つコマンドです。 ドキュメント ウィンドウを閉じるときにすべての内容はディスクに保存するか失われます。|*即時コミット*<br /><br /> 保存されていないモデルです。 ファイルを編集するを支援するツール ウィンドウのインスペクター、ファイルは、アクティブなエディターまたはデザイナーで開く必要があり、エディターまたはデザイナーは、保存先を所有します。|*遅延または即時実行のコミット*<br /><br /> ほとんどの場合、大規模なモードレス ダイアログでは、変更をコミットするアクションが必要ですし、ダイアログ セッション内で加えられた変更がロールバック「キャンセル」操作では、します。  これにより、ツール ウィンドウは、直ちにコミット モデルを常にある点で、ツール ウィンドウからモードレス ダイアログが区別されます。|  
|**可視性**|*開く/作成 (ファイル) と閉じる*<br /><br /> ドキュメント ウィンドウを開くと、既存のドキュメントを開くか、新しいドキュメントを作成するテンプレートを使用してを通して行われます。 ありません"開いている\<特定のエディター >"コマンドです。|*非表示にして表示します。*<br /><br /> 単一インスタンスのツール ウィンドウを非表示または表示します。 ビュー内かどうかの内容とツール ウィンドウ内の状態を永続化または非表示です。 マルチ インスタンスのツール ウィンドウでく閉じただけでなく非表示にします。 複数インスタンスのツール ウィンドウが閉じている場合は、ツール ウィンドウ内の状態と内容は破棄されます。|*コマンドからの起動*<br /><br /> タスク ベースのコマンドからは、ダイアログ ボックスが起動されます。|  
|**インスタンス**|*複数インスタンス*<br /><br /> 一部のエディターでは、同じファイルを&1; つ以上のエディターで開いていることも許可できる、いくつかのエディターが同時に、別のファイルを編集で開くことができる (を使用して、**ウィンドウ > 新しいウィンドウ**コマンド)。<br /><br /> 単一のエディターが同時に (プロジェクト デザイナー)&1; つまたは複数のファイルを編集することがあります。|*1 つまたは複数 instance*<br /><br /> 内容は変更 (プロパティ ブラウザー) と同じコンテキストを使用するか、フォーカス/コンテキストを他のウィンドウ (タスク リスト、ソリューション エクスプ ローラー) にプッシュします。<br /><br /> 存在がない限り、特別な理由に、単一インスタンスと複数インスタンスの両方のツール ウィンドウがアクティブなドキュメント ウィンドウを関連付ける必要があります。|*単一インスタンス*|  
|**例**|**テキスト エディター**、コード エディターなど<br /><br /> **デザイン サーフェイス**、フォーム デザイナーなどのモデル化画面<br /><br /> **ダイアログ ボックスのようなレイアウトを制御**、マニフェスト デザイナーなど|**ソリューション エクスプ ローラー**ソリューションが提供され、ソリューション内に含まれるプロジェクト<br /><br /> **サーバー エクスプ ローラー**を開くには、ウィンドウにユーザーが選択したサーバーとデータの接続の階層ビューを提供します。 クエリなど、データベース階層からオブジェクトを開くドキュメント ウィンドウが開き、クエリを編集することができます。<br /><br /> **プロパティ ブラウザー**ドキュメント ウィンドウまたは別のツール ウィンドウのいずれかを選択したオブジェクトのプロパティを表示します。 プロパティは、階層のグリッド ビューまたは複雑なダイアログのようなコントロールのいずれかが表示され、ユーザーがこれらのプロパティの値を設定できるようにします。||  
  
##  <a name="a-namebkmktoolwindowsa-tool-windows"></a><a name="BKMK_ToolWindows"></a>ツール ウィンドウ  
  
### <a name="overview"></a>概要  
 ツール ウィンドウは、ドキュメント ウィンドウに行われたユーザーの作業をサポートします。 Visual Studio は、操作する基本的なルート オブジェクトを表す階層を表示に使用できます。  
  
 使用する場合、IDE の新しいツール ウィンドウ、著者を行ってください。  
  
-   既存のツール ウィンドウのタスクに適したを使用し、同様の機能で新しいポリシーを作成できません。 新しいツール ウィンドウは、大幅に異なる「ツール」または機能のようなウィンドウ オンにしたり既存のウィンドウ ピボット ハブに統合することできませんが提供されている場合にのみ作成する必要があります。  
  
-   必要に応じて、ツール ウィンドウの上部にある場合は、標準のコマンド バーを使用します。  
  
-   コントロールのプレゼンテーションとキーボードのナビゲーションの他のツール ウィンドウに既に存在パターンと一致します。  
  
-   他のツール ウィンドウでコントロールのプレゼンテーションと一致します。  
  
-   ドキュメントに固有のツール ウィンドウ表示するか自動-可能な場合は親ドキュメントをアクティブにするタイミングにのみ表示されるようにします。  
  
-   そのウィンドウの内容がキーボード (矢印キーをサポートする) を使用してナビゲート可能なことを確認します。  
  
#### <a name="tool-window-states"></a>ツール ウィンドウの状態  
 Visual Studio のツール ウィンドウには、(自動的に隠す機能) のようなユーザーでアクティブ化されるこれらの一部は別の状態があります。 など、他の状態自動的に表示されている、現在のコンテキストで表示され、必要ない場合に非表示にするツール ウィンドウを許可します。 合計で&5; つのツール ウィンドウの状態があります。  
  
-   **ドッキングされている固定**ドキュメント領域の&4; つの辺にツール ウィンドウを関連付けることができます。 プッシュピン アイコンは、ツール ウィンドウのタイトル バーに表示されます。 ツール ウィンドウは、シェルと他のツール ウィンドウの端に沿って水平または垂直方向にドッキングでき、タブでリンクされたことができます。  
  
-   **自動非**ツール ウィンドウは固定されています。 ウィンドウは見えないのタブ (ツール ウィンドウの名前とアイコン) をオンのままドキュメント領域のエッジにスライドできます。 ツール ウィンドウがスライドして現れ、タブ上に置いたときにします。  
  
-   **自動的に表示されている**ツール ウィンドウは、UI のエディターなどの別の部分が起動するかフォーカスを取得するときに自動的に表示されます。  
  
-   **浮動小数点**IDE の外部のツール ウィンドウを移動します。 これは、マルチ モニターの構成に役立ちます。  
  
-   **タブ付きドキュメント**ツール ウィンドウをドキュメント内でもドッキングすることができます。 これは、フレームの端にドッキングよりも多くのスペースを必要なオブジェクト ブラウザーなどの大規模なツール ウィンドウに便利です。  
  
 ![ツール ウィンドウの状態を Visual Studio で](../../extensibility/ux-guidelines/media/0702-01_toolwindowstates.png "0702&01;_ToolWindowStates")  
  
 **Visual Studio でツール ウィンドウの状態**  
  
#### <a name="single-instance-and-multi-instance"></a>単一インスタンスと複数インスタンス  
 ツール ウィンドウは、単一インスタンスまたは複数のインスタンスです。 一部の単一インスタンスのツール ウィンドウは、マルチ インスタンスのツール ウィンドウがない場合があります、作業中のドキュメント ウィンドウに関連付けられたあります。 マルチ インスタンスのツール ウィンドウは、ウィンドウの新しいインスタンスを作成するウィンドウ]、[新しいウィンドウのコマンドに応答します。 次の図は、ウィンドウのインスタンスがアクティブな場合、新しいウィンドウのコマンドを有効にするツール ウィンドウを示しています。  
  
 ![Visual Studio のコマンドを有効にするツール ウィンドウ](../../extensibility/ux-guidelines/media/0702-02_toolwindowenablingcommand.png "0702&02;_ToolWindowEnablingCommand")  
  
 **ウィンドウのインスタンスがアクティブな場合、新しいウィンドウ コマンドを有効にすると、ツール ウィンドウ**  
  
 単一インスタンスのツール ウィンドウを非表示または表示で表示されて、複数インスタンスのツール ウィンドウでく閉じただけでなく非表示にします。 タブでリンクされた浮動小数点、または (ドキュメント ウィンドウに類似) マルチ ドキュメント インターフェイス (MDI) 子ウィンドウとして設定されて、すべてのツール ウィンドウをドッキングされることができます。 すべてのツール ウィンドウは、[ウィンドウ] メニューで目的のウィンドウ管理コマンドに応答する必要があります。  
  
 ![Visual Studio でのウィンドウ管理コマンド](../../extensibility/ux-guidelines/media/0702-03_windowmanagementcontrols.png "0702&03;_WindowManagementControls")  
  
 **Visual Studio ウィンドウのメニューでのウィンドウ管理コマンド**  
  
#### <a name="document-specific-tool-windows"></a>ドキュメントに固有のツール ウィンドウ  
 ドキュメントの特定の種類に基づいて変更するのには、一部のツール ウィンドウが設計されています。 これらのウィンドウは、継続的に、IDE で作業中のドキュメント ウィンドウに適用可能な機能を反映して更新します。  
  
 ツール ウィンドウの内容が変更を選択されたエディターを反映するには、ツールボックス、ドキュメント アウトラインがあります。 これらのウィンドウは、エディター ウィンドウにコンテキストは不可能なフォーカスがあるときに透かしを表示します。  
  
#### <a name="navigable-list-tool-windows"></a>ナビゲート可能なリスト ツール ウィンドウ  
 一部のツール ウィンドウは、ユーザーが対話ナビゲート可能な項目の一覧を表示します。 この種類のウィンドウでは、常にありますの一覧で、現在の項目のフィードバックをウィンドウがアクティブでない場合でもです。 リストへの応答が、 **GoToNextLocation**と**GoToPrevLocation**も ウィンドウで現在選択されている項目を変更してコマンド  
  
 ナビゲート可能なリスト ツール ウィンドウには、ソリューション エクスプ ローラーと検索結果 ウィンドウがあります。  
  
### <a name="tool-window-types"></a>ツール ウィンドウの種類  
  
#### <a name="common-tool-windows-and-their-functions"></a>一般的なツール ウィンドウとその機能  
  
|型|ツール ウィンドウ|関数|  
|----------|-----------------|--------------|  
|**階層**|ソリューション エクスプローラー|プロジェクト、その他のファイル、およびソリューション項目に含まれているドキュメントの一覧を表示する階層ツリー。 プロジェクト内のアイテムの表示は、プロジェクトの種類 (たとえば、参照に基づく、ディレクトリ ベース、または混在モードの種類) を所有しているパッケージによって定義されます。|  
|**階層**|クラス ビュー|クラスと、ファイル自体の独立したドキュメントのワーキング セット内のさまざまな要素の階層ツリー。|  
|**階層**|サーバー エクスプローラー|ソリューションのすべてのサーバーとデータ接続を表示する階層ツリー。|  
|**階層**|[ドキュメント アウトライン]|アクティブなドキュメントの階層構造です。|  
|**グリッド**|プロパティ|値ピッカーをこれらのプロパティを編集すると、選択したオブジェクトのプロパティの一覧を表示するグリッドです。|  
|**グリッド**|タスク一覧|ユーザーがタスクの作成/編集/削除およびコメント グリッドです。|  
|**コンテンツ**|[Help]|ユーザーの"How Do I"からのヘルプの取得のさまざまな方法へのアクセスを許可する ウィンドウ MSDN フォーラムのビデオです。|  
|**コンテンツ**|ダイナミック ヘルプ|現在の選択範囲に該当するトピックへのリンクを表示するツール ウィンドウ。|  
|**コンテンツ**|オブジェクト ブラウザー|2 つの列フレーム セットを左側のウィンドウとオブジェクトのプロパティの階層化されたオブジェクトのコンポーネントと、右側の列内のメソッドの一覧です。|  
|**ダイアログ**|検索を高度な検索|ユーザーが検索またはにおける検索し、置換、ソリューション内のさまざまなファイルのダイアログ。|  
|**その他**|ツールボックス|ツール ウィンドウは、一貫性のあるドラッグ元を提供するすべてのデザイナーのデザイン サーフェイス上に削除される要素を格納するために使用します。|  
|**その他**|スタート ページ|開発者向けニュース、Visual Studio ヘルプ、および最近使用したプロジェクトのフィードへのアクセス権を持つユーザーのポータル、Visual Studio です。 ユーザーもが作成できるカスタム スタート ページ StartPage.xaml ファイルを Visual Studio の"Common7\IDE\StartPages\"program files ディレクトリから Visual Studio のドキュメント ディレクトリ [startpages] フォルダーをコピーして、XAML を手動で編集または Visual Studio または別のコードで開いて、エディターです。|  
|**デバッガー:**ウィンドウのタスクのデバッグおよびアクティビティの監視に固有のグループ|自動変数||  
|**デバッガー:**ウィンドウのタスクのデバッグおよびアクティビティの監視に固有のグループ|イミディエイト||  
|**デバッガー:**ウィンドウのタスクのデバッグおよびアクティビティの監視に固有のグループ|出力|テキストのイベントや状態を宣言する必要があるたびに、出力ウィンドウを使用できます。|  
|**デバッガー:**ウィンドウのタスクのデバッグおよびアクティビティの監視に固有のグループ|メモリ||  
|**デバッガー:**ウィンドウのタスクのデバッグおよびアクティビティの監視に固有のグループ|ブレークポイント||  
|**デバッガー:**ウィンドウのタスクのデバッグおよびアクティビティの監視に固有のグループ|実行中||  
|**デバッガー:**ウィンドウのタスクのデバッグおよびアクティビティの監視に固有のグループ|ドキュメント||  
|**デバッガー:**ウィンドウのタスクのデバッグおよびアクティビティの監視に固有のグループ|呼び出し履歴||  
|**デバッガー:**ウィンドウのタスクのデバッグおよびアクティビティの監視に固有のグループ|ローカル||  
|**デバッガー:**ウィンドウのタスクのデバッグおよびアクティビティの監視に固有のグループ|ウォッチ||  
|**デバッガー:**ウィンドウのタスクのデバッグおよびアクティビティの監視に固有のグループ|逆アセンブリ||  
|**デバッガー:**ウィンドウのタスクのデバッグおよびアクティビティの監視に固有のグループ|レジスタ||  
|**デバッガー:**ウィンドウのタスクのデバッグおよびアクティビティの監視に固有のグループ|スレッド||  
  
##  <a name="a-namebkmkdocumenteditorconventionsa-document-editor-conventions"></a><a name="BKMK_DocumentEditorConventions"></a>ドキュメントのエディターの表記規則  
  
### <a name="document-interactions"></a>ドキュメントの相互作用  
 "Document ウェル"は、ide の領域が最も大きい、ここで、ユーザー一般的に中心とする、サポートの補足的なツール ウィンドウにより、タスクを完了するために。 文書の編集者は、ユーザーが開き、Visual Studio 内で保存する作業の基本的な単位を表します。 ソリューション エクスプ ローラーまたは他のアクティブな階層ウィンドウに関連付けられている選択範囲の厳密な意味は保持されます。 ユーザーは、これらの階層ウィンドウのいずれかをポイントし、ソリューション、プロジェクト、または Visual Studio パッケージで提供されるもう&1; つのルート オブジェクトのいずれかに、ドキュメントが含まれているとの関係を把握できる必要があります。  
  
 ドキュメントの編集には、一貫したユーザー エクスペリエンスが必要です。 手元の作業の代わりにウィンドウの管理とコマンドの検索に焦点をユーザーには、そのドキュメントの種類を編集するためのユーザーの作業に最適なドキュメント ビューの戦略を選択します。  
  
#### <a name="common-interactions-for-the-document-well"></a>よくのドキュメントの一般的な相互作用  
  
-   共通の一貫した対話モデルの管理**新しいファイル**と**ファイルを開く**で発生します。  
  
-   ドキュメント ウィンドウを開いたときに、関連するウィンドウおよびメニューに関連する機能を更新します。  
  
-   メニュー コマンドはなどの共通のメニューに統合適切に**編集**、**形式**、および**ビュー**メニュー。 大量の専用のコマンドが使用可能な場合は、し、新しいメニュー作成できますフォーカスがある場合のみ、ドキュメントが表示されています。  
  
-   埋め込みツールバーは、エディターの上部に配置できます。 これは、エディターの外側に表示される独立したツールバー方が適切です。  
  
-   ソリューション エクスプ ローラーまたは同様のアクティブな選択範囲を常に保持する [階層] ウィンドウ。  
  
-   ソリューション エクスプ ローラーでドキュメントをダブルクリックすると同じアクションを実行する必要があります**開く**します。  
  
-   場合は&1; つ以上のエディターを使用できるは、ドキュメントの種類で、ユーザーがオーバーライドやを使用して特定のドキュメント型の既定のアクションをリセットする必要があります、**ファイルを開く**ファイルを右クリックしてダイアログ ボックス**ファイルを開く**のショートカット メニュー。  
  
-   ビルドがドキュメント内のウィザードもします。  
  
### <a name="user-expectations-for-specific-document-types"></a>特定のドキュメントの種類のユーザーの期待  
 同じ種類の他のユーザーとの一貫性が相互作用のセットを持つ各し文書の編集者のさまざまな基本的な種類があります。  
  
-   **テキスト ベース エディター:**コード エディター、ログ ファイル  
  
-   **デザイン画面:** WPF フォームのデザイナーは、Windows フォーム  
  
-   **ダイアログ スタイルの編集:**マニフェスト デザイナー、プロジェクトのプロパティ  
  
-   **モデル デザイナー:** 、ワークフロー デザイナー、codemap、アーキテクチャの図の流れ  
  
 ドキュメントを使用してもいくつかの種類の非エディターも。 次のドキュメント ウィンドウの標準的な対話する必要がドキュメント自体を編集しないときにします。  
  
-   **レポート:** IntelliTrace レポート、HYPER-V でのレポート、プロファイラー レポート  
  
-   **ダッシュ ボード:**診断ハブ  
  
#### <a name="text-based-editors"></a>テキスト ベースのエディター  
  
-   ドキュメントは、開くことがなく、ドキュメントをプレビューするためのプレビュー タブ モデルに参加します。  
  
-   ドキュメント アウトラインなどの必携ツール ウィンドウ内では、ドキュメントの構造を表すことができます。  
  
-   IntelliSense (該当する場合) は、他のコード エディターで一貫して動作します。  
  
-   ポップアップや支援の UI は、CodeLens などの既存のような UI のようなスタイルやパターンに従います。  
  
-   ドキュメントの状態に関するメッセージは、ドキュメントの上部にある情報バー コントロールまたはステータス バーに表示されます。  
  
-   ユーザーは、フォントおよび色を使用しての外観をカスタマイズできる必要があります、**ツール > オプション**ページ、共有のフォントおよび色 ページまたはエディターに固有の&1; つのいずれかです。  
  
#### <a name="design-surfaces"></a>デザイン画面  
  
-   空のデザイナーを開始する方法を示す画面で、透かしが必要です。  
  
-   ビューの切り替えのメカニズムをダブルクリックしてコード エディター、または両方のウィンドウとの対話を許可するドキュメント ウィンドウ内のタブなどの既存のパターンに従います。  
  
-   高度に特定のツール ウィンドウが必要でない限り、ツールボックスを使用して、デザイン画面に要素を追加を行ってください。  
  
-   画面上のアイテムには、一貫性のある選択モデルに従います。  
  
-   埋め込みツールバーが含まれているドキュメントに固有のコマンドのみ、共通のコマンドなど**保存**します。  
  
#### <a name="dialog-style-editors"></a>ダイアログ スタイル エディター  
  
-   コントロールのレイアウトは、通常 ダイアログ ボックスのレイアウト規則に従う必要があります。  
  
-   エディター内のタブには、ドキュメントのタブの外観と一致しないように、許可されている内部 タブの&2; つのスタイルのいずれかに一致する必要があります。  
  
-   ユーザーは、キーボードのみを使用するコントロールと対話できる必要があります。標準のニーモニックを使用して、エディターをアクティブ化とコントロール、またはタブ移動するか。  
  
-   デザイナーには、共通モデルの保存を使用する必要があります。 全体の保存またはコミット ボタンが配置されるなし画面で、適切なその他のボタンもあります。  
  
#### <a name="model-designers"></a>モデル デザイナー  
  
-   空のデザイナーを開始する方法を示す画面で、透かしが必要です。  
  
-   デザイン画面に要素の追加は、ツールボックスを使用して行う必要があります。  
  
-   画面上のアイテムには、一貫性のある選択モデルに従います。  
  
-   埋め込みツールバーが含まれているドキュメントに固有のコマンドのみ、共通のコマンドなど**保存**します。  
  
-   凡例の指示またはウォーターマークの表面に表示されます。  
  
-   ユーザーを使用するフォントと色の外観をカスタマイズできる必要があります、**ツール > オプション**ページ、共有のフォントおよび色 ページまたはエディターに固有の&1; つのいずれかです。  
  
#### <a name="reports"></a>レポート  
  
-   レポートは通常情報専用であり、保存モデルに属していません。 ただし、他の関連する情報または展開したり折りたたんだりするセクションへのリンクなどの操作が含まれる場合します。  
  
-   サーフェイス上のほとんどのコマンドは、ハイパーリンク、ボタンではないはずです。  
  
-   レイアウトは、ヘッダーが含まれます、標準のレポート レイアウトのガイドラインに従う必要があります。  
  
#### <a name="dashboards"></a>ダッシュボード  
  
-   ダッシュ ボード必要はありません対話モデル自体がさまざまなその他のツールを提供するための手段として機能します。  
  
-   モデルに参加しません。  
  
-   ユーザーは、エディターをアクティブ化して、コントロール間をタブ移動するか、標準のニーモニックを使用して、キーボードのみを使用するコントロールと対話できる必要があります。  
  
##  <a name="a-namebkmkdialogsa-dialogs"></a><a name="BKMK_Dialogs"></a>ダイアログ ボックス  
  
### <a name="introduction"></a>はじめに  
 Visual Studio でのダイアログ ボックスでは、通常&1; つの個々 のユーザーの作業単位をサポートする必要があり、消去し、します。  
  
 ダイアログ ボックスが必要があることを判断した場合は、優先順位で&3; つの選択肢があります。  
  
1.  Visual Studio での共有のダイアログ ボックスのいずれかの機能を統合します。  
  
2.  既存のようなダイアログで検出されたパターンを使用して、独自のダイアログを作成します。  
  
3.  新しいダイアログ ボックス、次の操作とレイアウトのガイドラインを作成します。  
  
 このトピックでは、Visual Studio ワークフロー内で適切なダイアログ パターンと、ダイアログ デザインの一般的な規則を選択する方法について説明します。  
  
### <a name="themes"></a>テーマ  
 Visual Studio でのダイアログ ボックスでは、2 つの基本的なスタイルのいずれかに従います。  
  
#### <a name="standard-unthemed"></a>標準 (unthemed)  
 ダイアログ ボックスの大半は、標準ユーティリティのダイアログ ボックスし、unthemed をする必要があります。 定型の「最新の」ボタンやコントロールを作成しようとしたり re テンプレート一般的なコントロールではなくをしないでください。 コントロールとに従って chrome 外観[ダイアログ ボックスの標準の Windows デスクトップの対話のガイドライン](https://msdn.microsoft.com/en-us/library/windows/desktop/dn742499\(v=vs.85\).aspx)します。  
  
#### <a name="themed"></a>テーマが適用されました。  
 「署名」ダイアログ ボックスの専門分野は、テーマが適用された可能性があります。 テーマが適用されたダイアログ ボックスでは、スタイルに関連付けられているいくつか特別な相互作用のパターンを持つ独自の外観があります。 テーマこれらの要件を満たしている場合にのみ、ダイアログ。  
  
-   ダイアログ ボックスが表示され、多くの場合、または多数のユーザーを使用する共通のエクスペリエンスは、(たとえば、**新しいプロジェクト**ダイアログ。  
  
-   ダイアログ ボックスには、著名な製品ブランド要素が含まれています (たとえば、**アカウントの設定**ダイアログ)。  
  
-   その他のテーマが適用されたダイアログ ボックスを含むより大きなフローの一環として、ダイアログ ボックスが表示されます (たとえば、 **接続済みサービス**ダイアログ)。  
  
-   ダイアログ ボックスは、重要な部分、環境に昇格または製品バージョンを区別することで戦略的な役割を果たしているのです。  
  
 テーマが適用されたダイアログを作成するときに、適切な環境の色を使用し、正しいレイアウトと相互作用のパターンに従います。 (参照[Visual Studio のレイアウト](../../extensibility/ux-guidelines/layout-for-visual-studio.md))  
  
### <a name="dialog-design"></a>ダイアログ デザイン  
 適切に設計されたダイアログ ボックスでは、次の要素を考慮します。  
  
-   サポートされているユーザーのタスク  
  
-   ダイアログのテキストのスタイル、言語、および関連用語  
  
-   コントロールの選択および UI の表記規則  
  
-   視覚的なレイアウトの仕様とコントロールの配置  
  
-   キーボード アクセス  
  
#### <a name="content-organization"></a>組織のコンテンツ  
 ダイアログの基本的な型の間で相違点を考慮してください。  
  
-   [単純なダイアログ](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_SimpleDialogs)1 つのモーダル ウィンドウ内のコントロールを表示します。 プレゼンテーションには、フィールドの選択、アイコン バーなどの複雑なコントロール パターンのバリエーションが含まれます。  
  
-   [ダイアログ ボックスを階層化](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_LayeredDialogs)UI の&1; つは、コントロールの複数のグループを構成するときに、実際の画面を最大限に活用するために使用します。 ダイアログ ボックスのグループ化「に配置されます」タブ コントロール、ナビゲーションのリスト コントロール、またはボタンをユーザーがグループ化して、特定の時点を選択できるようにします。  
  
-   [ウィザード](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Wizards)は、タスクの完了までの手順の論理シーケンス全体のユーザーをリダイレクトするために役立ちます。 前のパネルで行った選択に依存してさまざまなワークフロー (「分岐」) の場合もあります概要シーケンシャルのパネルで、一連の選択肢が提供されます。  
  
####  <a name="a-namebkmksimpledialogsa-simple-dialogs"></a><a name="BKMK_SimpleDialogs"></a>単純なダイアログ ボックス  
 シンプルなダイアログ ボックスは、1 つのモーダル ウィンドウ内のコントロールのプレゼンテーションです。 このプレゼンテーションには、フィールドの選択などの複雑なコントロール パターンのバリエーションが含まれます。 単純なダイアログは、標準の一般的なレイアウトだけでなく複雑なコントロールのグループ化に必要な特定のレイアウトに参照してください。  
  
 ![Visual Studio での単純なダイアログ](../../extensibility/ux-guidelines/media/0704-01_createstrongnamekey.png "0704&01;_CreateStrongNameKey")  
  
 **作成する厳密な名前キーは、Visual Studio でのシンプルなダイアログ ボックスの例を示します。**  
  
####  <a name="a-namebkmklayereddialogsa-layered-dialogs"></a><a name="BKMK_LayeredDialogs"></a>階層化ダイアログ  
 複数層のダイアログ ボックスには、タブ、ダッシュ ボード、および埋め込みのツリーが含まれます。 1 つの UI で提供されているコントロールの複数のグループがある場合は、不動産を最大化に使用されます。 ユーザーが同時に表示するグループ化を選択できるように構成されるグループに配置されます。  
  
 最も簡単な例では、グループ化を切り替えるためのメカニズムは、タブ コントロールです。 使用可能ないくつかの選択肢ができます。 優先順位を指定し、最も適切なスタイルを選択する方法の配置を参照してください。  
  
 **ツール > オプション**ダイアログが埋め込みツリーを使用して階層ダイアログの例を示します。  
  
 ![Visual Studio での階層ダイアログ](../../extensibility/ux-guidelines/media/0704-02_toolsoptions.png "0704&02;_ToolsOptions")  
  
 **ツール > オプションは、Visual Studio での階層ダイアログの例を示します。**  
  
####  <a name="a-namebkmkwizardsa-wizards"></a><a name="BKMK_Wizards"></a>ウィザード  
 ウィザードは、タスクの完了手順の論理シーケンス全体のユーザーをリダイレクトするために役立ちます。 シーケンシャルなパネルは、一連の選択肢が提供され、ユーザーは、次に進む前に、各ステップを続行する必要があります。 十分な既定値が利用できるよう、**完了**ボタンが有効にします。  
  
 タスクのモーダルのウィザードを使用します。  
  
-   分岐、ユーザーの選択に応じて異なるパスを提供する場所を含む  
  
-   その後の手順が上記のステップからの入力をユーザーに依存する場合、手順間の依存関係を含む  
  
-   十分に複雑にあるオプションと各ステップで返される結果を説明する UI を使用すること  
  
-   トランザクションでは、一連の変更がコミットされるまでそのままの状態で完了する手順を必要とするには  
  
### <a name="common-conventions"></a>一般的な規則  
 最適な設計とをダイアログ ボックスを使用して機能を実現するためにダイアログのサイズ、位置、標準、コントロールの構成と配置、UI テキスト、タイトル バー、コントロール ボタン、およびアクセス キーにこれらの規則に従います。  
  
 レイアウトに固有のガイドラインについては、次を参照してください。 [Visual Studio のレイアウト](../../extensibility/ux-guidelines/layout-for-visual-studio.md)します。  
  
#### <a name="size"></a>サイズ  
 ダイアログ ボックスは、最低でも 1024 x 768 の画面解像度に収まるようにし、最初のダイアログのサイズは 700 900 ピクセルを超えることはできません。 ダイアログ ボックスのサイズを変更すると、できることがありますが、必須ではありません。  
  
 サイズ変更可能なダイアログ ボックスの&2; つの推奨事項があります。  
  
1.  最小サイズは、コントロールの最適化は、ダイアログに対して定義されていること、クリッピング、せずに設定し、適切なローカライズの成長に対応する調整します。  
  
2.  あるユーザー スケール サイズはセッションごとに永続化します。 などの場合は、ユーザーは、150% ダイアログを拡張、ダイアログ ボックスのそれ以降の起動が 150% で表示されます。  
  
#### <a name="position"></a>位置  
 ダイアログ ボックスには、最初の起動時に、IDE 内で中央揃えに表示されます。 ダイアログのサイズを変更できない場合はそれ以降の起動時の中央に表示されますので、ダイアログ ボックスの最後の位置を保持することが必要です。 をダイアログのサイズ変更可能な場合に、以降の起動時サイズを永続化する必要があります。 サイズ変更可能なダイアログはモーダルで位置が永続化する必要はありません。 IDE 内で中央揃えに表示するには、ユーザーの表示設定が変更されたときに、予期しないまたは使用不能の位置に表示されるダイアログ ボックスの可能性ができなくなります。 移動できるモードレスのダイアログ ボックスのユーザーの位置を維持する以降の起動時に、ダイアログ ボックスは、大規模なワークフローの一環として頻繁に使用する可能性があります。  
  
 ダイアログ ボックスでは、その他のダイアログ ボックスを生成する必要がありますと、最上位のダイアログ必要があります右側に連鎖的におよびが別の場所に移動することをユーザーに明らかになるように、親からのダウンします。  
  
#### <a name="modality"></a>モダリティ  
 モーダルの中では、ユーザーが完了するか続行する前に、ダイアログ ボックスをキャンセルする必要があることを意味します。 モーダル ダイアログ ボックスでは、環境内の他の部分との対話からユーザーをブロック、のでタスク フローの機能の珞・ ェマ限り慎重です。 モーダルの操作が必要な場合は、Visual Studio にはの共有のダイアログ ボックスに、機能を統合することができます。 新しいダイアログ ボックスを作成する必要がある場合は、同様の機能と既存のダイアログ ボックスの相互作用のパターンに従います。  
  
 ユーザーが一度に&2; つのアクティビティを実行する必要がある場合**検索**と**置換**新しいコードを書き込み中に、ダイアログするモードレスようにして、ユーザーはそれらの間に簡単に切り替えることができます。 通常、visual Studio は、この種類のリンクされたタスクのエディターをサポートしているツール ウィンドウを使用します。  
  
#### <a name="control-configuration"></a>コントロールの構成  
 同じことを Visual Studio で既存のコントロールの構成と一致します。  
  
#### <a name="title-bars"></a>タイトル バー  
  
-   タイトル バー内のテキストは、それを起動したコマンドの名前を反映する必要があります。  
  
-   ダイアログのタイトル バーにアイコンを使用しません。 システムが必要と&1; つの場合、Visual Studio ロゴを使用します。  
  
-   ダイアログ ボックスのないを最小化または最大化ボタン。  
  
-   タイトル バーの [ヘルプ] ボタンは廃止されました。 新しいダイアログ ボックスに追加されません。 存在しなければは、概念的には、タスクに関連するヘルプ トピックを起動する必要があります。  
  
 ![タイトル バーは、Visual Studio の仕様](../../extensibility/ux-guidelines/media/0704-03_titlebarspecs.png "0704&03;_TitleBarSpecs")  
  
 **Visual Studio のダイアログ ボックスのタイトル バーの仕様を規定します。**  
  
#### <a name="control-buttons"></a>コントロールのボタン  
 一般に、 **OK**/**キャンセル**/**ヘルプ**ボタンは、ダイアログ ボックスの右下隅の水平方向に整列する必要があります。 ダイアログ コントロールのボタンを持つ visual 混乱であれば、ダイアログの下部にあるその他のいくつかのボタンがある場合、代替の垂直方向の積み重ねが許可されます。  
  
 ![Visual Studio でボタンの構成を制御](../../extensibility/ux-guidelines/media/0704-04_controlbuttonconfig.png "0704&04;_ControlButtonConfig")  
  
 **Visual Studio のダイアログ ボックスのコントロール ボタンの使用可能な構成**  
  
 ダイアログ ボックスでは、既定のコントロール ボタンを含める必要があります。 既定値として使用する最適なコマンドを確認するのには、(優先順位の順に一覧表示)、次のオプションから選択します。  
  
-   既定値として、最も安全かつ最も安全なコマンドを選択します。 これは、データ損失を回避し、意図しないシステムへのアクセスを回避するほとんどのコマンドを選択することを意味します。  
  
-   データの損失やセキュリティ要因がそうでない場合は、利便性に基づく既定のコマンドを選択します。 既定値として最も可能性の高いコマンドを含む場合は、ダイアログ ボックスは、頻度または反復的なタスクをサポートしている場合、ユーザーのワークフローが改善されます。  
  
 既定のコマンドを完全に破壊するアクションを選択しないでください。 このようなコマンドが存在する場合、代わりに、既定値としてより安全なコマンドを選択します。  
  
#### <a name="access-keys"></a>アクセス キー  
 アクセス キーを使用しないでください**OK**/**キャンセル**/**ヘルプ**ボタン。 これらのボタンは、既定では、ショートカット キーにマッピングされます。  
  
|ボタン名|ショートカット キー|  
|-----------------|-----------------------|  
|OK|Enter|  
|キャンセル|Esc|  
|[Help]|F1|  
  
#### <a name="imagery"></a>画像  
 ダイアログ ボックスで画像を多用します。 空き領域を使用するだけでダイアログ ボックスで大きいアイコンを使用できません。 警告アイコンまたは状態アニメーションなどのユーザーにメッセージを伝達の重要な一部である場合にのみ、イメージを使用します。  
  
###  <a name="a-namebkmkprioritizingandlayeringa-prioritizing-and-layering"></a><a name="BKMK_PrioritizingAndLayering"></a>優先順位を付けると、レイヤー化  
  
#### <a name="prioritizing-your-ui"></a>UI の優先順位付け  
 特定の UI 要素を表示しより高度な動作とダイアログ ボックスにオプション (不可解なコマンドを含む) を配置する必要がある場合があります。 領域を確保することでことで、表示されるテキスト ラベル付きの UI に既定では、ダイアログ ボックスが表示されると、forefront に一般的に使用される機能を移動できます。  
  
#### <a name="layering-your-ui"></a>UI を階層化  
 ダイアログが必要なあるが、シンプルなダイアログ ボックスで表示できるそれるので、ユーザーに提示する、関連する機能を判断した場合は、UI を階層化する必要があります。 Visual Studio を使用して、最も一般的な階層化メソッドは、タブ、廊下やダッシュ ボードです。 場合によってを展開したり折りたたんだりできる領域は適切にあります。 アダプティブ UI は、通常は Visual Studio では推奨されません。  
  
 階層化 タブのようなコントロールを使用して UI のさまざまな方法に長所と短所があります。 状況に合わせて適切な階層化手法を選択していることを確認するのには、次の一覧を確認します。  
  
##### <a name="tabbing"></a>Tab キーによる移動  
  
|機能の切り替え|利点と適切な使用方法|短所と不適切な使用方法|  
|-------------------------|------------------------------------|-----------------------------------------|  
|タブ コントロール|関連する設定にダイアログ ページを論理的にグループ化します。<br /><br /> 5 個より少ない (またはダイアログ ボックスで、1 つの行に適合するタブの数) に便利です ダイアログ ボックスの関連するコントロールのページ<br /><br /> タブ ラベルを簡単にする必要がありますコンテンツを簡単に識別できる&1; つまたは&2; つの単語。<br /><br /> システムのコモン ダイアログ スタイル<br /><br /> 例:**エクスプ ローラー > アイテムのプロパティ**|わかりやすい短いラベルの作成は、困難になる可能性<br /><br /> 過去の&1; つのダイアログ ボックスで&5; つのタブは、一般に拡張します。<br /><br /> 不適切なは、1 つの行の多くのタブがある場合別の階層化手法を使用してください。<br /><br /> 拡張しません。|  
|サイド バー ナビゲーション|タブの他のカテゴリを対応する単純な切り替え装置<br /><br /> カテゴリ (階層構造) の単純なリスト<br /><br /> 拡張可能です<br /><br /> 例: **... カスタマイズ > コマンドの追加**|水平方向の領域よりも少ない&3; つのグループがある場合の適切な使い方ではありません。<br /><br /> タスクがドロップダウン リストに適していますがより可能性があります。|  
|ツリー コントロール|無制限のカテゴリでは、します。<br /><br /> グループ化やカテゴリの階層では、します。<br /><br /> 拡張可能です<br /><br /> 例:**ツール > オプション**|入れ子になった頻度の高い階層には、過剰な水平方向にスクロール可能性があります。<br /><br /> Visual Studio がツリー ビューの思わぬ意味|  
|ウィザード|タスク ベースで連続的な手順を完了したタスクを支援します。 ウィザードは高レベルのタスクを表し、各パネルが全体的なタスクを実行するために必要なサブタスクを表します。<br /><br /> タスクがときに、ユーザーは、複数のエディターを使用して、ツール ウィンドウのタスクを完了する必要がそれ以外の場合として、Ui の境界を越える場合に便利です。<br /><br /> タスクは、分岐が必要な場合に役立ちます。<br /><br /> タスクには、手順間の依存関係が含まれている場合に役立ちます。<br /><br /> 別のようなダイアログ ボックスの数を減らす&1; つのダイアログ ボックスで、意思決定の&1; つの分岐でいくつかのようなタスクを提示する場合に役立ちます。|シーケンシャル ワークフローを必要としない任意のタスクの不適切です<br /><br /> 過負荷状態に、多くの手順で、ウィザードによって混乱ができます。<br /><br /> ウィザードには、実際の画面が限られている本質的に|  
  
##### <a name="hallways-or-dashboards"></a>廊下やダッシュ ボード  
 廊下とダッシュ ボードは、ダイアログやその他のダイアログ ボックスおよびウィンドウへのポインターを起動する役割を果たしますパネルです。 適切に設計された「ホール」は、のみ、最も一般的なオプション、コマンド、および一般的なタスクをすぐに実行するユーザーを許可する設定にすぐに表示されます。 実際の廊下では、背後にルームにアクセスする入り口を提供するようにここで、頻度の低い UI は専用「ルーム」(多くの場合、その他のダイアログ ボックス) の主の廊下からアクセス可能な関連する機能に集約されます。  
  
 また、ダッシュ ボードにだけでは、別の場所に頻度の低い機能をリファクタリングするのではなく、単一のコレクションで使用可能なすべての機能を提供する UI。  
  
 ![Outlook での廊下の概念](../../extensibility/ux-guidelines/media/0704-08_hallway.png "0704&08;_Hallway")  
  
 **Outlook での他の UI を公開するための廊下の概念**  
  
##### <a name="adaptive-ui"></a>アダプティブ UI  
 使用量に基づいて、UI の表示と非表示または自主的に報告のユーザー エクスペリエンスが必要な UI を表示するのには他の部分を非表示の別の方法を示します。 これは UI を非表示かを決めるアルゴリズムは、複雑になる場合と、ルールが誤っているケースのいくつかのセットは常に、Visual Studio では推奨されません。  
  
##  <a name="a-namebkmkprojectsa-projects"></a><a name="BKMK_Projects"></a>プロジェクト  
  
### <a name="projects-in-the-solution-explorer"></a>ソリューション エクスプ ローラーでプロジェクト  
 ほとんどのプロジェクトは、その参照に基づく、ディレクトリ ベース、または混在に分類されます。 次の&3; つすべての種類のプロジェクトはソリューション エクスプ ローラーで同時にサポートします。 プロジェクトでの作業でユーザー エクスペリエンスのルートは、このウィンドウ内行われます。 別のプロジェクトのノードは、参照、ディレクトリ、または混在モードの種類のプロジェクトには、プロジェクト固有のユーザーのパターンに分岐する前に開始点として適用される一般的な相互作用のパターンがあります。  
  
 プロジェクトには常にする必要があります。  
  
-   プロジェクトの内容を整理するフォルダーをプロジェクトに追加する機能のサポート  
  
-   プロジェクトの永続化を一貫したモデルを管理します。  
  
 プロジェクトの一貫性のある相互作用のモデルの管理もする必要があります。  
  
-   プロジェクト項目の削除  
  
-   ドキュメントの保存  
  
-   プロジェクト プロパティの編集  
  
-   代替ビューで、プロジェクトの編集  
  
-   ドラッグ アンド ドロップの操作  
  
### <a name="drag-and-drop-interaction-model"></a>ドラッグ アンド ドロップ操作モデル  
 プロジェクトを通常分類自体の参照をベースとして (記憶域内のプロジェクト項目への参照のみを保持すること)、ディレクトリ ベースの (唯一のプロジェクト項目を物理的に永続化すること格納されているプロジェクトの階層内で)、または混合 (参照または物理的な項目を永続化可能)。 IDE 内で同時に&3; 種類のプロジェクトすべてに対応、**ソリューション エクスプ ローラー**します。  
  
 内のプロジェクトの種類ごとにドラッグ アンド ドロップの観点から、次の特性を適用する必要があります、**ソリューション エクスプ ローラー**:  
  
-   **プロジェクトの参照に基づく:**重要なポイントは、プロジェクトがストレージ内の項目への参照をドラッグすることです。 参照ベースのプロジェクトは、移動操作のソースとして動作している場合にのみプロジェクトからアイテムへの参照を削除する必要があります。 項目いない実際に削除してください、ハード ドライブから。 参照ベースのプロジェクトは、移動またはコピー操作の対象として動作際は、アイテムのプライベート コピーを作成せず、元のソース アイテムへの参照を追加、します。  
  
-   **ディレクトリ ベースのプロジェクト:**ドラッグ アンド ドロップの観点から、プロジェクトが参照ではなく、物理的なアイテムの周囲でドラッグすることです。 ディレクトリ ベースのプロジェクトは、移動操作のソースとして動作は、ハード ドライブから物理的な項目を削除するだけでなく、プロジェクトから削除することを終了しなければなりません。 ディレクトリ ベースのプロジェクトは、移動またはコピー操作のターゲットとして機能、そのターゲットの場所にソース項目のコピーにする必要があります。  
  
-   **混在ターゲット プロジェクト:**ドラッグ アンド ドロップの観点から、この種類のプロジェクトの動作は (ストレージ内の項目への参照) または、項目自体のいずれかにドラッグされている項目の種類に基づきます。 上記の参照、および物理的な項目の正しい動作。  
  
 プロジェクトの種類を&1; つだけがあった場合、**ソリューション エクスプ ローラー**、ドラッグ アンド ドロップ操作が簡単です。 各プロジェクト システムは、独自のドラッグ アンド ドロップの動作を定義する機能があるため、予測可能なユーザー エクスペリエンスを実現する (Windows エクスプ ローラーのドラッグ アンド ドロップの動作に基づく) 特定のガイドラインに従ってください。  
  
-   操作をドラッグして、変更されていない、**ソリューション エクスプ ローラー**移動操作になります (ときに ctrl キーを押しも Shift キー間押され)。  
  
-   Shift キーを押しドラッグ操作は、移動操作にもなります。  
  
-   Ctrl キーを押しドラッグ操作は、コピー操作になります。  
  
-   および参照ベースの混合プロジェクト システムは、元の項目にリンク (または参照) を追加するという概念をサポートします。 これらのプロジェクトは、ドラッグ アンド ドロップ操作の対象と (ときに**ctrl キーを押しながら shift キーを押し**が押された)、プロジェクトに追加される項目への参照で発生する必要があります  
  
 すべてのドラッグ アンド ドロップ操作は、参照に基づく、ディレクトリ ベースおよび混在プロジェクトの組み合わせで実用的なです。 具体的には、これはのようにソース ディレクトリ ベースのプロジェクトは、移動の完了時に元の項目を削除する必要があるために、ディレクトリ ベースの移行元のプロジェクトと参照に基づく対象となるプロジェクトの間の移動操作を許可するように振る舞う困難です。 ターゲットの参照に基づくプロジェクトとのことになる削除済みアイテムへの参照。  
  
 ようにターゲットの参照に基づくプロジェクトはソース項目の独立したコピーにしないようにするために、この種のプロジェクト間でコピー操作を許可するように振る舞う誤解を招きやすいもあります。 同様に、ctrl キーを押しながら shift キーを押し、ディレクトリ ベースの移行先のプロジェクトにドラッグすることは許可されておらずディレクトリ ベースのプロジェクトが参照を保持できないためです。 ドラッグ アンド ドロップ操作がサポートされていない場合、IDE で、削除を許可しないようにを (以下のポインターへのテーブルを参照)、非ドロップ カーソルが、ユーザーを表示する必要があります。  
  
 ドラッグのソース プロジェクトをドラッグ アンド ドロップの動作を正しく実装するのには、本質的に通信する必要があります (たとえばは参照またはディレクトリ ベース) 対象のプロジェクトにします。 この情報は、ソースによって提供されるクリップボードの形式で表されます。 ドラッグ (またはクリップボードのコピー操作) のソースとしてプロジェクトに表示するいずれかの**CF_VSREFPROJECTITEM**S または**CF_VSSTGPROJECTITEMS**それぞれかどうかに応じて、プロジェクト参照に基づくディレクトリ ベースです。 両方の形式がある同一のデータのコンテンツは、Windows のような**ドロップ**する点を除いて、ファイル名ではなく、文字列のリストは、二重の書式を設定**NULL**の一覧を終了**Projref**文字列 (から返される**IVsSolution::GetProjrefOfItem**または**:: GetProjrefOfProject**必要に応じて)。  
  
 ドロップ (またはクリップボード貼り付けの操作) のターゲットとしてプロジェクトを受け入れるか両方**CF_VSREFPROJECTITEMS**と**CF_VSSTGPROJECTITEMS**ドラッグ アンド ドロップ操作の正確な処理は対象のプロジェクトおよびソース プロジェクトの性質によって異なりますが、します。 ソース プロジェクトが提供するかどうかによって本来を宣言**CF_VSREFPROJECTITEMS**または**CF_VSSTGPROJECTITEMS**します。 ドロップ ターゲット独自の性質を理解してこのようには、移動、コピー、かどうかを決定するのに十分な情報やリンクを実行する必要があります。 ユーザーは、ctrl キーを押し、shift キーまたは ctrl キーと Shift キーを押すと、ドラッグ アンド ドロップ操作を実行する必要がありますも変更されます。 ドロップ ターゲットがどの操作が事前に実行を適切に示すために重要である、 **DragEnter**と**ドラッグされた**メソッドです。 **ソリューション エクスプ ローラー**ソース プロジェクトおよびターゲット プロジェクトが同じプロジェクトをかどうかを自動的に認識します。  
  
 Visual Studio のインスタンス間で (たとえば、別の devenv.exe の&1; つのインスタンス) からプロジェクト項目をドラッグすることはサポートされていません。 **ソリューション エクスプ ローラー**も直接これを無効にします。  
  
 ユーザーは、常に項目を選択し、ターゲットの場所にドラッグすると、項目が削除される前に表示される次のマウス ポインターの観察し、ドラッグ アンド ドロップ操作の効果を確認することでする必要があります。  
  
|マウス ポインター|コマンド|説明|  
|-------------------|-------------|-----------------|  
|![マウスの [ドロップしない] アイコン](../../extensibility/ux-guidelines/media/0706-01_mousenodrop.png "0706&01;_MouseNoDrop")|ドロップしません。|指定した場所に項目を削除できません。|  
|![[コピー] アイコンをマウス](../../extensibility/ux-guidelines/media/0706-02_mousecopy.png "0706&02;_MouseCopy")|コピー|項目は、ターゲットの場所にコピーされます。|  
|![マウス [移動] アイコン](../../extensibility/ux-guidelines/media/0706-03_mousemove.png "0706&03;_MouseMove")|移動|項目は、ターゲットの場所に移動されます。|  
|!["参照の追加 アイコンをマウス](../../extensibility/ux-guidelines/media/0706-04_mouseaddref.png "0706&04;_MouseAddRef")|参照の追加|選択した項目への参照は、ターゲットの場所に追加されます。|  
  
#### <a name="reference-based-projects"></a>プロジェクトの参照に基づく  
 次の表では、参照されるベースの移行先のプロジェクトの押されたソースの項目と修飾子キーのために実行する必要があります (切り取り/コピー/貼り付け) と同様にドラッグ アンド ドロップ操作をまとめます。  
  
|||ソース アイテム: 参照/リンク|ソース アイテム: 物理項目またはファイル システム (ドロップ)|  
|-|-|----------------------------------|-------------------------------------------------------------|  
|修飾子なし|操作|移動|リンク|  
|修飾子なし|ターゲット|元の項目への参照を追加します。|元の項目への参照を追加します。|  
|修飾子なし|ソース|元の項目への参照を削除|元の項目が保持されます。|  
|修飾子なし|結果|**行った**からアクションとして返される**:: 削除**ストレージ内の元の場所に項目を開いたまま|**DROPEFFECT_LINK**からアクションとして返される**:: 削除**ストレージ内の元の場所に項目を開いたまま|  
|Shift キーを押しながらドラッグ|操作|移動|ドロップしません。|  
|Shift キーを押しながらドラッグ|ターゲット|元の項目への参照を追加します。|ドロップしません。|  
|Shift キーを押しながらドラッグ|ソース|元の項目への参照を削除|ドロップしません。|  
|Shift キーを押しながらドラッグ|結果|**行った**からアクションとして返される**:: 削除**ストレージ内の元の場所に項目を開いたまま|ドロップしません。|  
|Ctrl キーを押しながらドラッグ|操作|コピー|ドロップしません。|  
|Ctrl キーを押しながらドラッグ|ターゲット|元の項目への参照を追加します。|ドロップしません。|  
|Ctrl キーを押しながらドラッグ|ソース|元の項目への参照が保持されます。|ドロップしません。|  
|Ctrl キーを押しながらドラッグ|結果|**DROPEFFECT_COPY**からアクションとして返される**:: 削除**ストレージ内の元の場所に項目を開いたまま|ドロップしません。|  
|Ctrl キーを押しながら shift キーを押しながらドラッグ|操作|リンク|リンク|  
|Ctrl キーを押しながら shift キーを押しながらドラッグ|ターゲット|元の項目への参照を追加します。|元の項目への参照を追加します。|  
|Ctrl キーを押しながら shift キーを押しながらドラッグ|ソース|元の項目への参照が保持されます。|元の項目が保持されます。|  
|Ctrl キーを押しながら shift キーを押しながらドラッグ|結果|**DROPEFFECT_LINK**からアクションとして返される**:: 削除**ストレージ内の元の場所に項目を開いたまま|**DROPEFFECT_LINK**からアクションとして返される**:: 削除**ストレージ内の元の場所に項目を開いたまま|  
|Ctrl キーを押しながら shift キーを押しながらドラッグ|メモ|Windows エクスプ ローラーのショートカット キーのドラッグ アンド ドロップの動作と同じです。||  
|切り取り/貼り付け|操作|移動|リンク|  
|切り取り/貼り付け|ターゲット|元の項目への参照を追加します。|元の項目への参照を追加します。|  
|切り取り/貼り付け|ソース|元の項目への参照が保持されます。|元の項目が保持されます。|  
|切り取り/貼り付け|結果|項目がストレージ内の元の場所に残ります|項目がストレージ内の元の場所に残ります|  
|コピー/貼り付け|操作|コピー|リンク|  
|コピー/貼り付け|ソース|元の項目への参照を追加します。|元の項目への参照を追加します。|  
|コピー/貼り付け|結果|元の項目への参照が保持されます。|元の項目が保持されます。|  
|コピー/貼り付け|操作|項目がストレージ内の元の場所に残ります|項目がストレージ内の元の場所に残ります|  
  
#### <a name="directory-based-projects"></a>ディレクトリ ベースのプロジェクト  
 次の表では、ディレクトリ ベースの移行先のプロジェクトの押されたソースの項目と修飾子キーのために実行する必要があります (切り取り/コピー/貼り付け) と同様にドラッグ アンド ドロップ操作をまとめます。  
  
|||ソース アイテム: 参照/リンク|ソース アイテム: 物理項目またはファイル システム (ドロップ)|  
|-|-|----------------------------------|-------------------------------------------------------------|  
|修飾子なし|操作|移動|移動|  
|修飾子なし|ターゲット|ターゲットの場所にコピー項目|ターゲットの場所にコピー項目|  
|修飾子なし|ソース|元の項目への参照を削除|元の項目への参照を削除|  
|修飾子なし|結果|**DROPEFFECT_ 移動**からアクションとして返される**:: 削除**ストレージ内の元の場所に項目を開いたまま|**DROPEFFECT_ 移動**からアクションとして返される**:: 削除**ストレージ内の元の場所に項目を開いたまま|  
|Shift キーを押しながらドラッグ|操作|移動|移動|  
|Shift キーを押しながらドラッグ|ターゲット|ターゲットの場所にコピー項目|ターゲットの場所にコピー項目|  
|Shift キーを押しながらドラッグ|ソース|元の項目への参照を削除|元の場所から項目を削除します。|  
|Shift キーを押しながらドラッグ|結果|**DROPEFFECT_ 移動**からアクションとして返される**:: 削除**ストレージ内の元の場所に項目を開いたまま|**DROPEFFECT_ 移動**からアクションとして返される**:: 削除**ストレージ内の元の場所に項目を開いたまま|  
|Ctrl キーを押しながらドラッグ|操作|コピー|コピー|  
|Ctrl キーを押しながらドラッグ|ターゲット|ターゲットの場所にコピー項目|ターゲットの場所にコピー項目|  
|Ctrl キーを押しながらドラッグ|ソース|元の項目への参照が保持されます。|元の項目への参照が保持されます。|  
|Ctrl キーを押しながらドラッグ|結果|**DROPEFFECT_ コピー**からアクションとして返される**:: 削除**ストレージ内の元の場所に項目を開いたまま|**DROPEFFECT_ コピー**からアクションとして返される**:: 削除**ストレージ内の元の場所に項目を開いたまま|  
|Ctrl キーを押しながら shift キーを押しながらドラッグ||ドロップしません。|ドロップしません。|  
|切り取り/貼り付け|操作|移動|移動|  
|切り取り/貼り付け|ターゲット|ターゲットの場所にコピー項目|ターゲットの場所にコピー項目|  
|切り取り/貼り付け|ソース|元の項目への参照を削除|元の場所から項目を削除します。|  
|切り取り/貼り付け|結果|項目がストレージ内の元の場所に残ります|記憶域内の元の場所から削除されます。|  
|コピー/貼り付け|操作|コピー|コピー|  
|コピー/貼り付け|ターゲット|元の項目への参照を追加します。|ターゲットの場所にコピー項目|  
|コピー/貼り付け|ソース|元の項目が保持されます。|元の項目が保持されます。|  
|コピー/貼り付け|結果|項目がストレージ内の元の場所に残ります|項目が元の場所をストレージに残ります|  
  
#### <a name="mixed-target-projects"></a>混在ターゲット プロジェクト  
 次の表では、混在ターゲット プロジェクトの押されたソースの項目と修飾子キーのために実行する必要があります (切り取り/コピー/貼り付け) と同様にドラッグ アンド ドロップ操作をまとめます。  
  
|||ソース アイテム: 参照/リンク|ソース アイテム: 物理項目またはファイル システム (ドロップ)|  
|-|-|----------------------------------|-------------------------------------------------------------|  
|修飾子なし|操作|移動|移動|  
|修飾子なし|ターゲット|元の項目への参照を追加します。|ターゲットの場所にコピー項目|  
|修飾子なし|ソース|元の項目への参照を削除|元の項目への参照を削除|  
|修飾子なし|結果|**DROPEFFECT_ 移動**からアクションとして返される**:: 削除**ストレージ内の元の場所に項目を開いたまま|**DROPEFFECT_ 移動**からアクションとして返される**:: 削除**とストレージ内の元の場所からアイテムを削除|  
|Shift キーを押しながらドラッグ|操作|移動|移動|  
|Shift キーを押しながらドラッグ|ターゲット|元の項目への参照を追加します。|ターゲットの場所にコピー項目|  
|Shift キーを押しながらドラッグ|ソース|元の項目への参照を削除|元の場所から項目を削除します。|  
|Shift キーを押しながらドラッグ|結果|**DROPEFFECT_ 移動**からアクションとして返される**:: 削除**ストレージ内の元の場所に項目を開いたまま|**DROPEFFECT_ 移動**からアクションとして返される**:: 削除**とストレージ内の元の場所からアイテムを削除|  
|Ctrl キーを押しながらドラッグ|操作|コピー|コピー|  
|Ctrl キーを押しながらドラッグ|ターゲット|元の項目への参照を追加します。|ターゲットの場所にコピー項目|  
|Ctrl キーを押しながらドラッグ|ソース|元の項目への参照が保持されます。|元の項目が保持されます。|  
|Ctrl キーを押しながらドラッグ|結果|**DROPEFFECT_ コピー**からアクションとして返される**:: 削除**ストレージ内の元の場所に項目を開いたまま|**DROPEFFECT_ コピー**からアクションとして返される**:: 削除**ストレージ内の元の場所に項目を開いたまま|  
|Ctrl キーを押しながら shift キーを押しながらドラッグ|操作|リンク|リンク|  
|Ctrl キーを押しながら shift キーを押しながらドラッグ|ターゲット|元の項目への参照を追加します。|元のソース アイテムへの参照を追加します。|  
|Ctrl キーを押しながら shift キーを押しながらドラッグ|ソース|元の項目への参照が保持されます。|元の項目が保持されます。|  
|Ctrl キーを押しながら shift キーを押しながらドラッグ|結果|**DROPEFFECT_ リンク**からアクションとして返される**:: 削除**ストレージ内の元の場所に項目を開いたまま|**DROPEFFECT_ リンク**からアクションとして返される**:: 削除**ストレージ内の元の場所に項目を開いたまま|  
|切り取り/貼り付け|操作|移動|移動|  
|切り取り/貼り付け|ターゲット|ターゲットの場所にコピー項目|ターゲットの場所にコピー項目|  
|切り取り/貼り付け|ソース|元の項目への参照を削除|元の場所から項目を削除します。|  
|切り取り/貼り付け|結果|項目がストレージ内の元の場所に残ります|記憶域内の元の場所から削除されます。|  
|コピー/貼り付け|操作|コピー|コピー|  
|コピー/貼り付け|ターゲット|元の項目への参照を追加します。|ターゲットの場所にコピー項目|  
|コピー/貼り付け|ソース|元の項目が保持されます。|元の項目が保持されます。|  
|コピー/貼り付け|結果|項目がストレージ内の元の場所に残ります|項目がストレージ内の元の場所に残ります|  
  
 これらの詳細は、内のドラッグを実装するときに考慮される必要があります、**ソリューション エクスプ ローラー**:  
  
-   選択範囲が複数あるシナリオの設計します。  
  
-   ファイル名 (完全パス) は、対象のプロジェクト間で一意でなければなりませんまたはドロップは許可されておらずします。  
  
-   フォルダー名は一意である必要があります (大文字) が破棄されるレベルです。  
  
-   ドラッグ (上記のシナリオでは取り上げられていません) の時にオープンかクローズであるファイルの間での動作の違いがあります。  
  
-   最上位レベルのファイルがフォルダー内のファイルよりも若干異なる方法で動作します。  
  
 注意すべきもう&1; つの問題は、開いているデザイナーまたはエディターを持つアイテムの移動操作を処理する方法です。 想定される動作は、次のとおりです (これはあらゆる種類のプロジェクトに適用)、です。  
  
1.  エディターとデザイナーを開くには、未保存の変更がない場合、エディターまたはデザイナー ウィンドウ何も行わずにクローズされます。  
  
2.  エディターとデザイナーを開くには、未保存の変更あるにすると、ドラッグのソースが、削除を実行し、ユーザーと、次のようにプロンプト ウィンドウを閉じる前に、開いているドキュメントでコミットされていない変更を保存するように依頼に待機。  
  
    ```  
    ==========================================================   
         One or more open documents have unsaved changes.  
    Do you want to save uncommitted changes before proceeding?   
                      [Yes]  [No]  [Cancel]   
    ==========================================================  
    ```  
  
 これにより、ユーザーは、ターゲットがそのコピーを行うには、進行中の作業を保存することです。 新しいメソッド**IVsHierarchyDropDataSource2::OnBeforeDropNotify**この処理を有効になりました。  
  
 記憶域に格納されることは、ターゲットに項目の状態はコピーし、(未保存の変更、ユーザーが選択した場合、エディター内含まれない**いいえ**)。 ターゲットがそのコピーを完了した後 (で**IVsHierarchyDropDataSource::Drop**)、ソースには、移動操作の削除の部分を完了する機会が与えられます (で**IVsHierarchyDropDataSource::OnDropNotify**)。  
  
 変更を保存して、エディターは、開いたまま必要があります。 変更を保存してそれらのドキュメントのつまり、移動操作のコピーの部分が実行されますが、削除の部分は中止されます。 複数選択シナリオを選択すると **いいえ**、そのドキュメントの保存されていない変更を終了したり、削除しないで必要がありますが、未保存の変更を使用しない終了および削除する必要があります。
