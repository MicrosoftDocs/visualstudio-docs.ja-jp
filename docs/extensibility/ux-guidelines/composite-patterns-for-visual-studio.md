---
title: Visual Studio の複合パターン |Microsoft Docs
description: Visual Studio での一貫性のための重要な複合パターンについて説明します。 複合パターンは、相互作用とデザイン要素を結合します。
ms.custom: SEO-VS-2020
ms.date: 11/04/2016
ms.topic: conceptual
ms.assetid: e48ecfb2-f4b5-4d3a-b4a2-7a4d62fa4ec0
author: acangialosi
ms.author: anthc
manager: jmartens
ms.workload:
- vssdk
ms.openlocfilehash: c8ac314a2ec49b805fc87badf6b63a719b8511e8
ms.sourcegitcommit: ae6d47b09a439cd0e13180f5e89510e3e347fd47
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 02/08/2021
ms.locfileid: "99952097"
---
# <a name="composite-patterns-for-visual-studio"></a>Visual Studio の複合パターン
複合パターンでは、個別の構成で相互作用とデザイン要素を組み合わせています。 一貫性に関して、Visual Studio で最も重要な複合パターンには次のようなものがあります。

- [データの視覚化](../../extensibility/ux-guidelines/composite-patterns-for-visual-studio.md#BKMK_DataVisualization)

- [オブジェクト内の UI とピーク](../../extensibility/ux-guidelines/composite-patterns-for-visual-studio.md#BKMK_OnObjectUI)

- [選択モデル](../../extensibility/ux-guidelines/composite-patterns-for-visual-studio.md#BKMK_SelectionModels)

- [永続化と設定の保存](../../extensibility/ux-guidelines/composite-patterns-for-visual-studio.md#BKMK_PersistenceAndSavingSettings)

- [タッチ入力](../../extensibility/ux-guidelines/composite-patterns-for-visual-studio.md#BKMK_TouchInput)

## <a name="data-visualization"></a><a name="BKMK_DataVisualization"></a> データの視覚化

### <a name="overview"></a>概要
 グラフは、意思決定を容易にするために、データを集計して視覚化するための視覚的な方法です。 ユーザーは大量のデータに直面するのに役立ちますが、あまり注意が必要なものや、アクションが必要になる可能性があることを確認することはできません。

 次の条件のいずれかに該当する場合、ユーザーはグラフを活用できます。

- グラフは、ユーザーが操作できるタスクを特定するのに役立ちますか。

- グラフでは、ユーザーが潜在的な変更の結果を予測できるようになりますか。

- グラフは、ユーザーが傾向を発見し、パターンを識別するのに役立ちますか。

- グラフでは、ユーザーがより良い決定を行えるようになりますか。

- グラフは、特定のコンテキストでユーザーに与えられている特定の質問に回答するのに役立ちますか。

#### <a name="general-rules-for-charts"></a>グラフの一般的な規則

- データのラベルを明確にします。 説明のない図は、非常に美しい画像にすぎません。

- 比率を傾斜させないようにするには、軸をゼロで開始します。 行の長さと棒のサイズは、データポイント間の関係を理解するために重要な視覚的手掛かりです。

- インフォグラフィックスではなく、グラフを作成します。 インフォグラフィックスはデータを視覚的に表現したものであり、主な目的は visual ストーリーテリングです。 グラフは視覚的に魅力を持つことができますが、それ自体のためにデータを読み上げることができます。

- Skeumorphism、視覚的な棒グラフ、コントラストのある画像、その他のインフォグラフィックに触れないようにします。

- 3D 効果を装飾的な要素として使用しないでください。 これらの情報は、ユーザーが情報を理解する能力に実際に不可欠な場合にのみ使用してください。

- 複数の線と塗りつぶしを使用しないでください。2色を超えると、この種類のグラフの読み取りや解釈が困難になる場合があります。

- 概念を理解したりデータを操作したりする唯一の方法として、グラフ (または任意の図) は使用しないでください。 これにより、視覚障碍のあるユーザーにとって問題が発生します。

- ページでは、グラフを無償または装飾的な要素として使用しないでください。 つまり、グラフで値が追加されていない場合や、ユーザーが問題を解決できない場合は、使用しないでください。

### <a name="chart-types"></a>グラフの種類
 Visual Studio で使用されるグラフの種類には、横棒グラフ、折れ線グラフ、変更された円グラフ (リンググラフまたは "ドーナツグラフ")、タイムライン、散布図 ("クラスターグラフ" とも呼ばれます)、およびガントチャートがあります。 それぞれの種類のグラフは、さまざまな種類の情報を伝えるのに役立ちます。

### <a name="other-charting-considerations"></a>その他のグラフ作成の考慮事項

#### <a name="color"></a>Color
 グラフの色には、Visual Studio で使用するために定義されている特定のパレットがあります。 パレットは、視覚障碍の主要な種類に対してアクセスできます。色の非常に狭いスライスとして使用されている場合でも、色は区別されます。 これらの色は、UI の任意の種類のグラフやグラフに対して任意の組み合わせで使用できます。 複数の色を使用する必要がない場合は、7色すべてを使用する必要はありません。 これらの色は、前景要素と共に使用するように設計されていないため、これらの色の上にテキストやグリフを配置しないでください。 これらの色合いはハードコーディングされ、[ **ツール > オプション** ] の [ユーザーのカスタマイズ] に表示される必要があります (「 [エンドユーザー向けの色の公開](../../extensibility/ux-guidelines/colors-and-styling-for-visual-studio.md#BKMK_ExposingColorsForEndUsers)」を参照してください)。

|見本|Hex|RGB|
|------------|---------|---------|
|![見本 71B252](../../extensibility/ux-guidelines/media/0711_71b252.png "0711_71B252")|#71B252|113178、82|
|![見本 BF3F00](../../extensibility/ux-guidelines/media/0711_bf3f00.png "0711_BF3F00")|#BF3F00|191、63、0|
|![見本 FCB714](../../extensibility/ux-guidelines/media/0711_fcb714.png "0711_FCB714")|#FCB714|252183、20|
|![見本 903F8B](../../extensibility/ux-guidelines/media/0711_903f8b.png "0711_903F8B")|#903F8B|144、63139|
|![見本 117AD1](../../extensibility/ux-guidelines/media/0711_117ad1.png "0711_117AD1")|#117AD1|17122209|
|![見本 79D7F2](../../extensibility/ux-guidelines/media/0711_79d7f2.png "0711_79D7F2")|#79D7F2|121215242|
|![見本 B5B5B5](../../extensibility/ux-guidelines/media/0711_b5b5b5.png "0711_B5B5B5")|#B5B5B5|181181181|

## <a name="on-object-ui-and-peeking"></a><a name="BKMK_OnObjectUI"></a> オブジェクト内の UI とピーク
 このセクションでは、Visual Studio に固有のオブジェクト内 UI の種類として、コードピークビューとも呼ばれる、ピークのコンテキストを示します。

### <a name="overview"></a>概要

- オブジェクトの UI を使用すると、ユーザーにメインタスクから detracting せずに、より多くの情報や対話機能を提供する必要があります。

- Visual Studio でのオブジェクト内 UI のメインパターンは、「詳細な情報」と呼ばれています。

- Visual Studio のオブジェクト内 UI は、インラインまたはフローティングで、永続性または一時的なものです。

  - Visual Studio のオブジェクト内 UI の一種であるコードピークビューは、インラインで持続性があります。

  - Visual Studio のオブジェクト内 UI の種類である CodeLens は、フローティングと一時的です。

  コードの一部がどのように動作するかを理解したり、そのコードの詳細を検索したりするには、多くの場合、開発者がコンテキストを切り替え、他のコンテンツや別のウィンドウに移動する必要があります。 これらのコンテキストのシフトは、ユーザーがメインウィンドウを離れると元のタスクにフォーカスを失う可能性があるため、中断される可能性があります。 また、windows の切り替えによって元のコードが他の UI によって隠される場合は特に、元のコンテキストを元に戻すことが困難になる可能性があります。

  オブジェクト内の UI は、"注意点に関する情報" というパターンに従います。 これらのメッセージ、ポップアップウィンドウ、およびダイアログボックスを使用すると、主要なタスクにフォーカスを移動することなく、明確または対話機能を追加する関連情報をユーザーに提供できます。 オブジェクト内 UI の例としては、ユーザーが通知領域のアイコンの上にポインターを置いたときに表示されるポップアップウィンドウ、スペルミスの単語の下の赤い波線、Visual Studio 2013 で導入されたピークビューなどがあります。

### <a name="decision-points"></a>デシジョンポイント
 Visual Studio では、このような情報のパターンを注意して使用する方法がいくつかあります。 適切なメカニズムを選択し、一貫性のある予測可能な方法で実装することは、全体的なエクスペリエンスに不可欠です。 そうしないと、ユーザーには、コンテンツ自体からフォーカスをあって混乱を招くことがあります。

#### <a name="relationships-between-master-and-detail-content"></a>マスターコンテンツと詳細コンテンツ間のリレーションシップ
 注意点の情報は、ユーザーがフォーカスしているコンテンツ ("マスター" コンテンツ) とその他の関連コンテンツ ("詳細" コンテンツ) との関係を表示するために使用されます。 このパターンでは、詳細コンテンツはユーザーが操作しているコンテンツに明確に関連し、マスターコンテンツの近くに表示できます。 マスターコンテンツを大量にまとめることができない補足情報や情報は、ツールウィンドウなどの別のパターンに従う必要があります。

- 詳細コンテンツは、**常に** マスターコンテンツの近くに表示されます。

- 詳細コンテンツが引き続き、マスターコンテンツにフォーカスされたままに **なるように** します。 多くの場合、これを実現する最善の方法は、できるだけ詳細なコンテンツをマスターコンテンツの近くに表示することです。 これを行うには、マスターコンテンツの横にあるポップアップウィンドウに詳細コンテンツを表示するか、マスターコンテンツの下に詳細コンテンツをインライン表示します。

- ユーザーがマスタコンテンツから離れた場所にいる場合は、注意が必要な情報を使用 **しない** でください。 ユーザーが詳細コンテンツを個別に表示する必要がある場合は、ユーザーがこの操作を実行できるようにする明示的なアクションを公開します。

#### <a name="design-details"></a>デザインの詳細
 オンオブジェクト UI が最適な選択であると判断したら、次の4つの主要な設計上の考慮事項があります。

1. **永続性:** コンテンツは耐久性があるか、または一時的であると想定されていますか。
   ユーザーは、参照または操作のために情報を表示したままにする必要がありますか。 または、ユーザーが情報をひとめで確認し、メインタスクを続行したいと思いますか。

2. **コンテンツの種類:** コンテンツは、情報、操作可能、またはナビゲーションになりますか。
   ユーザーは、マスターコンテンツに関する追加の詳細情報を必要としていますか。 ユーザーは、マスターコンテンツに影響を与えるタスクを完了する必要がありますか。 または、ユーザーを別のリソースに転送する必要がありますか。

3. **インジケーターの種類:** アンビエントインジケーターは意味がありますか。
   有用な方法で情報を要約して、マスターコンテンツを圧倒せずに表示することはできますか。

4. **ジェスチャ:** UI の呼び出しと破棄にどのようなジェスチャが使用されますか。
   ユーザーは詳細コンテンツをどのように表示して送信しますか。 一時的な状態と永続的な状態の切り替えにピン留めするなどのジェスチャの追加には、値はありますか。

   これらの4つの決定ポイントは、オブジェクト上の UI の主要なコンポーネントに影響を与えます。

### <a name="on-object-ui-components"></a>オブジェクト内の UI コンポーネント

1. コンテナー (コンテンツプレゼンター) の種類

    - フローティング

    - インライン

2. Content type

    - 情報: 静的または動的なデータ

    - 対応可能: マスターコンテンツを変更するコマンド

    - ナビゲーション: ユーザーを別のウィンドウまたはアプリケーション (MSDN など) に移動するリンク

3. ジェスチャ

    - 呼び出し

    - 無視

    - ピン留め

    - その他の対話

4. 永続化とコミットモデル

    - 一時的

    - Durable

    - 自動

    - オンデマンド

5. アンビエントインジケーター (省略可能)

    - 波線の下線

    - スマートタグアイコン

    - その他のアンビエントインジケーター

#### <a name="container-content-presenter-type"></a>コンテナー (コンテンツプレゼンター) の種類
 注意点でコンテンツを表示するには、次の2つの主要なオプションがあります。

1. **Inline:** Visual Studio 2013 コードエディターで導入された [ピーク] ビューなどのインラインプレゼンターは、既存のコンテンツを移動することによって、新しいコンテンツ用の領域を確保します。

    - インラインプレゼンターを **優先** する場合は、ユーザーが指定したコンテンツを参照したり操作したりするのに非常に長い時間がかかることが予想されます。

    - ユーザーが表示しようとしている情報を確認し、中断を最小限に抑えてメインタスクを続行する場合は、インラインプレゼンターを使用し **ないよう** にします。

2. **フローティング:** フローティングプレゼンターは、選択したコンテンツにできるだけ近い場所に配置されますが、既存のコンテンツのレイアウトは変更されません。 選択した記号に対して、使用可能な最も近い空白にフローティングコンテンツパネルを表示するなど、さまざまな方法を使用できます。

    - ユーザーが表示しようとしている情報を確認し、中断を最小限に抑えてメインタスクを続行する場合は、フローティングプレゼンターを **優先** します。

    - ユーザーが、提示されたコンテンツを参照したり、操作したりするために膨大な時間を費やすことが予想される場合は、浮動プレゼンターを使用し **ないよう** にします。

#### <a name="content-type"></a>Content type
 オブジェクトの UI コンテナー内に表示できるコンテンツには、主に3つの種類があります。 これらの種類の情報の任意の組み合わせを表示できます。 次の3つの型があります。

1. **情報:** ほとんどのオブジェクトの UI コンテナーには、何らかの情報コンテンツが表示されます。 コンテンツは、環境の現在の状態に関する情報を表すことができます。また、環境の将来の状態に関する情報を表す場合もあります。 たとえば、リファクタリングなどの特定のコマンドが既存のコードに与える影響を示すために使用できます。

    - 表示する情報の正規表現を **常に** 使用します。 たとえば、コードはコードのようになり、構文の強調表示が設定されている必要があります。また、ユーザーが設定したフォントやその他の環境設定を考慮する必要があります。

    - 同じ情報がマスターコンテンツとして表示される場合は、情報コンテンツに対するアクションを **常に** サポートすることを検討してください。 たとえば、オンオブジェクトの UI コンテナー内に既存のコードを表示する場合は、そのコードを参照および変更する機能をサポートすることを強く検討してください。

    - 将来の潜在的な状態を表す情報コンテンツを表示する場合は、**常に** 別の背景色を使用することを検討してください。

2. 対応可能: いくつかのオンオブジェクト UI コンテナーは、リファクタリング操作の実行など、マスターコンテンツに対して何らかのアクションを実行する機能を提供します。

    - **常に** 、操作可能なコマンドを情報コンテンツとは別に配置します。

    - 必要に応じて、アクションを **常** に有効または無効にします。

    - ダイアログボックス内のコマンドを表す標準ガイドライン **を参照し** てください。

    - **常** に、オブジェクト内の UI コンテナーで公開されているアクションの数を最小限に抑えます。 オブジェクト内 UI との対話は、軽量で高速なエクスペリエンスである必要があります。 ユーザーは、オブジェクトの UI コンテナー自体の管理にエネルギーを費やす必要はありません。

    - **常** に、オブジェクト内の UI コンテナーを閉じるか破棄するかを検討します。 ベストプラクティスとして、マスターコンテンツと詳細コンテンツの間のダイアログを終了するアクションでは、そのアクションが呼び出されたときにオブジェクト間 UI コンテナーも閉じる必要があります。

3. **ナビゲーション:** いくつかのオブジェクトの UI コンテナーには、ユーザーを別のウィンドウまたはアプリケーションに移動するリンクが含まれています。たとえば、ユーザーの web ブラウザーで MSDN 記事を開くことができます。

    - 他のコンテンツに移動してもユーザーには驚かれないように、**常に**"Open" を使用してナビゲーションリンクを先頭に付加します。

    - ナビゲーションリンクは、**常に** アクション可能なリンクから分離します。

#### <a name="ambient-indicators-optional"></a>アンビエントインジケーター (省略可能)
 アンビエントインジケーターは微妙な場合があります。これには、コードの他の部分とは対照的な色で表示されるテキストや、波線の下線やスマートタグアイコンなどの tickler 記号などが含まれます。 アンビエントインジケーターは、関連する追加情報の可用性を伝えます。 理想的には、ユーザーによる操作が不要な場合でも、役に立つ情報を提供します。

- アンビエントインジケーターは、ユーザーにとってあいまいでないように **常に** 配置します。 このような方法でアンビエントインジケーターを配置できない場合は、別の解決策を検討してください。

- アンビエントインジケーターは、**常** に、関連するコンテンツにできるだけ近い場所に配置します。

- **常に** 、使用可能な情報をまとめたインジケーターの作成を試みます。 使用可能なデータ項目の数 (単に単に "参照" ではなく "3 つの参照" など) を提供するか、データを集計する他の方法を検討してください。

  - インジケーターのデータが常に計算されて表示されない場合は、値が計算されるときにプログレッシブフィードバックを提供することをすぐに検討してください。 たとえば、使用可能なデータの更新が反映された変更をアニメーション化することを検討してください。電子メールのライブタイルを更新する方法と同様に、未読の電子メールの数が増えるにつれて Windows Phone が更新されます。

- ユーザーが特定のコンテンツに対して合理的に実行できるインジケーターを追加 **しない** でください。 アンビエントインジケーターは、ユーザーとの対話を必要とせずに便利です。 オーバーフローやその他の管理コントロールを表示する必要がある場合、インジケーターはそのアンビエントを失います。

#### <a name="gestures"></a>ジェスチャ
 ユーザーがマスターコンテンツにフォーカスを保持できるようにするための重要な点は、追加の詳細コンテンツを開いて閉じるための適切なジェスチャをサポートすることです。

- 追加のコンテンツを開くには、**常** に明示的なジェスチャを実行するようにユーザーに要求します。 一般的な開いているジェスチャは次のとおりです。

  - **ホバー:** ヒントまたは非対話型の情報コンテンツ

  - **Explicit コマンド:** インラインプレゼンター

  - **[アンビエント] インジケーターをダブルクリックします。** CodeLens のポップアップウィンドウ

- ユーザーが Esc キーを押したときは **常に** 詳細コンテンツを無視します。

- **常** に、オブジェクト内の UI のコンテキストを検討してください。 コンテナー内での対話を可能にするコンテンツのプレゼンターの場合、ホバー時に追加情報を表示するかどうかを慎重に検討してください。これは、ユーザーのワークフローに悪影響を及ぼす可能性があります。

- ホバー時にコンテンツを表示し **ない** ようにして、編集可能またはユーザーとの対話を招待します。 この動作は、ユーザーがカーソルを詳細コンテンツの上に移動しようとした場合に、ユーザーに不満を感じる可能性があります。これは、ツールヒントの標準動作が、カーソルが生成されたマスターコンテンツから除外されたときに直ちに破棄されるためです。

## <a name="selection-models"></a><a name="BKMK_SelectionModels"></a> 選択モデル

### <a name="overview"></a>概要
 選択モデルは、ユーザーインターフェイス内で対象の1つ以上のオブジェクトに対して操作を示し、確認するために使用されるメカニズムです。 このトピックでは、Visual Studio ドキュメントエディター内の選択操作パターン (テキストエディター、デザインサーフェイス、モデリングサーフェイス) について説明します。

 ユーザーは、Visual Studio で作業していることを示す方法を持っている必要があります。また、Visual Studio は、動作している内容についてユーザーにフィードバックを送ることで、予測どおりに応答する必要があります。 ユーザーとユーザーインターフェイスの間の違いまたは miscommunication によって、ユーザーがアクションを気付かないことがあります。これにより、意図しない結果が生じる可能性があります。 多くの場合、エラーは、何かが不足しているか変更されていることをユーザーが確認するまで気付かれません。 そのため、選択モデルは、ユーザーインターフェイスの設計の最も重要な部分の1つです。 Visual Studio の選択モデルは Windows との一貫性がありますが、微妙な違いがあります。

 Visual Studio では、Windows と同様に、選択モデルは相互作用が発生するコンテキストによって異なります。 選択は、次の4種類のオブジェクトで実行できます。

- Text

- グラフィック オブジェクト

- リストとツリー

- グリッド

  これらのオブジェクトには、次の3種類の選択肢があります。

- 連続

- 不整合

- リージョン

#### <a name="scope"></a>Scope
 選択の最も重要なコンポーネントは、ユーザーがどのウィンドウで作業しているか (アクティブ化)、フォーカスが置かれている場所 (選択) を確実に把握することです。 Visual Studio は Windows のウィンドウ管理機能を拡張しますが、アクティベーションスキームは同じです。ウィンドウを操作するとウィンドウにフォーカスが移動します。 Visual Studio には、アクティブ化のための2つのインジケーターがあります。1つはドキュメントウィンドウ用で、もう1つはツールウィンドウ用です。

 ドキュメントウィンドウの場合、アクティブウィンドウは、前面に表示される [ドキュメントウィンドウ] タブによって示され、背景色が変わります。

 ![Visual Studio でのアクティブなタブの選択](../../extensibility/ux-guidelines/media/0713-01_activetab.png "0713-01_ActiveTab")

 **アクティブなタブの選択**

 ツールウィンドウの場合、アクティブウィンドウは、ツールウィンドウのタイトルバー領域の色の変更によって示されます。

 ![Visual Studio でのアクティブなツール ウィンドウの選択](../../extensibility/ux-guidelines/media/0713-02_activetoolwindow.png "0713-02_ActiveToolWindow")

 **ノードのプライマリ選択を示すアクティブなツールウィンドウ**

 ![Visual Studio での非アクティブなツール ウィンドウの選択](../../extensibility/ux-guidelines/media/0713-03_inactivetoolwindow.png "0713-03_InactiveToolWindow")

 **非アクティブなツールウィンドウ。ノードの選択範囲を表示しています**

 ウィンドウがアクティブになると、ガイドラインのこのセクションで説明した選択モデルに従ってそのフォーカスが示されます。

#### <a name="context"></a>Context
 Visual Studio は、ユーザーがどこで作業しているかを追跡しながら、コンテキストの強力な概念を保持するように設計されています。 アクティブなウィンドウは、ツールウィンドウかドキュメントウィンドウかにかかわらず、1つだけです。 ただし、最上位のドキュメントウィンドウには、常に選択範囲が保持されます。 フォーカスはツールウィンドウに表示される場合がありますが、最後にアクティブになったドキュメントウィンドウには、非アクティブ状態であっても選択内容が表示されます。 これは、編集中のドキュメントにユーザーのコンテキストを保持するために行われます。これは、Visual Studio がツールウィンドウとドキュメントウィンドウの間でシームレスに戻ることができるように、Visual Studio が状態を保持していることを示しています。

### <a name="text-selection"></a>テキストの選択
 組み込みのテキストエディターなど、厳密にテキスト化された Visual Studio エディターでは、MSDN の「Windows ユーザーエクスペリエンスの相互作用ガイドライン」の「 [マウスとポインター](/windows/desktop/uxguide/inter-mouse) 」ページで説明したものと同じテキスト選択モデルと外観が使用されます。 テキストエディターの入力フォーカスは、挿入ポイントと呼ばれる縦棒で示されます。 挿入ポイントは1ピクセルの太線で、背後に表示されるものの逆の色になります。 コントロールパネルの **キーボード** アプレットの [**速度**] タブにある [**カーソルの点滅率**] 設定によって設定された速度に従って点滅します。

#### <a name="contiguous-and-disjoint-selection"></a>隣接する選択と非結合の選択
 テキストエディター内の選択範囲は連続しています。 非結合テキストの選択は許可されませんが、グラフィカルオブジェクトエディターで対処する必要があります。 ユーザーのマウスポインターがテキスト領域上にあると、カーソルが I ビームに変わります。 1回のクリックで、テキストエディター内のクリック位置に挿入ポイントが配置されます。 マウスボタンを押したままにすると選択範囲が強調表示され、マウスボタンを放すと選択範囲が強調表示されます。

#### <a name="region-selection-box-selection"></a>領域の選択 (ボックスの選択)
 Visual Studio では、テキストエディターでの領域の選択がサポートされています。これはボックスの選択と呼ばれます。 ボックスを選択すると、通常のテキストストリームに従わないテキストの領域をユーザーが選択できるようになります。 標準のテキスト選択と同様に、選択範囲は連続している必要があります。 ボックスの選択を開始するには、Alt キーを押したままマウスでドラッグします。 矢印キーを押しながら選択範囲を示すために、Alt キーと Shift キーを押しながら、ボックスの選択を開始することもできます。 ボックスの選択では、通常の選択範囲が使用され、選択領域の終了時に挿入ポイントのカーソルが点滅します。

 ![Visual Studio の [地域 &#40;ボックス&#41; 選択]](../../extensibility/ux-guidelines/media/0713-04_boxselection.png "0713-04_BoxSelection")

 **Visual Studio での Region (box) の選択**

#### <a name="text-selection-appearance"></a>テキストの選択の外観
 エディターでアクティブおよび非アクティブな選択に使用される色はカスタマイズできます。 エディターの外観をカスタマイズするには、ユーザーが [ツール] **> [オプション**] にアクセスし、[ **環境] > [フォントおよび色] > [テキストエディター**] の順に表示します。

### <a name="graphical-selection"></a>グラフィカルな選択

#### <a name="interaction"></a>相互作用
 グラフィカルオブジェクトの選択は複雑で、さまざまな要因によって異なります。

- **エディターのプライマリ選択モデル。** グラフィカルオブジェクトを含むエディターを使用して、テキストやグリッドを編集することもできます。 たとえば、エディターはテキストベースのエディターであり、Visual Studio XAML デザイナーなどのグラフィカルオブジェクトの配置もサポートします。 複数のオブジェクトの種類をサポートすると、さまざまな種類のオブジェクトで構成されたグループをユーザーが選択する方法に影響を与える可能性があります。

- **プライマリとセカンダリの選択状態がサポートされます。** エディターでは、オブジェクトを調整したり、互いに並べたり、サイズを変更したりできるように、プライマリとセカンダリの選択状態を指定できます。

- **埋め込み先編集のサポート。** エディターでは、グラフィカルオブジェクトの内容を編集することもできます。 たとえば、四角形の図形には、ユーザーが変更できるテキストを内部に含めることもできます。 また、そのテキストを中央揃えまたは両端揃えにすることもできます。 インプレース編集では、より詳細なユーザー操作のレベルが必要になるため、ユーザーに状態情報を表示するための適切な視覚的な手掛かりセットが必要になります。

#### <a name="mouse-interaction"></a>マウス操作

|入力|結果|
|-----------|------------|
|選択していないオブジェクトをクリックします|オブジェクトを選択し、オブジェクトのサイズが変更可能な場合は、破線と選択ハンドルを表示します。|
|選択したオブジェクトをクリックします|埋め込み先編集がオブジェクトでサポートされている場合にアクティブにします。 オブジェクトの外側をクリックすると、インプレース編集モードが非アクティブになります。|
|オブジェクトをダブルクリックします。|編集するためにオブジェクトの背後にあるコードを開き、必要に応じて既定のイベントハンドラーを挿入します。|
|オブジェクトをポイントします。|ポインターを移動カーソルに変更します。 オブジェクトの外観 (明度や色など) は変更される可能性があります。|
|選択ハンドルをポイントする|ポインターをサイズ変更カーソルに変更します。 回転をサポートするオブジェクトの場合、選択ハンドルによってポインターが別の位置に移動されるため、ポインターが回転カーソルに変わることがあります。|
|ドラッグ|オブジェクトが以前に選択されていない場合でも、は移動カーソルまでポインターを変更し、オブジェクトを移動します。|
|エディターがフォーカスを失った|埋め込み先編集モードを非アクティブにします。ただし、オブジェクトは、最後の操作/選択状態であったコンテンツと外観を保持します。|
|オブジェクトの選択|オブジェクトの境界を強調表示するために、境界線、点線、またはその他の視覚的に区別される処理によって示されます。|
|選択したオブジェクトのサイズを変更する|選択ハンドルで示されます。<br /><br /> サイズ変更可能なオブジェクトには、サイズを変更できる各方向を表す8つのハンドルがあります。 オブジェクトのサイズを特定の方向にしか変更できない場合は、使用できるハンドルが減少します。 ユーザーがオブジェクトのサイズを、8つのハンドルが対話型にならないように設定すると、4つのハンドルが使用されます。 ハンドルサイズは、ウィンドウの境界線とエッジメトリックに関連付けられます。 **GetSystemMetrics** API 関数を使用すると、ディスプレイの解像度に比例してサイズを調整できます。<br /><br /> ![サイズ変更ハンドル](../../extensibility/ux-guidelines/media/0713-05_resizehandles.png "0713-05_ResizeHandles")|
|選択したオブジェクトの回転|![回転ハンドル](../../extensibility/ux-guidelines/media/0713-06_rotate.png "0713-06_Rotate")|

#### <a name="keyboard-interaction"></a>キーボード操作

|入力|結果|
|-----------|------------|
|タブ|エディター内のオブジェクトの論理的な順序でフォーカスインジケーターを移動します。 **TabIndex** (またはそれと同等) のプロパティ値、オブジェクトの作成順序、およびエディターの全体的な目的に応じて、左から右または上から下に移動できます。 Shift + Tab キーを押すと、フォーカスインジケーターの方向が反転します。|
|Space|キーストロークが保持されている間、パンモードをアクティブにします。 ビューポートの位置をパンするには、追加のマウス入力が必要です。|
|Ctrl + Space|キーストロークが保持されている間、ズームモードをアクティブにします。 ズームファクターを増減するには、追加のマウス入力が必要です。|
|Ctrl + Alt + マイナス記号 (-)|ズーム率を1レベル下げます。|
|Ctrl + Alt + プラス記号 (+)|ズーム率を1レベル増やします。|
|Shift キーまたは Ctrl キー|選択グループにオブジェクトを追加します。 Ctrl キーを押すと、選択グループからオブジェクトを個別に削除することもできます。|
|Enter|オブジェクトの既定のコマンドを実行します (通常はオープンまたは編集)。|
|F2|オブジェクトのインプレース編集をアクティブにします。|
|方向キー|選択されたオブジェクトを、押された方向キーの方向に少しずつ移動します (たとえば、1ピクセルずつ)。|
|Ctrl + 方向キー|選択されたオブジェクトを、押された方向キーの方向に移動します (たとえば、一度に10ピクセル)。|
|Shift + 方向キー|選択したオブジェクトをそれぞれの方向にサイズ変更します (たとえば、1ピクセルずつ)。|
|Ctrl + Shift + 方向キー|選択したオブジェクトのサイズを、それぞれの方向にサイズ変更します (たとえば、一度に10ピクセル)。|

 ユーザーがコントロールを適切に編集するときは、ユーザー入力によってオブジェクトのサイズが自動的に変更されることがあります。 たとえば、ユーザーがラベルコントロールを編集すると、ラベルが拡張され、ユーザーが入力したテキストが表示されます。 これが行われない場合、ユーザーはテキストを編集した後にコントロールのサイズを手動で変更する必要があります。 ユーザーが多数のコントロールを持っている場合、これは rote と生産性の高いタスクになります。

#### <a name="graphical-containers"></a>グラフィカルコンテナー
 場合によっては、グラフィカルエディターでは、Windows フォーム Panel コントロールや HTML デザイナーのグリッドレイアウトコントロールなど、他のグラフィカルオブジェクト用のコンテナーが用意されています。 エディターに他のグラフィカルオブジェクト用のコンテナーが用意されている場合は、次の選択モデルをコンテナーに対してのみ使用する必要があります (コンテナー内のオブジェクトは、前に説明した標準モデルに従います)。

|入力|結果|
|-----------|------------|
|コンテナーをシングルクリックします。|含まれているオブジェクトを直接選択せずに、コンテナーオブジェクトを選択します。 コンテナーは、標準のマウスとキーボード入力で移動したり、サイズを変更したりすることができます (前述の説明を参照)。 包含オブジェクトは、コンテナーに対して移動されますが、含まれているオブジェクトは、直接選択されている場合を除き、サイズ変更されません。|
|コンテナーの境界領域の上にマウスポインターを移動します。|マウスを移動カーソルに移動し、コンテナーを移動できることを示します。|
|コンテナーの境界領域をドラッグします|マウスを移動カーソルに変更し、コンテナー (およびその中に格納されているオブジェクト) を移動します。 1回のクリックで最初に選択しないと、コンテナーを移動できません。|
|コンテナー内のオブジェクトをシングルクリックします。|コンテナーを選択解除し (選択されている場合)、クリックしたオブジェクトのみを選択します。|
|Shift キーを押しながらクリックするか、Ctrl キーを押しながら、含まれているオブジェクトやコンテナーをクリックします。|クリックされたオブジェクトを既存の選択グループまたは選択グループに追加します。 クリックされたオブジェクトが既に選択グループのメンバーである場合は、選択グループから削除されます。|

 含まれているオブジェクトは、前のセクションで説明した基本的な選択モデルに準拠している必要があります。 Windows フォームデザイナーのユーザビリティテストでは、ユーザーは、(コンテインメントオブジェクトによって設定される) ステップを介在させずに、含まれているオブジェクトにシームレスにアクセスすることを期待していました。

#### <a name="disjoint-and-region-selections"></a>不整合と領域の選択
 グラフィカルオブジェクトエディターでは、選択範囲の不整合をサポートする必要があります。 この図には、Visual Studio のコントロールの外観が表示されないことに注意してください。 視覚的仕様の詳細については、「 [グラフィカルオブジェクトの選択の外観](../../extensibility/ux-guidelines/composite-patterns-for-visual-studio.md#BKMK_GraphicalObjectSelectionAppearance) 」を参照してください。

 ![非結合セレクターと領域セレクター](../../extensibility/ux-guidelines/media/0713-07_disjointregionselectors.png "0713-07_DisjointRegionSelectors")

 **不整合の選択**

 グラフィカルエディターでは、マーキー型選択インジケーターで領域を選択する必要もあります。 グラフィカルエディターで他のオブジェクトの種類 (テキストなど) がサポートされている場合、その他のオブジェクトの種類の制約によっては、領域の選択が不可能になることがあります。

 ![マーキーの選択](../../extensibility/ux-guidelines/media/0713-08_marqueeselection.png "0713-08_MarqueeSelection")

 **マーキーの選択**

#### <a name="primary-and-secondary-selections"></a>プライマリとセカンダリの選択
 一部のグラフィカルオブジェクトエディターでは、ユーザーはグループ内のオブジェクトを編集または整列できます。 この場合、プライマリとセカンダリの選択の概念を導入する必要があります。 プライマリ選択は、他のすべてのオブジェクトがグループ操作に応答するオブジェクトです。 ユーザーが最初に選択したオブジェクトがプライマリコントロールになり、それ以降の選択がセカンダリの選択になります。 プライマリ選択は、プライマリのオブジェクトを示すために、2次的に選択した場合とは異なる視覚扱いになります。

 ![プライマリとセカンダリ選択](../../extensibility/ux-guidelines/media/0713-09_primarysecondary.png "0713-09_PrimarySecondary")

 **2つのセカンダリ選択によるプライマリ選択**

#### <a name="graphical-object-selection-appearance"></a><a name="BKMK_GraphicalObjectSelectionAppearance"></a> グラフィカルオブジェクトの選択の外観
 選択ハンドルは、オブジェクトの境界ボックスを囲む四角形パターンで描画された四角形です。 次の表は、グラフィカルオブジェクトがハンドル、サイズ変更、および埋め込み先編集の外観を持つことができるさまざまな状態の例を示しています。 ハンドルのサイズは、 **GetSystemMetrics** API を使用してウィンドウの境界線とエッジメトリックに関連付けられている必要があります。

| State | 外観 | ビジュアルの詳細 |
|-------------------------|---------------| - |
| **未選択** | Default | ![既定のボタンの状態](../../extensibility/ux-guidelines/media/0713-10_defaultstate.png "0713-10_DefaultState") |
| **プライマリの選択** | サイズ | ![サイズ変更ハンドルを使ったプライマリ選択](../../extensibility/ux-guidelines/media/0713-11_primaryresize.png "0713-11_PrimaryResize") |
| **プライマリの選択** | サイズ変更不可 | ![サイズ変更ハンドルを使わないプライマリ選択](../../extensibility/ux-guidelines/media/0713-13_primarynoresize.png "0713-13_PrimaryNoResize") |
| **プライマリの選択** | ロック | ![ロックされたプライマリ選択](../../extensibility/ux-guidelines/media/0713-15_primarylocked.png "0713-15_PrimaryLocked") |
| **2番目の選択** | サイズ | ![サイズ変更ハンドルを使ったセカンダリ選択](../../extensibility/ux-guidelines/media/0713-17_secondaryresize.png "0713-17_SecondaryResize") |
| **2番目の選択** | サイズ変更不可 | ![サイズ変更ハンドルを使わないセカンダリ選択](../../extensibility/ux-guidelines/media/0713-19_secondarynoresize.png "0713-19_SecondaryNoResize") |
| **2番目の選択** | ロック | ![ロックされたセカンダリ選択](../../extensibility/ux-guidelines/media/0713-21_secondarylocked.png "0713-21_SecondaryLocked") |
| **アクティブな UI** | Default | ![UI のアクティブな状態](../../extensibility/ux-guidelines/media/0713-23_uiactive.png "0713-23_UIActive") |

### <a name="view-selection-models"></a>選択モデルの表示

#### <a name="tree-view"></a>ツリー構造
 ツリービューでの選択は、単純な強調表示で表示されます。 ユーザーがノード名またはノードアイコンをクリックすると、ノードが選択された状態になります。 ノードの左側にある三角形のグリフは、ツリーコントロールを展開または縮小しますが、ユーザーの選択には影響しません。ただし、1つの例外として、選択がノードの子にあるときに親ノードを折りたたむと、選択項目が親に移動します。

 ![Visual Studio での一般的なツリー ビュー](../../extensibility/ux-guidelines/media/0713-25_treeview.png "0713-25_TreeView")

 **Visual Studio での一般的なツリー ビュー**

 ツリービューでは、ツリー内の複数のレベルにまたがっても、連続した選択と非結合の選択をサポートできます。 隣接する、または結合されていない複数選択は、ツリーノードが表示されている必要があります。 ノードが折りたたまれている場合、不整合の選択は失われ、折りたたまれたノードが選択範囲を取得します。 この方法では、操作の影響を受けるノードをユーザーが確認できます。 ノードが折りたたまれると、影響を受けるノードが不明確になります。

 親ノードが選択されている場合は、操作を親に適用する必要がありますが、操作が親とそのすべての子に適用されることが理にかなっている場合もあります。 この場合は、操作中に追加の UI を提供します。たとえば、チェックボックスや確認ダイアログなどを使用して、"すべての子に適用" オプションを明示的にユーザーに設定します。

##### <a name="renaming"></a>名前の変更
 ツリー内のノードの名前の変更がサポートされている場合は、名前の変更を行う必要があります。 インプレース操作は、Visual Studio のすべてのツリーコントロールにおいて標準である必要があります。 [名前の変更] コマンドを使用して、埋め込み先編集モードを直ちにアクティブにします。テキスト選択では、ノードの名前全体をカバーし、ユーザー入力を受け入れる準備ができています。 ノードがファイルを表している場合は、ファイル名に拡張子が含まれている必要があります。 選択項目の強調表示には、拡張子ではなく、ファイル名の本文のみを含める必要があります。

|入力|結果|
|-----------|------------|
|Enter キー|名前変更操作をコミットします。|
|Esc キー|名前の変更操作を取り消します。|
|埋め込み先の編集領域の外側をクリックする|名前変更操作をコミットします。|
|元に戻す|名前の変更操作を取り消すには、簡単に元に戻す機能を提供します|

#### <a name="selection-within-lists-and-grid-controls"></a>リストとグリッドコントロール内の選択
 リストの選択における重要な概念は、行ベースであることです。つまり、選択が行われると、行全体が1つの単位として選択されます。 これに対し、グリッドでは、行の他の側面に影響を与えることなく、特定のセルを選択できます。 また、グリッドには入れ子になった行の階層 (TreeGrid など) が含まれている場合もあります。これにより、親の行と対話することによって、階層のすべての分岐を選択および選択解除できます。 リスト内の選択は、データ行全体の単純な強調表示色で表示されます。 フォーカスは、現在の編集可能な行またはセル (すべてのセルが読み取り専用の場合は行) を囲む1ピクセルの点線の境界線で表示されます。

> [!NOTE]
> **フォーカス** と **選択** の概念は異なります。 *フォーカス* は、他のオブジェクトで明示的に指定されていない入力の受信を対象とする UI 要素を示します。一方、 *選択* は、後続の操作が行われるオブジェクトのセットに含まれるオブジェクトの状態を指します。

 リストでの選択は、連続、非結合、または領域にすることができます。 複数の選択が許可されている場合、隣接する選択と非結合の選択は常にサポートされますが、地域 (box) の選択は省略可能です。 領域の選択は、リスト本文の空白部分をドラッグすることによって開始されます。

| Object | 選択 |
|--------|------------|
| List | 連続 |
| List | 不整合 |
| List | リージョン |

 一覧で [1 回] をクリックすると、クリックが発生した行が選択されます。 埋め込み先編集がサポートされているリストセル内でユーザーがクリックした場合は、そのセルも埋め込み先編集のためにすぐにアクティブになります。 それ以外の場合は、行全体がすぐに選択され、強調表示されます。

 リスト本文内をドラッグすると、次の3つのいずれかの処理が行われます。

- リストでサポートされていて、マウスの下に空白がある場合に、領域の選択を開始します

- リストのセルまたは行がドラッグ元になることがサポートされている場合、ドラッグアンドドロップ操作を開始します

- 現在の行を選択します

##### <a name="in-place-editing"></a>インプレース編集
 インプレース編集が許可されている場合、単純な編集コントロールとプロパティピッカーの2つの基本的なモデルがあります。 単純な編集コントロールを使用すると、埋め込み先編集がアクティブになるとすぐに、コンテンツが強調表示され、ユーザー入力の準備が整います。 プロパティピッカーが実装されている場合、埋め込み先編集モードがアクティブ化され、現在の選択範囲が強調表示されていないと、プロパティピッカーを呼び出すボタンが表示されます。 選択ボタンは、セル内で右揃えにする必要があります。 インプレース編集の例については、Visual Studio の [ **プロパティ] ウィンドウ** と **タスク一覧** を参照してください。

##### <a name="keyboard-support"></a>キーボードのサポート
 リストおよびグリッドでの選択に対するキーボードのサポートは、標準の Windows 規則に従います。

- 方向キーフォーカスが移動されるたびに各行またはセルを選択して、一覧内を移動します。

- Shift + 方向キーを押すと、方向キーの方向に連続する選択が実行されます。

- Ctrl + 矢印の後に Space キーを押すと、選択範囲からリスト項目の追加と削除が切り替わり、非結合の選択が作成されます。

- 入れ子になった階層を含むグリッドの場合、→キーを使用すると親行が展開され、←キーは1を折りたたみます。

- Tab キーを押すと、セルが編集可能な場合、現在の行のセル間でフォーカスが移動します。

- Enter キーは、リスト内の項目に対して既定のコマンドを実行します (多くの場合は **開い** ています)。

- F2 キーを押すと、現在選択されているセルの埋め込み先編集が有効になります。

## <a name="persistence-and-saving-settings"></a><a name="BKMK_PersistenceAndSavingSettings"></a> 永続化と設定の保存

### <a name="overview"></a>概要
 通常、Visual Studio の各ソフトウェアコンポーネントが独自の状態と永続化を担当しますが、Visual Studio では、ウィンドウのサイズや位置など、一部の場合に設定が自動的に保存されます。 次の表は、自動的に保存される設定と、明示的なユーザーまたはプログラムによって実行されるアクションを必要とする設定の組み合わせを示しています。

|Object|保存する内容|セーブするタイミング|保存する場所|
|------------|------------------|------------------|-------------------|
|選択可能なオブジェクト (たとえば、コード行)|コード行のブレークポイント<br /><br /> コード行に関連付けられているユーザーショートカット|プロジェクトが保存されたとき|プロジェクトの **ユーザーオプション (.suo)** ファイル|
|ダイアログ|ダイアログの場所 (移動された場合)<br /><br /> ユーザーがダイアログで最後に使用したビュー|ダイアログが閉じたとき<br /><br /> Visual Studio セッションが終了したとき|メモリ内<br /><br /> **HKEY_Current_User** のレジストリ|
|ウィンドウ|ウィンドウのサイズと場所|ウィンドウが閉じるとき<br /><br /> Visual Studio モードが変更されたとき<br /><br /> Visual Studio セッションが終了したとき|プロジェクトの **ユーザーオプション (.suo)** ファイル<br /><br /> ウィンドウ設定のカスタムオプションファイル|
|マニュアル名の正式名称|ドキュメント内の現在の選択項目<br /><br /> ドキュメントのビュー<br /><br /> ユーザーが最後にアクセスした場所|ドキュメントが保存されたとき|プロジェクトの **ユーザーオプション (.suo)** ファイル|
|Project|ファイルへの参照<br /><br /> ディスク上のディレクトリへの参照<br /><br /> その他のソフトウェアへの参照<br /><br /> Components<br /><br /> プロジェクト自体に関する状態情報|プロジェクトが保存されたとき|プロジェクト ファイル|
|解決策|プロジェクトへの参照<br /><br /> ファイルへの参照|プロジェクトまたはソリューションが保存されたとき|**ソリューション (.sln)** ファイル|
|**ツール > オプション** の設定|キーボードのカスタマイズ<br /><br /> ツールバーのカスタマイズ<br /><br /> 配色|[ **ツール > オプション** ] ダイアログを閉じるとき<br /><br /> Visual Studio セッションが終了したとき|**HKEY_Current_User** のレジストリ|

 ユーザーが実行している操作とその実行時には、設定が (セッション中に) メモリに保存されているか、ディスクに保存されているか (レジストリ設定として)、 **ソリューションオプション (.suo)** ファイルの一部として、またはソフトウェアコンポーネントのみが認識しているカスタム設定ファイルとして指定されます。 上の表は、設定を保存できるいくつかのイベントを示しています。 ただし、次のような状況では、状態を保存することが必要になる場合があります。

- ユーザーがダイアログまたはウィンドウ内の場所を変更したとき

- ユーザーが別のウィンドウにフォーカスを移すとき

- ユーザーがデザインからデバッグモードに切り替えたとき

- ユーザーがアカウントからログオフしたとき

- コンピューターが休止状態またはシャットダウンしたとき

- コンピューター/ハードドライブの再フォーマットと再設定が実行されようとしているとき

### <a name="window-configurations"></a>ウィンドウ構成
 ウィンドウ構成は、開発環境の基本的な表現であり、ツールウィンドウの一覧とその配置方法で構成されるスキームです。 IDE で管理されているウィンドウ (IDE ウィンドウ) では、レイアウト情報はユーザーごとに保持されるため、ユーザーが IDE を起動すると、ウィンドウレイアウトは Visual Studio を最後に終了したときと同じように表示されます。 IDE ウィンドウの状態と位置は、カスタムオプションファイルに XML 形式で保存されます。 IDE に読み込まれたパッケージによって作成されたツールウィンドウは、状態情報をレジストリに保持します。また、ユーザーごとに使用することもできます。

#### <a name="profile-specific-layouts"></a>プロファイル固有のレイアウト
 各プロファイルには、ツールウィンドウのレイアウトが含まれています。これは、特定の開発者のペルソナになじみのある方法で整理されています (Visual C++ 開発者は IDE の左側に **ソリューションエクスプローラー** を表示しますが、C# 開発者は右側に **ソリューションエクスプローラー** を表示します)。 プロファイル固有のウィンドウレイアウトは、ユーザーが起動時にプロファイルを選択した後に読み込まれます。 パッケージの作成者は、ユーザーがウィンドウの構成に対して行った変更が保持されることを把握して、顧客のエクスペリエンスに最も適したウィンドウのレイアウトを決定する必要があります。

## <a name="touch-input"></a><a name="BKMK_TouchInput"></a> タッチ入力
 ユーザーはタッチデバイスで Microsoft 開発製品を使用することが増えています。 ただし、タッチデバイスで開発ツールを使用するのが困難な障壁があります。 ユーザーは、製品の信頼性と詳細なタッチエクスペリエンスを提供することを期待しています。 これらのガイドラインの目的は、どのタッチ機能を組み込むかを決定し、Visual Studio と関連製品の間で一貫性のあるタッチエクスペリエンスを奨励することです。

### <a name="levels-of-experience"></a>エクスペリエンスのレベル
 次の経験レベルは、お客様が必要な投資レベルのタッチに基づいてどのタッチ機能を提供するかを決定するためのガイドとして使用することを目的としています。

- **基本的なエクスペリエンス** は、タッチ機能を提供したいチームを対象としています。そのため、作業全体に停止することはありません。

- 最適化された **エクスペリエンス** は、最も一般的なタッチ機能 (たとえば、インターネットブラウザーアプリケーションで一般に使用可能) を提供するチーム向けです。

- **高度なエクスペリエンス** は、ジェスチャなどの機能や、アプリケーションをタッチファーストで表示できるようにするその他のオプション機能を追加するチーム向けです。

||基本的なエクスペリエンス|最適化されたエクスペリエンス|高度なエクスペリエンス|
|-|----------------------|--------------------------|-------------------------|
|**ユーザーは...**|停止しないでコードとソリューション/プロジェクトレベルの読み取りを修正する|メンテナンス、リファクタ、ナビゲーションの各タスクを実行する|自信を持って、一貫性のある直感的で滑らかな環境で動作|
|**[エディター]**|タッチパンと選択<br /><br /> スクロールバーにタッチして、押しながらドラッグします|ピンチズーム<br /><br /> 高速スクロール<br /><br /> 選択<br /><br /> ショートカットメニューを使いやすく||
|**トップツールウィンドウ**|リストのパン<br /><br /> 項目の選択<br /><br /> スクロールバーにタッチして、押しながらドラッグします|簡単な項目のスクロールと選択||
|**ウィンドウ化**||ウィンドウのサイズ変更<br /><br /> クイック アクセス||
|**ドキュメントウェル**||開いているファイル間を簡単に移動||
|**ジェスチャ**||IDE で共通のジェスチャが動作することを確認する|ジェスチャベースのアクション<br /><br /> ドラッグアンドドロップとデザイナーのサポート|
|**その他の考慮事項**|||カスタムスクリーンキーボード|

#### <a name="gestures"></a>ジェスチャ
 ジェスチャは、より複雑な対話を必要とする可能性のあるコマンドへのショートカットをユーザーに提供します。 [デスクトップアプリケーションの一般的なタッチジェスチャ](/windows/desktop/wintouch/windows-touch-gestures-overview)に関する Windows のガイドラインを参照し、パンやズームなどの単純なジェスチャを含むほとんどのジェスチャについては、こちらのガイダンスに従ってください。
