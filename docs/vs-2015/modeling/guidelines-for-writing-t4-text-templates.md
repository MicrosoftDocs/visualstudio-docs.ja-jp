---
title: T4 テキスト テンプレートの記述に関するガイドライン |Microsoft Docs
ms.custom: ''
ms.date: 11/15/2016
ms.prod: visual-studio-tfs-dev14
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 04dd3fc4-10e8-488a-bdea-4d615f50f063
caps.latest.revision: 11
author: gewarren
ms.author: gewarren
manager: douge
ms.openlocfilehash: f4d0b435544ffd77292e8cad217247733cac4075
ms.sourcegitcommit: 9ceaf69568d61023868ced59108ae4dd46f720ab
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/12/2018
ms.locfileid: "49272234"
---
# <a name="guidelines-for-writing-t4-text-templates"></a>T4 テキスト テンプレートの記述に関するガイドライン
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

これらの一般的なガイドラインをプログラム コードまたはその他のアプリケーション リソースを生成している場合に役立つことがあります[!INCLUDE[vsprvs](../includes/vsprvs-md.md)]します。 ルールが修正されません。  
  
## <a name="guidelines-for-design-time-t4-templates"></a>デザイン時 T4 テンプレートのガイドライン  
 デザイン時 T4 テンプレートでのコードを生成するテンプレート、[!INCLUDE[vsprvs](../includes/vsprvs-md.md)]デザイン時にプロジェクト。 詳細については、次を参照してください。 [T4 テキスト テンプレートを使用したデザイン時コード生成](../modeling/design-time-code-generation-by-using-t4-text-templates.md)します。  
  
 アプリケーションの可変部分を生成します。  
 コード生成は、プロジェクトの中に変わる可能性がありますか、アプリケーションの異なるバージョン間で変化するアプリケーションのこれらの要素に対して最も役立ちます。 生成する必要のあるものをより簡単に確認できるように、不変的な部分からこれらの可変部分を分離します。 たとえば、アプリケーションでは、Web サイトを提供する場合は、関数を 1 つのページから別のナビゲーション パスを定義するロジックを提供している標準的なページを区切ります。  
  
 ソース モデルの 1 つまたは複数の可変部分をエンコードします。  
 モデルは、ファイルまたは各テンプレートの読み取りが生成されるコードの変数部分を特定の値を取得するデータベースです。 モデルには、データベース、デザイン、図、またはドメイン固有言語の XML ファイルを指定できます。 多くのファイルを生成する 1 つのモデルを使用する、通常、[!INCLUDE[vsprvs](../includes/vsprvs-md.md)]プロジェクト。 各ファイルは、別のテンプレートから生成されます。  
  
 プロジェクトでは、1 つ以上のモデルを使用できます。 たとえば、Web ページ、およびページのレイアウトの別のモデル間のナビゲーションのためのモデルを定義する可能性があります。  
  
 ユーザーのニーズとボキャブラリを実装ではなく、モデルの焦点を当てます。  
 たとえば、Web サイトのアプリケーションで期待するモデルを Web ページとハイパーリンクを参照してください。  
  
 理想的には、モデルを表す情報の種類に合ったプレゼンテーションのフォームを選択します。 たとえば、Web サイトを通じてナビゲーション パスのモデルでは、ボックスと矢印のダイアグラム可能性があります。  
  
 生成されたコードをテストします。  
 結果のコードが必要のあるユーザーとして動作することを確認するのにには、手動または自動テストを使用します。 コードの生成元となる、同じモデルからテストが生成されないようにします。  
  
 場合によっては、一般的なテストはモデルに直接します。 たとえば、Web サイト内の各ページに、他のナビゲーションによってアクセスできることにより、テストを作成します。  
  
 カスタム コードを許可する: 部分クラスを生成します。  
 記述するコードを手動でさらに、生成されたコードを許可します。 生じる可能性のあるすべてのバリエーションを考慮することができるコード生成設定の一般的なことはできません。 そのため、生成されたコードの一部を上書きまたは追加するはずです。 生成されたマテリアルが .NET 言語でなど[!INCLUDE[csprcs](../includes/csprcs-md.md)]または[!INCLUDE[vbprvb](../includes/vbprvb-md.md)]、2 つの戦略は特に便利です。  
  
-   生成されたクラスは、部分的な必要があります。 これにより、生成されたコードにコンテンツを追加できます。  
  
-   クラスは、継承、他の 1 つのペアで生成する必要があります。 基本クラスはすべて、生成されるメソッドとプロパティを含める必要があり、派生クラスでコンス トラクターのみを含める必要があります。 これにより、手作業で記述されたコードに生成されたメソッドをオーバーライドできます。  
  
 XML など生成された他の言語を使用して、`<#@include#>`ディレクティブを手作業で記述されたと生成されたコンテンツを単純に結合します。 複雑な場合は、生成されたファイルを手作業で記述されたファイルに結合する処理後の手順を記述する必要があります。  
  
 一般的な素材をインクルード ファイルまたは実行時テンプレートに移動します。  
 テキストと複数のテンプレートにコードのようなブロックを繰り返しを避けるため、使用、`<#@ include #>`ディレクティブ。 詳細については、次を参照してください。 [T4 Include ディレクティブ](../modeling/t4-include-directive.md)します。  
  
 また別のプロジェクトでの実行時テキスト テンプレートをビルドし、デザイン時テンプレートから呼び出してできます。 これを行うには、使用、`<#@ assembly #>`個別のプロジェクトにアクセスするディレクティブ。 例については、次を参照してください。 ["継承でテキスト テンプレート"Gareth Jones のブログで](http://go.microsoft.com/fwlink/?LinkId=208373)します。  
  
 別のアセンブリに大量のコードの移動を検討してください。  
 大規模なコード ブロックおよびクラス機能ブロックがある場合は、このコードの一部を別のプロジェクトをコンパイルするメソッドに移動すると便利ですが考えられます。 使用することができます、`<#@ assembly #>`ディレクティブがテンプレートのコードにアクセスします。 詳細については、次を参照してください。 [T4 アセンブリ ディレクティブ](../modeling/t4-assembly-directive.md)します。  
  
 メソッドは、テンプレートが継承できる抽象クラスを格納できます。 抽象クラスを継承する必要があります<xref:Microsoft.VisualStudio.TextTemplating.TextTransformation?displayProperty=fullName>します。 詳細については、次を参照してください。 [T4 テンプレート ディレクティブ](../modeling/t4-template-directive.md)します。  
  
 構成ファイルではなく、コードを生成します。  
 変数のアプリケーションの作成方法の 1 つでは、構成ファイルを受け入れる汎用プログラム コードを作成します。 この方法で記述されたアプリケーションは、非常に柔軟なアプリケーションをリビルドすることがなく、ビジネス要件を変更するときに再構成することができます。 ただし、この方法の欠点は、アプリケーションが特定のアプリケーションよりも適切に機能しないを実行することに。 またがある常にほとんどのジェネリック型を処理するため、部分的、プログラム コードは読み取りおよび、メンテナンスが難しくなります。  
  
 これに対し、アプリケーションをコンパイルする前に生成される可変部分が厳密に入力できます。 これにより、ソフトウェアのはるかに簡単かつを手作業で記述されたコードを記述し、生成されたと統合してより信頼性の高い部分。  
  
 完全なコード生成の利点を取得するには、構成ファイルではなく、プログラム コードを生成してみてください。  
  
 生成されたコード フォルダーを使用します。  
 という名前のプロジェクト フォルダーで、テンプレートと、生成されたファイルを配置**生成されたコード**ようにするには、直接編集する必要がありますファイルではないことをオフにします。 生成されたクラスを追加またはオーバーライドするカスタム コードを作成する場合は、という名前のフォルダーにそれらのクラスを配置**カスタム コード**します。 一般的なプロジェクトの構造のようになります。  
  
```  
MyProject  
   Custom Code  
      Class1.cs  
      Class2.cs  
   Generated Code  
      Class1.tt  
          Class1.cs  
      Class2.tt  
          Class2.cs  
   AnotherClass.cs  
  
```  
  
## <a name="guidelines-for-run-time-preprocessed-t4-templates"></a>実行時 (前処理された) T4 テンプレートのガイドライン  
 継承されたテンプレートに一般的な素材を移動します。  
 継承を使用して、メソッドと T4 テキスト テンプレート間のテキスト ブロックを共有することができます。 詳細については、次を参照してください。 [T4 テンプレート ディレクティブ](../modeling/t4-template-directive.md)します。  
  
 使用することもできますが、ランタイム テンプレート ファイルを含めます。  
  
 部分クラスには、大量のコードを移動します。  
 各実行時テンプレートは、テンプレートと同じ名前を持つ部分クラス定義を生成します。 同じクラスの別の部分定義を含むコード ファイルを記述することができます。 この方法でクラスには、メソッド、フィールド、およびコンス トラクターを追加できます。 これらのメンバーは、テンプレート内のコード ブロックから呼び出すことができます。  
  
 これを行う利点は、IntelliSense は使用可能なため、コードが記述するには簡単です。 また、プレゼンテーションと基になるロジックの間の優れた分離を実現できます。  
  
 たとえば、 **MyReportText.tt**:  
  
 `The total is: <#= ComputeTotal() #>`  
  
 **MyReportText Methods.cs**:  
  
 `private string ComputeTotal() { ... }`  
  
 カスタム コードを許可する: 拡張機能ポイントを提供  
 仮想メソッドの生成を検討\<#+ クラス機能ブロックの #>。 これにより、1 つのテンプレートを変更しなくてもさまざまなコンテキストで使用できます。 テンプレートを変更する代わりに、最小の追加のロジックを提供する派生クラスを構築できます。 派生クラスは、正規表現のどちらかのコードを指定できますか、実行時テンプレートであることができます。  
  
 たとえば、MyStandardRunTimeTemplate.tt: で  
  
```  
This page is copyright <#= CompanyName() #>.  
<#+ protected virtual string CompanyName() { return ""; } #>  
```  
  
 アプリケーションのコード。  
  
```  
class FabrikamTemplate : MyStandardRunTimeTemplate  
{  
  protected override string CompanyName() { return "Fabrikam"; }  
}  
...  
  string PageToDisplay = new FabrikamTemplate().TextTransform();  
  
```  
  
## <a name="guidelines-for-all-t4-templates"></a>すべての T4 テンプレートに関するガイドライン  
 テキスト生成から別のデータ収集  
 計算とテキスト ブロックの混在を回避しようとしてください。 各テキスト テンプレート内で 1 つ目を使用して、 \<# コード ブロックの #> を変数を設定し、複雑な計算を実行します。 テンプレートまたは 1 つ目の末尾までの最初のテキスト ブロックから\<#+ クラス機能ブロックの #> 長い式を避けるため、テキスト ブロックがない限り、ループや条件を回避します。 この実習では、テンプレートが読み取りおよびメンテナンス簡単です。  
  
 使用しない`.tt`インクルード ファイル  
 別のファイル名拡張子を使用して`.ttinclude`インクルード ファイル。 使用`.tt`させるファイルと実行時またはデザイン時テキスト テンプレートを処理するだけです。 場合によっては、[!INCLUDE[vsprvs](../includes/vsprvs-md.md)]認識`.tt`ファイルし、自動的に処理するためには、そのプロパティを設定します。  
  
 固定のプロトタイプとしては、各テンプレートを開始します。  
 生成して、これが正しいことを確認するコードまたはテキストの例を記述します。 その拡張子を .tt に変更し、段階的モデルを読み取ることによって、コンテンツを変更するコードを挿入します。  
  
 型指定されたモデルの使用を検討してください。  
 XML またはデータベースのスキーマを作成するには、モデルの場合は、ドメイン固有言語 (DSL) を作成する便利な場合があります。 DSL には、スキーマ、および属性を表すプロパティ内の各ノードを表すクラスが生成されるという利点があります。 これは、ビジネス モデルの観点から、プログラムできることを意味します。 例えば:  
  
```  
Team Members:  
<# foreach (Person p in team.Members)   
 { #>   
    <#= p.Name #>   
<# } #>  
```  
  
 モデルの図の使用を検討してください。  
 多くのモデルが最も効果的に表示されは非常に大きい場合に特にテキスト テーブル、単純として管理されています。  
  
 ただし、ビジネス要件の一部の種類のリレーションシップと、ワークフローの複雑なセットを明確にすることが重要と図は、最も適していますメディア。 ダイアグラムの利点は、ユーザーとその他の利害関係者と話し合うには簡単であります。 ビジネス要件のレベルでのモデルからコードを生成してコードを作成より柔軟な要件を変更するときにします。  
  
 UML クラスとアクティビティ図はこれらの目的によっては適合がよくあることができます。 ドメイン固有言語 (DSL) としての図の独自の型を設計することもできます。 UML および Dsl の両方からコードを生成できます。 詳細については、次を参照してください。[の分析とアーキテクチャのモデリング](../modeling/analyze-and-model-your-architecture.md)と[の分析とアーキテクチャのモデリング](../modeling/analyze-and-model-your-architecture.md)します。  
  
## <a name="see-also"></a>関連項目  
 [T4 テキスト テンプレートを使用したデザイン時コード生成](../modeling/design-time-code-generation-by-using-t4-text-templates.md)   
 [T4 テキスト テンプレートを使用した実行時テキスト生成](../modeling/run-time-text-generation-with-t4-text-templates.md)



