---
title: 'UML アクティビティ図: ガイドライン |Microsoft Docs'
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-modeling
ms.topic: conceptual
helpviewer_keywords:
- UML diagrams, activity
- diagrams - modeling, activity
- diagrams - modeling, UML activity
- activity diagrams
- UML, activity diagrams
ms.assetid: fe5dbe96-79ab-483a-b9bc-44d0d1d3efc2
caps.latest.revision: 50
author: jillre
ms.author: jillfra
manager: jillfra
ms.openlocfilehash: abcc83a301553ee0c6141502c25903ef2153258b
ms.sourcegitcommit: a8e8f4bd5d508da34bbe9f2d4d9fa94da0539de0
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/19/2019
ms.locfileid: "72658483"
---
# <a name="uml-activity-diagrams-guidelines"></a>UML アクティビティ図: ガイドライン
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Visual Studio では、アクティビティ図を描画することによって、ビジネス プロセスやソフトウェア アルゴリズムを一連のアクションのワークフローとして表すことができます。 ユーザー、ソフトウェア コンポーネント、またはデバイスが、これらのアクションを実行できます。 ビデオデモについては、「[アクティビティ図を使用したビジネスワークフローのキャプチャ](http://channel9.msdn.com/posts/clinted/UML-with-VS-2010-Part-4-Capture-Business-Workflows/)」を参照してください。

 この機能をサポートする Visual Studio のバージョンを確認するには、「 [Version support for architecture and modeling tools](../modeling/what-s-new-for-design-in-visual-studio.md#VersionSupport)」を参照してください。

 UML アクティビティ図を作成するには、 **[アーキテクチャ]** メニューの **[新しい Uml またはレイヤー図]** をクリックします。

 アクティビティ図は、以下のようなさまざまな目的に使用できます。

- ビジネス プロセス、またはユーザーとシステム間のワークフローを示す。 詳細については、「[ユーザー要件のモデル](../modeling/model-user-requirements.md)化」を参照してください。

- ユース ケースで実行される手順を示す。 詳細については、「 [UML ユースケース図: ガイドライン](../modeling/uml-use-case-diagrams-guidelines.md)」を参照してください。

- ソフトウェアでのメソッド、関数、または操作を示す。 詳細については、「[アプリのアーキテクチャのモデル](../modeling/model-your-app-s-architecture.md)化」を参照してください。

  アクティビティ図を描画することは、プロセスの改善につながります。 既存のプロセスの図が非常に複雑であることが分かったら、どのようにすればプロセスを単純化できるかを検討してください。

  アクティビティ図の要素に関するリファレンス情報については、「 [UML アクティビティ図: リファレンス](../modeling/uml-activity-diagrams-reference.md)」を参照してください。

## <a name="Relationships"></a>他の図との関係
 ビジネス プロセス、またはユーザーがシステムを使用する方法を表すアクティビティ図を描画する場合は、ユース ケース図を描画することにより、同じ情報を異なる観点で示すことができます。 ユース ケース図では、アクションをユース ケースとして描画します。 ユース ケースには、対応するアクションと同じ名前を付けます。 ユース ケース ビューのメリットは、次の操作ができることです。

- 大規模なアクション/ユース ケースが、小規模なアクション/ユース ケースでどのように構成されるかを、Includes リレーションシップを使用して 1 つの図で示す。

- 各アクション/ユース ケースを、その実行に関連するユーザーまたは外部システムに明示的に接続する。

- システムまたはその各主要コンポーネントでサポートされているアクション/ユース ケースの周囲に境界線を描画する。

  アクティビティ図を描画することにより、ソフトウェア操作の詳細設計を示すこともできます。

  アクティビティ図では、アクション間で渡されるデータのフローを示すことができます。 [データフローの説明](#DataFlows)については、「」セクションを参照してください。 ただし、アクティビティ図はデータの構造を表すわけではありません。 そのためには、UML クラス図を描画します。 詳細については、「 [UML クラス図: ガイドライン](../modeling/uml-class-diagrams-guidelines.md)」を参照してください。

## <a name="BasicSteps"></a>アクティビティ図を描画するための基本的な手順
 モデリング図を作成するための詳細な手順については、「 [UML モデルとダイアグラムの編集](../modeling/edit-uml-models-and-diagrams.md)」を参照してください。

#### <a name="to-draw-an-activity-diagram"></a>アクティビティ図を描画するには

1. **[アーキテクチャ]** メニューの **[新しい UML またはレイヤー図]** をクリックします。

2. **[テンプレート]** の **[UML アクティビティ図]** をクリックします。

3. 図に名前を付けます。

4. **[モデリングプロジェクトへの追加]** で、ソリューション内の既存のモデリングプロジェクトを選択するか、**新しいモデリングプロジェクトを作成**します。

#### <a name="to-draw-elements-on-an-activity-diagram"></a>アクティビティ図の要素を描画するには、次のようにします。

1. ツールボックスから図へ要素をドラッグします。

     まず、図にメイン アクティビティを配置し、それらを接続した後、開始ノードや終了ノードなどの最後の仕上げを追加します。

    > [!NOTE]
    > UML モデル エクスプローラーから図へ既存の要素をドラッグすることはできません。

2. 要素を接続するには、次の手順に従います。

    1. **アクティビティダイアグラム**ツールボックスで、 **[コネクタ]** をクリックします。

    2. 図で、ソース要素をクリックします。

    3. ターゲット要素をクリックします。

        > [!NOTE]
        > ツールを複数回使用するには、ツールボックス内のツールをダブルクリックします。

#### <a name="to-move-an-activity-to-another-package"></a>アクティビティを別のパッケージに移動するには、次のようにします。

- **UML モデルエクスプローラー**で、アクティビティをパッケージにドラッグします。

     \- または

- **UML モデルエクスプローラー**で、アクティビティを右クリックし、 **[切り取り]** をクリックします。 次に、パッケージを右クリックし、 **[貼り付け]** をクリックします。

    > [!NOTE]
    > アクティビティが UML モデル エクスプローラーに表示されるのは、最初の要素を図に追加するときのみです。

## <a name="SimpleControlFlow"></a>制御フローの記述
 アクティビティ図は、ビジネス プロセスまたはソフトウェア アルゴリズムを一連のアクションとして表します。 コネクタの矢印は、あるアクションから次のアクションにどのように制御が連続的に渡されるかを示します。 通常、アクションは前のアクションが完了した後でなければ開始できません。

 次の図は、アクションのシーケンスをアクション、コネクタ、分岐、およびループでどのように示すことができるかという例です。 各要素については、後のセクションで詳しく説明します。

 ![単純なアクティビティ図](../modeling/media/uml-actguidectrl.png "UML_ActGuideCtrl")

 アクティビティ図では、アクションと**コネクタ** **を使用し**て、システムまたはアプリケーションを一連のアクションとして記述します。この操作は、コントロールが1つのアクションから次のアクションに順次流れます。

- ユーザー、システム、またはその両方によって共同作業を行う主要なタスクごとに、**アクション**(1) を作成します。

  > [!NOTE]
  > プロセスまたはアルゴリズムをごくわずかのアクションで記述するようにしてください。 振る舞い**呼び出しアクションを使用し**て、各アクションを別の図で定義できます。詳細については、「[振る舞い呼び出しアクションを使用したサブアクティビティの記述](#Subactivities)」を参照してください。

- 各アクションのタイトルは、アクションによって通常得られることを明確に示すタイトルになるようにしてください。

- アクションを**コネクタ**(2) で順番にリンクします。

- それぞれのアクションが終了してから、制御フロー内の次のアクションが始まります。 重複するアクションを記述する場合は、「[同時実行フロー](#Concurrent)」で説明されているように**フォークノード**を使用します。

  図はアクションのシーケンスを表しますが、アクションの実行方法や、あるアクションから次のアクションへの制御の渡し方を示すわけではありません。 図を使用してビジネス プロセスを表す場合は、たとえば、あるユーザーが別のユーザーに電子メール メッセージを送信したら、制御を渡すことができます。 図を使用してソフトウェア設計を表す場合は、通常の実行フローによって、あるステートメントから次のステートメントに制御を渡すことができます。

### <a name="describing-decisions-and-loops"></a>判断とループの記述

- デシジョン**ノード**(3) を使用して、決定の結果が次の手順を示すポイントを示します。 必要な数だけ出力パスを描画できます。

- アクティビティ図を使用してアプリケーションの一部を定義する場合は、各パスがいつ必要かが明確になるように、ガード (4) を定義する必要があります。 コネクタを右クリックし、 **[プロパティ]** をクリックします。 **[プロパティ]** ウィンドウで、**ガード**フィールドの値を入力します。

- ガードを常に定義する必要はありません。 たとえば、アクティビティ図を使用してビジネス プロセスまたは相互作用プロトコルを表す場合は、ユーザーまたは相互作用コンポーネントに対してオープンなオプションの範囲を分岐で定義します。

- **マージノード**(5) を使用して、**デシジョンノード**で分岐する2つ以上の代替フローをまとめます。

    > [!NOTE]
    > 1つのアクションでフローをまとめるのではなく、**マージノード**を使用して代替フローをまとめる必要があります。 この例では、デシジョンノードから直接 **[選択] メニュー項目**に接続するのは適切ではありません。 アクションが開始されるのは、その受信コネクタに制御のスレッドが到着してからになるためです。 そのため、アクションでまとめるのは、同時実行フローのみにする必要があります。 詳細については、「[同時実行フロー](#Concurrent)」を参照してください。

- 例に示すように、分岐を使用してループを表します。

    > [!NOTE]
    > プログラム コードの場合と同様に、適切な構造でループを入れ子にしてください。 既存のビジネス プロセスを記述していくと、そのビジネス プロセスを改善できる機会がいくつか明らかになることがあります。

### <a name="starting-the-activity"></a>アクティビティの開始
 アクティビティへのエントリ ポイントを示すには、次の 2 とおりの方法があります。

- **最初のノード**

     最初の**ノード**(6) を1つ作成して、アクティビティの最初のアクションを指定します。

     この方法は、サブアクティビティを記述するときや、何がアクティビティを開始するかを明示的に示す必要がない場合に最も有用です。 たとえば、"Order a Meal" というアクティビティは、顧客が空腹になったときに明確に開始されます。

- **イベントノードの受理**

     「[同時実行フロー](#Concurrent)」で説明されているように、 **Accept イベントノード**を作成して、ユーザー入力などの特定のイベントに応答するスレッドの開始を示します。 ノードに入力フローを接続しないでください。 入力フローを省略した場合は、イベントが発生するたびにスレッドが開始されることを示します。

     この方法は、特定の外部イベントへの応答を記述するときに最も有用です。

### <a name="ending-the-activity"></a>アクティビティの終了
 アクティビティの最後の**ノード**(7) を使用して、アクティビティの終了を示します。

- 制御のスレッドが**アクティビティの最後のノード**に到達すると、すべてのアクティビティの同時実行アクションとサブアクティビティが終了します。

- アクティビティ終了ノードを複数使用することで、追加コネクタの煩雑さを軽減できます。

### <a name="interrupting-the-activity"></a>アクティビティの中断
 たとえば、ユーザーがプロセスを取り消すことにした場合、どうすればアクティビティの通常フローを中断できるかを記述するには、そのイベントをリッスンするイベント受理ノードを作成します。 詳細については、「[同時実行フロー](#Concurrent)」を参照してください。 それからアクティビティ終了ノード (7) への制御フローを作成します。

### <a name="swimlanes"></a>スイムレーン
 アクティビティのアクションを、アクションを実行する異なるオブジェクトまたはビジネス ロールに対応する領域に配置すると好都合な場合があります。 これらの領域は、従来は列に配置され、*スイムレーン*と呼ばれます。

- ツールボックスの **[単純な図形]** セクションの線または四角形を使用して、スイムレーンまたはその他の領域を描画します。

- 各スイムレーンにラベルを付けるには、コメントを作成し、その**Transparent**プロパティを**True**に設定します。

  単純なシェイプは UML モデルの一部を形成しないため、UML モデル エクスプローラーには表示されません。

## <a name="DataFlows"></a>データフローの記述
 アクティビティとの間のデータの受け渡しを、次の 2 とおりの方法のいずれかで記述できます。

- **オブジェクトノード**を使用します。 これは、アクティビティ間を流れる情報を記述する最も簡単な方法です。 オブジェクト ノードは、プログラムにおける変数のようなものです。 あるアクションから別のアクションへ渡される 1 つ以上の値を格納するものを表します。

- **出力ピン**と**入力ピン**を使用します。 この方法を使用すると、あるアクションからの出力と別のアクションへの入力を別々に記述できます。 ピンはプログラムにおけるパラメーターのようなものです。 ピンは、オブジェクトがアクションに出入りできるポートを表します。

    > [!NOTE]
    > このセクションで使用する要素の概要については、「 [UML アクティビティ図: リファレンス](../modeling/uml-activity-diagrams-reference.md)」の「データフロー」セクションを参照してください。

### <a name="describing-data-flow-with-object-nodes"></a>オブジェクト ノードを使用したデータ フローの記述
 ほとんどの制御フローはデータを運びます。 たとえば、"Customer provides details" アクションからの出力フローは、出荷先住所への参照を運びます。

 そのデータを図に記述するには、次の図に示すように、コネクタを 1 つのオブジェクト ノードと 2 つのコネクタに置き換えます。

 ![オブジェクトノードはアクション間で渡されるデータを表示できます](../modeling/media/uml-actguidedata.png "UML_ActGuideData")

 Dispatch Goods などの角が丸い四角形は、処理がなされるアクションを表します。 Shipment Address などの角が直角の四角形は、あるアクションから別のアクションへのオブジェクトのフローを表します。

 アクション間を流れるオブジェクトのコンジットまたはバッファーとしてのノードのロールを反映した名前を、オブジェクト ノードに付けます。

 プロパティウィンドウのオブジェクトノードの**種類**を設定できます。 型としては、整数などのプリミティブ型、またはクラス図で定義したクラス、インターフェイス、列挙を使用できます。 たとえば、Street Address、City などの属性を持つ Shipment Address というクラスを、Customer という名前の別のクラスへの関連付けと一緒に作成することもできます。 詳細については、「 [UML クラス図: ガイドライン](../modeling/uml-class-diagrams-guidelines.md)」を参照してください。

> [!NOTE]
> まだ定義されていない型の名前を入力すると、UML モデルエクスプローラーの **[未指定の型]** の下に項目が追加されます。 その名前の型を後でクラス図で定義する場合は、新しい型を参照するようにオブジェクト ノードの型を再設定する必要があります。

#### <a name="buffering-data-in-object-nodes"></a>オブジェクト ノードでのデータのバッファリング
 オブジェクト ノードは、複数のオブジェクトのバッファーの働きをすることができます。 次の図の制御フローは、ユーザーは [choose more] ループ (1) を何度も回ることができ、その間 Chosen Menu Items オブジェクト ノード (2) はユーザーが選択したものを蓄積することを示しています。 最後に、ユーザーが自分の選択を完了すると、制御は Confirm Order アクション (3) に渡され、このアクションは選択された項目の完全なリストを Chosen Menu Items バッファーから受け取ります。

 ![オブジェクトノードのデータのバッファリング](../modeling/media/uml-actguidebuffer.png "UML_ActGuideBuffer")

 オブジェクト ノードのプロパティを設定することにより、バッファー内の項目の格納方法を指定できます。次のようにします。

- **順序**プロパティを設定します。

  - 順序**なし**。ランダムまたは未指定の順序を指定します。 (既定値。)

  - **Ordered**は、特定のキーに従って順序を指定します。

  - **Fifo**は、先入れ先出しの順序を指定します。

  - **[Lifo]** : 後入れ先出しの順序を指定します。

- **上限**を設定するプロパティを設定して、バッファーに格納できるオブジェクトの最大数を指定します。 既定値は * です。 これは、制限がないことを意味します。

### <a name="describing-data-flow-with-input-and-output-pins"></a>入力ピンと出力ピンを使用したデータ フローの記述
 **出力ピン**と**入力ピン**を使用して、あるアクションから別のアクションへの出力と入力を個別に記述します。

 ![入力ピンと出力ピンはアクションパラメーターです](../modeling/media/uml-actguidepins.png "UML_ActGuidePins")

 Pin を作成するには、ツールボックスの [**入力ピン**または**出力ピン**] をクリックし、アクションをクリックします。 その後、ピンをアクションの周囲に移動して、その名前を変更することができます。 **振る舞い呼び出しアクション**、**操作呼び出しアクション**、**シグナル送信アクション**、**イベント受理アクション**など、任意の種類のアクションで入力ピンと出力ピンを作成できます。

 2 つのピンの間のコネクタは、オブジェクト ノードへのフローやオブジェクト ノードからのフローと同じように、オブジェクト フローを表します。

 各ピンには、それが生成したり受け取ったりするオブジェクトのロールを示す、パラメーター名などの名前を付けます。

 **Type**プロパティで転送されるオブジェクトの種類を設定できます。 これは、UML クラス図を作成した型であることが必要です。

 接続されたピンの間を流れる各オブジェクトには、何らかの形で互換性がなければなりません。 たとえば、出力ピンによって生成されたオブジェクトは、入力ピンの型の派生型に属するからです。

 もう 1 つの方法として、出力ピンの型と入力ピンの型の間でデータを変換する変換がオブジェクト フローに含まれることを指定することもできます。 この種の最も一般的な変換は、大きい方の型から適切な部分を抽出するだけです。 図の例は、注文の詳細から出荷先住所を抽出する変換の存在を示しています。

## <a name="Details"></a>アクションの詳細な定義
 アクションの名前を使用してそのアクションによって通常得られるべき結果を明確にすることに加えて、さらに詳細をアクションに追加できる次の方法があります。

- **Body**プロパティにより詳細な説明を記述します。 たとえば、プログラム コードまたは擬似コードの一部や、得られる結果の詳細な説明を書き込むこともできます。

- アクションを振る舞い呼び出しアクションに置き換え、その詳細な振る舞いを別個のアクティビティ図内で記述する。 「[振る舞い呼び出しアクションを使用したサブアクティビティの記述」を](#Subactivities)参照してください。

- アクションの**ローカル事後** **条件とローカルの事前条件**プロパティを設定して、その結果をより具体的な詳細に記述します。 詳細については、「[事後条件と事前条件の定義](#Postcondition)」を参照してください。

### <a name="Subactivities"></a>振る舞い呼び出しアクションを使用したサブアクティビティの記述
 別個のアクティビティ図を使用して、アクションの詳細な振る舞いを記述できます。 呼び出される振る舞いは、振る舞い呼び出しアクションによってメイン アクティビティ図に表されるアクティビティ図です。 振る舞い呼び出しアクションを使用して、異なるアクティビティ間で共有される振る舞いを記述することもできます。これにより、サブアクティビティを複数回描画する必要がなくなります。

 次の図において、図 1 は、振る舞い呼び出しアクションのあるアクティビティを示しており、図 2 は、呼び出される振る舞いを表すサブアクティビティ図を示しています。

 ![別のアクティビティ図に詳細なアクションが表示されます。](../modeling/media/uml-actguidedetail.png "UML_ActGuideDetail")

##### <a name="to-describe-a-sub-activity-with-a-call-behavior-action"></a>振る舞い呼び出しアクションを使用してサブアクティビティを記述するには

1. サブアクティビティのダイアグラムを作成するには、**ソリューションエクスプローラー**で、モデリングプロジェクトを右クリックし、 **[追加]** をポイントして、 **[新しい項目]** をクリックします。

2. **[新しい項目の追加]** ダイアログボックスの **[テンプレート]** で **[アクティビティ図]** をクリックし、 **[名前]** ボックスに、**呼び出し動作アクション**を提供する予定の名前を入力します。

3. サブアクティビティの詳細なワークフローを描画します。 これは、呼び出される振る舞いです。

    - 呼び出されたサブアクティビティ図では、呼び出された動作が呼び出されたときに制御が開始される場所が**初期ノード**によって示されます。 **アクティビティの最後のノード**は、コントロールが親アクティビティに戻る場所を示します。

4. **振る舞い呼び出しアクション**の**behavior**プロパティを、呼び出された動作ダイアグラムを参照するように設定します。

    > [!NOTE]
    > サブアクティビティ図にはいくつかの要素が含まれている必要があります。そうしないと、 **[動作]** プロパティのドロップダウンリストで図を使用できなくなります。 また、 **[動作] プロパティを**設定するまで、[**動作の呼び出し] アクション**図形に trident アイコンは表示されません。

5. アクションの "**同期**" プロパティを設定して、呼び出されたアクティビティが完了するまでアクティビティが待機するかどうかを指定します。

    - [**同期が**false] に設定されている場合は、呼び出されたアクティビティが終了する前にフローが次のアクションに進むことができることを示しています。 出力ピンは定義すべきではありません。定義すると、アクションから送信データが流れる結果となります。

### <a name="describing-data-flow-in-and-out-of-sub-activities"></a>サブアクティビティとの間のデータ フローの記述
 ソフトウェアでパラメーターを使用するのと同じように、サブアクティビティに出入りするデータを記述できます。

- 呼び出される振る舞いアクションに、アクションに出入りするデータごとに、入出力ピン (1) を作成します。 それぞれに適切な名前を付けます。

- サブアクティビティ図で、呼び出し元のアクションの各入力ピンと出力ピンに対して**アクティビティパラメーターノード**(2) を作成します。 各ノードに、対応するピンと同じ名前を付けます。

  > [!NOTE]
  > アクティビティ パラメーター ノードは、オブジェクト ノードに似ています。 表示しているノードの種類を確認するには、ノードを右クリックし、 **[プロパティ]** をクリックします。 [プロパティ] ウィンドウのヘッダーにノードの型が表示されます。

- サブアクティビティ図で、各アクティビティ パラメーター ノードに出入りするオブジェクトのフローを示すコネクタを描画します。

  ![呼び出し動作のピン留めアクティビティパラメーターへのマップ](../modeling/media/uml-actguidesub.png "UML_ActGuideSub")

### <a name="Postcondition"></a>事後条件と事前条件の定義
 **ローカルの事後**条件とローカルの**事前条件**プロパティを使用して、アクションの結果を詳細に指定できます。 これらのプロパティは、どのようにして効果が得られるかを記述せずに、アクションの効果を記述します。

 これらのプロパティを設定するには、アクションを右クリックし、 **[プロパティ]** をクリックします。 [プロパティ] ウィンドウで、プロパティに値を入力します。

#### <a name="local-postconditions"></a>ローカル事後条件
 事後条件とは、アクションが完了したと見なされるために満たされなければならない条件のことです。 Confirm Order アクション例では、事後条件は次のような場合があります。

 顧客は、自分のクレジット カードを処理するために必要な、完全で有効な詳細を提供した。

 事後条件は、アクション実行前後の状態間のリレーションシップを表すことができます。 (例:

 利率は以前の 2 倍である。

 より形式的なスタイルで事後条件を作成することで、アクションで扱われるデータの特定の属性を表せます。 (例:

 `InvoiceTotal == Sum(OrderItem.MenuItem.Price)`

#### <a name="local-preconditions"></a>ローカル事前条件
 事前条件とは、アクションが開始可能状態になるために真でなければならない条件のことです。 たとえば、Confirm Order アクションの事前条件は、次のような場合があります。

 顧客はメニューから少なくとも 1 つの項目を選択した。

### <a name="describing-calls-to-operations"></a>操作の呼び出しの記述
 アクションは一般に、ユーザー、ソフトウェア、コンピューターのあらゆる組み合わせによって実行される作業を表します。 ただし、操作呼び出しアクションを使用して、特定のソフトウェア メソッドまたは関数の呼び出しを記述することができます。

- 操作呼び出しアクションの名前を、どのような操作がどのようなオブジェクトまたはコンポーネントに対して呼び出されるかを示すように設定します。

- 操作呼び出しアクションに入出力ピンを追加して、パラメーターと戻り値を記述します。

- アクションの "**同期**" プロパティを設定して、操作が完了するまでアクティビティが待機するかどうかを指定できます。

  - [**同期が**false] に設定されている場合は、呼び出された操作が完了する前にフローが次のアクションに進むことができることを示しています。 出力ピンは定義すべきではありません。定義すると、アクションから送信データが流れる結果となります。

## <a name="Concurrent"></a>同時実行フロー
 **フォークノード**と**結合ノード**を使用すると、同時に実行できるアクティビティの複数のスレッドを記述できます。

 ![フォークノードと join ノードに同時実行フローが表示される](../modeling/media/uml-actguideconcurrent.png "UML_ActGuideConcurrent")

 **フォークノード**(1) の効果は、制御のスレッドを2つ以上のスレッドに分割することです。 前のアクションが終了すると、フォークの出力側のすべてのアクションが開始可能になります。

 **結合ノード**(2) は、同時実行スレッドをまとめます。 結合**ノードの後**のアクションは、**結合ノード**に先行するすべてのアクションが完了するまで開始されません。

### <a name="describing-signals-and-events"></a>シグナルとイベントの記述
 シグナルを送信するプロセス内のステップを、アクティビティ内のシグナル送信アクションとして示すことができます。 イベント受理アクションとして続行する前段階で、特定のシグナルやイベントを待機するステップを示すことができます。

 たとえば、注文を送信するステップと、その注文を受信してから処理しなければならない別のステップを示すこともできます。

#### <a name="sending-a-signal"></a>シグナルの送信
 ある種のシグナルまたはメッセージが他のアクティビティまたはプロセスに送信されることを示すには、シグナル送信アクション (3) を使用します。 アクションが送信するメッセージの種類を示すには、アクションの名前を使用します。

- 制御フロー内に次のアクションがあれば、制御がすぐに渡されます。

- 返された情報にプロセスがどのように応答するかを、シグナル送信アクションを使用して記述することはできません。 そうするには、別個のイベント受理アクションを使用します。

- シグナル送信アクションへの入力データ フローを使用して、送信メッセージとともに送信できるデータを示すことができます。 詳細については、「[データフローの記述](#DataFlows)」を参照してください。

#### <a name="waiting-for-a-signal-or-event"></a>シグナルまたはイベントの待機
 このアクティビティが何らかの外部イベントまたは受信メッセージを待機することを示すには、イベント受理アクション (4) を使用します。 アクションが待機するイベントの種類を示すには、アクションの名前を使用します。

- アクティビティがそのフロー内の特定のポイントで外部イベントまたはメッセージを待機することを示すには、アクティビティ内の適切な場所にイベント受理アクションを入力フローとともに描画します。

- アクティビティがいつでも外部イベントまたはメッセージに応答できることを示すには、入力フローなしのイベント受理アクションを描画します。 指定された外部イベントが発生すると、アクティビティ内のイベント受理アクションから、新しいスレッドが開始されます。

- シグナルの送信側に返される値を、イベント受理アクションを使用して記述することはできません。 そのためには、別個のシグナル送信アクションを使用します。

- アクションからの出力データ フローを示すことにより、シグナルで受信されたデータをアクティビティがどのように処理するかを示すことができます。 複数の出力フローを表示する場合は、[イベントの受理] アクションの**IsUnmarshall**プロパティを設定する必要があります。これは、アクションによって受信シグナルが個別のコンポーネントに解析されることを示します。 詳細については、「[データフローの記述](#DataFlows)」を参照してください。

### <a name="describing-multiple-data-flows"></a>複数のデータ フローの記述
 アクションから出てくる制御フローまたはオブジェクト フローを複数描画することにより、アクションが終了すると複数のスレッドが出現することを示すことができます。 この効果はフォークに似ていますが、制御フローとオブジェクト フローの組み合わせを使用することができます。

 次の例は、アクションに出入りする複数のフローを示しています。

 ![並列オブジェクトフロー](../modeling/media/uml-actguidemulti.png "UML_ActGuideMulti")

 "Customer provides details" アクションが完了すると、"Shipment address" と "Credit card details" の 2 つのオブジェクトが生成されます。 この 2 つのオブジェクトは、それぞれ異なるアクションによる処理に進みます。

 アクションの開始のためにはそのすべての入力がそろっていることが必要であるため、最後のアクションは、それにつながるすべてのアクションが完了するまで開始されません。

### <a name="streams"></a>ストリーム
 アクティビティ図を使用すると、パイプライン、つまり同時に実行されて、アクションが相互に連続的にデータを受け渡す一連のアクションを記述しやすくなります。

 次の例の意図は、各アクションはオブジェクトを生成して作業し続けることができるということです。 制御フローが存在しないので、各アクションはそれぞれの最初のオブジェクトを受け取ったらすぐに開始できます。

 この例のコネクタはオブジェクト フローであることに注意してください。それらすべてにおいて、アクティビティ パラメーター ノード、オブジェクト ノード、あるいは入力ピンまたは出力ピンに、末端が少なくとも 1 つあるからです。

 ![データフロー](../modeling/media/uml-actguidestream.png "UML_ActGuideStream")

 1. この例には、3 つのアクティビティ パラメーター ノードがあり、その入力と出力を表しています。

 2. オブジェクト ノード、入力ピン、出力ピンは、バッファーを表すことができます。 オブジェクト ノードの [上限] プロパティを設定することにより、バッファーに同時に入れることができるオブジェクトの数を示すことができます。

 3. デシジョン ノードを使用することにより、ストリームが分かれて各オブジェクトがそれぞれ異なる分岐に送信されることを示すことができます。 コメントまたはノードのタイトルを使用して、分割の基準を説明できます。

 4. フォーク ノードを使用することにより、オブジェクトのコピーが複数作成されて同時処理に送られることを示すことができます。

 5. ジョイン ノードを使用して、処理の 2 つのストリームが 1 つに再マージされることを示すことができます。

### <a name="selection-and-transformation"></a>選択と変換
 オブジェクト フロー内のオブジェクトが変換されることまたは選択されること、あるいはその両方であることを指定できます。 オブジェクト フローとは、ピンまたはオブジェクト ノードに出入りするフローのことです。

- 変換は、フローに入るオブジェクトが別の型にどのように変換されるかを表します。

- 選択は、どのようにしてフローに入るオブジェクトの一部だけが受信アクションに送信されるかを表します。

  例は、変換を示しています。 図 1 の最初のアクションは、出力ピンに郵便番号を生成します。 これは、2 番目のアクションの入力ピンに接続されています。 しかし、2 番目のアクションは、完全に指定された住所を必要としています。 ある型から別の型への変換は、2 番目のアクティビティ Address Lookup で指定されています。 これは、オブジェクトのフローの [変換] プロパティから参照されます。 Address Lookup アクティビティには、受信する郵便番号のためのアクティビティ パラメーター ノードと、送信する詳細住所のための別のアクティビティ パラメーター ノードが含まれています。

  ![別の図で定義されたオブジェクト変換](../modeling/media/uml-actguidetransform.png "UML_ActGuideTransform")

  変換または選択は、次の 2 とおりの方法で指定できます。

- 入力ピンまたは出力ピンにコメントをアタッチする。

  - この説明を一般的なコメントと区別するには、< \<**変換**> > または < \< >**選択**> を使用してコメントを開始できます。

- 別個のアクティビティ図で変換または選択を詳細に指定する。

  - この方法を使用する場合も、コメントをアタッチします。こうすることで、変換が定義されていることが読み手にとって明確になります。

##### <a name="to-specify-a-transformation-or-selection-in-a-separate-activity-diagram"></a>別個のアクティビティ図で変換または選択を指定するには

1. 変換フローまたは選択フローを記述する新しいアクティビティ図を作成します。

   - **ソリューションエクスプローラー**で、プロジェクトを右クリックして **[追加]** をポイントし、 **[新しい項目]** をクリックして、 **[アクティビティ図]** をクリックします。 変換フローまたは選択フローにふさわしい名前を図に付けます。 **[追加]** をクリックします。

2. 新しい図で、次のようにします。

   1. アクティビティ パラメーター ノードを 2 つ作成します。1 つは入力フロー用、もう 1 つは出力用です。

   2. オブジェクト フローと相互接続されるアクションを作成します。 これは、変換または選択の動作を示します。

3. 変換または選択を使用する図で、次のようにします。

   1. オブジェクト フロー (入力ピンまたは出力ピンのコネクタ、オブジェクト ノード、またはアクティビティ パラメーター ノード) を作成します。

   2. オブジェクトフローを右クリックし、 **[プロパティ]** をクリックします。

   3. **変換**または**選択**プロパティで、変換フローまたは選択フローを指定したダイアグラムを選択します。

   オブジェクト ノード、および個々の入力ピンと出力ピンに対して、選択を定義することもできます。 前の手順と同様に選択アクティビティを定義し、オブジェクト ノード、または 入力 または 出力ピン の **選択** プロパティを設定します。

## <a name="see-also"></a>参照
 [Uml モデルとダイアグラムの編集](../modeling/edit-uml-models-and-diagrams.md) [uml シーケンス図: リファレンス](../modeling/uml-sequence-diagrams-reference.md) [uml コンポーネント図](../modeling/uml-component-diagrams-reference.md): リファレンス uml[ユースケース図](../modeling/uml-use-case-diagrams-reference.md): リファレンス uml[クラス図](../modeling/uml-class-diagrams-reference.md): リファレンス[uml コンポーネント図: リファレンス](../modeling/uml-component-diagrams-reference.md) [ビデオ: アクティビティ図を使用したビジネスワークフローのキャプチャ](http://channel9.msdn.com/posts/clinted/UML-with-VS-2010-Part-4-Capture-Business-Workflows/)
