---
title: アプリ モデル&#39;アーキテクチャ |Microsoft Docs
ms.custom: ''
ms.date: 11/15/2016
ms.prod: visual-studio-tfs-dev14
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
helpviewer_keywords:
- UML, modeling architecture
ms.assetid: aedce746-9df5-49e1-9662-67eb1b83d313
caps.latest.revision: 21
author: alexhomer1
ms.author: gewarren
manager: douge
ms.openlocfilehash: 7300af951a50fb463453e83041d0651ac2c62cef
ms.sourcegitcommit: 240c8b34e80952d00e90c52dcb1a077b9aff47f6
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/23/2018
ms.locfileid: "49835266"
---
# <a name="model-your-app39s-architecture"></a>アプリ モデル&#39;アーキテクチャ
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

ユーザーが、ソフトウェア システムまたはアプリケーションが満たしていることを確認する必要があります、全体的な構造の記述と、ソフトウェア システムまたはアプリケーションの動作の一部として Visual Studio でモデルを作成することができます。 モデルを使用して、設計全体で使用するパターンを記述することもできます。 これらのモデルは、既存のアーキテクチャの理解、変更についての話し合い、開発者の意図の伝達に役立ちます。  
  
 この機能をサポートする Visual Studio のバージョンを確認するには、「 [アーキテクチャ ツールとモデリング ツールのバージョン サポート](../modeling/what-s-new-for-design-in-visual-studio.md#VersionSupport)」を参照してください。  
  
 モデルの目的は、自然言語による記述のあいまいさを減らし、開発者同士が設計を視覚化してさまざまな設計について話し合えるようにすることです。 モデルは、他のドキュメントまたはディスカッションと一緒に使用する必要があります。 モデルだけでは、アーキテクチャの完全な仕様を表すことができません。  
  
> [!NOTE]
>  このトピックで言う "システム" は、開発するソフトウェアを指します。 システムは、多数のソフトウェアおよびハードウェアのコンポーネントで構成される大規模な集合体であったり、1 つのアプリケーションであったり、1 つのアプリケーションの一部であったりします。  
  
 システムのアーキテクチャは、次の 2 つの領域に分類できます。  
  
-   [高度な設計](#Structure)します。 この設計では、主要なコンポーネントと、それらのコンポーネントが各要件を満たすために相互に対話する方法について記述します。 大きいシステムの場合は、コンポーネントごとに、そのコンポーネントを構成している、より小さなコンポーネントを示す概要設計が存在する場合があります。  
  
-   [設計パターン](#Patterns)とコンポーネントの設計全体で使用される規則です。 パターンで、プログラムの目的を達成するための特定の方法について記述します。 設計全体で同じパターンを使用することで、チームは、変更を加えたり、新しいソフトウェアを開発したりする際のコストを削減できます。  
  
##  <a name="Structure"></a> 概要設計  
 概要設計では、システムの主要なコンポーネントと、それらのコンポーネントが設計の目標を達成するために相互に対話する方法について記述します。 概要設計を作成する際に必要な作業を次の一覧に示します。ただし、この順序で行う必要があるわけではありません。  
  
 既存のコードを更新する場合は、一般に、主要なコンポーネントを記述することから始めます。 必ず、ユーザー要件の変更について理解したうえで、コンポーネント間の対話を追加または変更するようにしてください。 新しいシステムを開発する場合は、ユーザーのニーズの主な特徴を理解することから始めます。 その後に、主要なユース ケースにおける対話のシーケンスを調査し、コンポーネントの設計にそれらのシーケンスを統合できます。  
  
 どのケースの場合も、さまざまな作業を同時に進め、早い段階でコードとテストを開発しておくと効果的です。 1 つの作業を完成させてから別の作業を開始するようなことはやめてください。 通常、要件も、システムを設計する最善の方法についての理解も、コードの作成とテストを実行している間に変化します。 したがって、まずは、要件および設計の主な特徴を理解してコーディングすることから始める必要があります。 細部は、プロジェクトの後の段階で満たすようにします。  
  
-   [要件の理解](#Requirements)します。 どのような設計も、まずはユーザーのニーズを明確に理解することから始まります。  
  
-   [アーキテクチャ パターン](#BigDecisions)します。 システムのコア テクノロジとアーキテクチャ要素の選択。  
  
-   [コンポーネントとそのインターフェイス](#Components)します。 コンポーネント図を描画して、システムの主要部分と、それらの相互対話に使用するインターフェイスを表すことができます。 各コンポーネントのインターフェイスには、シーケンス図に指定したすべてのメッセージを含めます。  
  
-   [コンポーネント間の相互作用](#Interactions)します。 ユース ケース、イベント、または受信メッセージごとに、必要な応答を実現するためにシステムの主要コンポーネントが対話する方法を示すシーケンス図を描画できます。  
  
-   [コンポーネントとインターフェイスのデータ モデル](#Data)します。 クラス図を描画して、コンポーネント間で受け渡され、コンポーネントの内部に格納される情報を記述できます。  
  
##  <a name="Requirements"></a> 要件の理解  
 アプリケーション全体の概要設計は、要求モデルなどの、ユーザーのニーズを示す他の記述と組み合わせると、最も効果的に作成できます。 要件モデルの詳細については、次を参照してください。[ユーザー要件をモデル化](../modeling/model-user-requirements.md)します。  
  
 開発するシステムが、より大きなシステムに属するコンポーネントである場合、プログラム インターフェイスでは、要件の一部またはすべてを具体化します。  
  
 要求モデルは、次のような重要な情報を提供します。  
  
- 提供インターフェイス。 提供インターフェイスは、システムまたはコンポーネントがユーザー (人間のユーザーまたは他のソフトウェア コンポーネント) に提供する必要があるサービスまたは操作をリストします。  
  
- 要求インターフェイス。 要求インターフェイスは、システムまたはコンポーネントが使用できるサービスまたは操作をリストします。 場合によっては、これらのすべてのサービスを、独自のシステムの一部として設計することができます。 そうしない場合、特に、さまざまな構成で他のコンポーネントと組み合わせて使用できるコンポーネントを設計する場合、要求インターフェイスは、外部の考慮事項に基づいて設定されます。  
  
- サービス品質要求 システムが満たさなければならないパフォーマンス、セキュリティ、堅牢性、およびその他の目標と制約。  
  
  要求モデルは、システムのユーザー (人間またはその他のソフトウェア コンポーネント) の観点から作成します。 システムのユーザーは、システムの内部動作には関知しません。 一方、アーキテクチャ モデルの目的は、内部動作を記述し、それらの動作によってユーザーのニーズが満たされる方法を示すためのものです。  
  
  要求モデルとアーキテクチャ モデルを分けておくと、ユーザーと要件について話し合いやすくなるため、効果的です。 また、要件を変更せずに、設計をリファクタリングしてさまざまなアーキテクチャを検討する際にも有効です。  
  
  要求モデルとアーキテクチャ モデルは、次の 2 つの方法で分けることができます。  
  
- 同じソリューション内の別々のプロジェクトに保持する。 UML モデル エクスプローラーで、別々のモデルとして表示されます。 さまざまなチーム メンバーがモデルを同時に操作できます。 モデル間に作成できるトレースの種類は限られます。  
  
- 同じ UML モデル内の別々のパッケージに保持する。 これにより、モデル間の依存関係のトレースが簡単になり、一度に複数のユーザーがモデルを操作することを防止できます。 また、非常に大きなモデルの場合は、Visual Studio への読み込みにかかる時間が長くなります。 そのため、この方法は大規模なプロジェクトにはあまり適していません。  
  
  要求モデルまたはアーキテクチャ モデルに組み込む必要がある詳細情報の量は、プロジェクト規模およびチームのサイズや分散状況によって異なります。 短期プロジェクトの小さなチームであれば、ビジネス概念のクラス図やある程度のデザイン パターンを描く以上のことは必要でない可能性がありますが、複数の地域に分散する大規模なプロジェクトであれば、より詳細な情報が必要になる可能性があります。  
  
##  <a name="BigDecisions"></a> アーキテクチャ パターン  
 開発の早い段階で、設計の基礎にする主要なテクノロジと要素を選択する必要があります。 こうした選択が必要になる領域の例を次に示します。  
  
- データベースとファイル システムのどちらにするか、ネットワーク アプリケーションと Web クライアントのどちらにするか、といった基本的なテクノロジの選択。  
  
- Windows Workflow Foundation と ADO.NET Entity Framework のどちらにするか、といったフレームワークの選択。  
  
- エンタープライズ サービス バスとポイントツーポイント チャネルのどちらにするか、といった統合方法の選択。  
  
  こうした選択は、しばしば、スケールや柔軟性といったサービス品質要求に基づいて行なわれます。また、詳細な要求が明らかになる前に選択できます。 大規模なシステムでは、ハードウェアとソフトウェアの構成は密接に相関してます。  
  
  何を選択するかによって、アーキテクチャ モデルの使用方法および解釈方法が変わります。 たとえば、クラス図の関連付けは、データベースを使用するシステムではデータベース内の関係や外部キーを表す可能性がありますが、XML ファイルをベースとするシステムでは XPath を使用する相互参照を指す可能性があります。 シーケンス図のメッセージは、分散システムでは送信されるメッセージを表す可能性がありますが、独立した 1 つのアプリケーションでは関数呼び出しを表す可能性があります。  
  
##  <a name="Components"></a> コンポーネントとそのインターフェイス  
 このセクションの主要な推奨事項を次に示します。  
  
- システムの主要部分を示すコンポーネント図を作成する。  
  
- システムの構造を示すために、コンポーネント間、またはコンポーネントのインターフェイス間の依存関係を描画する。  
  
- コンポーネントのインターフェイスを使用して、各コンポーネントが提供する、または必要とするサービスを示す。  
  
- 大規模な設計の場合は、各コンポーネントを、より小さな部分に分解した別の図を描画できる。  
  
  これらの点について、このセクションの残りの部分で詳しく説明していきます。  
  
### <a name="components"></a>コンポーネント  
 アーキテクチャ モデルの最も重要なビューは、システムの主要部分およびそれらの依存関係を示すコンポーネント図です。 コンポーネント図の詳細については、次を参照してください。 [UML コンポーネント図: リファレンス](../modeling/uml-component-diagrams-reference.md)します。  
  
 ![UML コンポーネント図の各要素を示す](../modeling/media/uml-barecomponent.png "UML_BareComponent")  
  
 大規模なシステムの一般的なコンポーネント図には、次のようなコンポーネントが含まれます。  
  
-   プレゼンテーション。 ユーザーにアクセスを提供するコンポーネント。一般には Web ブラウザーで実行されます。  
  
-   Web サービス コンポーネント。 クライアントとサーバーの間に接続を提供します。  
  
-   ユース ケース コントローラー。 各シナリオの手順をユーザーに案内します。  
  
-   ビジネス コア。 要求モデルのクラスに基づくクラスを含んでおり、重要な操作を実装し、ビジネス制約を適用します。  
  
-   データベース。 ビジネス オブジェクトを格納します。  
  
-   ロギング コンポーネントおよびエラー処理コンポーネント。  
  
### <a name="dependencies-between-components"></a>コンポーネント間の依存関係  
 コンポーネントだけではなく、コンポーネント間の依存関係を示すことができます。 2 つのコンポーネント間にある依存関係を示す矢印は、一方のコンポーネントの設計が変更されると、他方のコンポーネントの設計に影響することを示しています。 通常は、一方のコンポーネントが、他方のコンポーネントの提供するサービスまたは機能を直接または間接的に使用している場合に、このような依存関係が生じます。  
  
 適切に構成されたアーキテクチャでは、依存関係が明確に整理され、次の条件が満たされています。  
  
- コード マップ上にループが存在しない。  
  
- コンポーネントがレイヤーに配置され、すべての依存関係が 1 つのレイヤーのコンポーネントから次のレイヤーのコンポーネントに向かって設定されている。 2 つのレイヤー間の依存関係はすべて同じ方向である。  
  
  コンポーネント間の依存関係を直接表すことも、コンポーネントに接続された要求インターフェイスと提供インターフェイスの間の依存関係を表すこともできます。 インターフェイスを使用して、各依存関係で使用される操作を定義できます。 一般に、図を初めて描画したときにはコンポーネント間の依存関係が表示されますが、その後、詳細な情報を追加すると、インターフェイス間の依存関係に置き換えられます。 どちらのバージョンもソフトウェアを正しく表すものですが、インターフェイスのバージョンの方が、前者のバージョンよりも詳細な情報を示します。  
  
  保守しやすいソフトウェアを作成するためには、依存関係を管理することが最も重要です。 コンポーネント図には、コードに含まれるすべての依存関係を表さなければなりません。 コードが既に存在する場合は、すべての依存関係が図に表されていることを確認してください。 コードを開発する際には、コンポーネント図で計画されていない依存関係がコードに含まれないようにしてください。 コード内の依存関係を検出するために、レイヤー図を生成することができます。 計画した依存関係の制約が満たされていることを確認するために、レイヤー図と照らし合わせてコードを検証することができます。 詳細については、次を参照してください。[レイヤー図: リファレンス](../modeling/layer-diagrams-reference.md)します。  
  
### <a name="interfaces"></a>インターフェイス  
 コンポーネント上にインターフェイスを配置することで、各コンポーネントの提供する主要な操作のグループを分けて、名前を付けることができます。 たとえば、Web ベースの販売システムのコンポーネントには、顧客が商品を購入するときに使用するインターフェイス、供給業者がカタログを更新するときに使用するインターフェイス、また、システムの管理に使用するインターフェイスがあるはずです。  
  
 1 つのコンポーネントに、任意の数の提供インターフェイスおよび要求インターフェイスを含めることができます。 提供インターフェイスは、コンポーネントが、他のコンポーネントで使用できるように提供するサービスを示します。 要求インターフェイスは、コンポーネントが、他のコンポーネントで使用するサービスを示します。  
  
 提供インターフェイスと要求インターフェイスの両方を定義すると、設計の他の部分からコンポーネントを明確に切り離して、次の手法を利用できるようになります。  
  
- コンポーネントをテスト ハーネスに配置し、周囲のコンポーネントをテスト ハーネスでシミュレートする。  
  
- 他のコンポーネントには依存せずに、コンポーネントを開発する。  
  
- コンポーネントのインターフェイスを別のコンポーネントに結合して、コンポーネントを他のコンテキストで再利用する。  
  
  インターフェイスの操作リストを定義する場合は、UML クラス図でインターフェイスの別のビューを作成することができます。 このためには、UML モデル エクスプローラーでインターフェイスを見つけて、クラス図にドラッグします。 そのインターフェイスに操作を追加できます。  
  
  UML インターフェイス内の操作は、コンポーネントの動作を呼び出す方法を表します。 Web サービス要求、シグナル、他の種類の対話、または通常のプログラムの関数呼び出しを表すこともできます。  
  
  追加する操作を決定するには、コンポーネント間の対話を示すシーケンス図を作成します。 参照してください[コンポーネント間の相互作用](#Interactions)します。 これらのシーケンス図は、それぞれ別のユース ケースで行われる対話を示します。 このように、ユース ケースを調べながら、各コンポーネントのインターフェイスの操作リストに段階的に操作を追加していくことができます。  
  
### <a name="decomposing-a-component-into-parts"></a>コンポーネントをパーツに分解する  
 これまでのセクションで説明した手順を、各コンポーネントに適用できます。  
  
 各コンポーネントの中で、そのサブコンポーネントをパーツとして表示することができます。 パーツとは、実際には親コンポーネントの属性であり、一種のクラスです。 パーツごとに独自の型を持ちます。型はコンポーネントにすることができます。 このコンポーネントを図上に配置し、そのパーツを示すことができます。 詳細については、次を参照してください。 [UML コンポーネント図: ガイドライン](../modeling/uml-component-diagrams-guidelines.md)します。  
  
 この手法をシステム全体に適用すると効果的です。 システムを 1 つのコンポーネントとして描画し、その主要なコンポーネントをパーツとして表します。 これにより、外部とのシステムのインターフェイスを明確に特定できます。  
  
 コンポーネントの設計で別のコンポーネントを使用する場合、そのコンポーネントをパーツとして表すか、それとも、要求インターフェイスを通じてアクセスする別個のコンポーネントとして表すかを何度も選択する必要があります。  
  
 次の状況では、パーツを使用してください。  
  
- 親コンポーネントの設計で、パーツのコンポーネント型を必ず使用しなければならない。 そのため、パーツの設計が、親コンポーネントの設計に不可欠である。  
  
- 親コンポーネントが抽象的な存在である。 たとえば、ビューおよびユーザーとの対話を処理する実際のコンポーネントのコレクションを表す、プレゼンテーション層という概念的なコンポーネントがあるかもしれません。  
  
  次の状況では、要求インターフェイスを介してアクセスする別個のコンポーネントを使用してください。  
  
- 要求側コンポーネントを、そのインターフェイスを介して、別の提供側コンポーネントに実行時に結合できる。  
  
- あるプロバイダーを別のプロバイダーに簡単に置換できるような設計になっている。  
  
  要求インターフェイスの使用は、通常、パーツの使用よりも望ましいです。 設計にかかる時間が増える可能性がありますが、結果的にシステムの柔軟性が高まります。 コンポーネントを別々にテストすることも簡単です。 これにより、開発計画での結合を減らすことができます。  
  
##  <a name="Interactions"></a> コンポーネント間の相互作用  
 このセクションの主要な推奨事項を次に示します。  
  
- システムのユース ケースを明らかにする。  
  
- ユース ケースごとに、システムのコンポーネントが他のコンポーネントおよびユーザーと連携して必要な成果を得る方法を表す図を 1 つ以上描画する。 通常は、シーケンス図またはアクティビティ図を描画します。  
  
- インターフェイスを使用して、各コンポーネントが受け取るメッセージを指定する。  
  
- インターフェイス内の操作の効果について記述する。  
  
- コンポーネントごとにこの手順を繰り返し、そのパーツの対話を表す。  
  
  たとえば、Web ベースの販売システムの要求モデルでは、顧客による購入をユース ケースとして定義するはずです。 顧客がプレゼンテーション層で各コンポーネントと行う対話を示すシーケンス図や、倉庫および会計のコンポーネントと行う対話を示すシーケンス図を作成できます。  
  
### <a name="identifying-the-initiating-events"></a>開始イベントを指定する  
 ほとんどのソフトウェア システムの処理は、さまざまな入力またはイベントに対して返す応答によって簡単に分割できます。 開始イベントは、次のイベントのいずれかです。  
  
-   ユース ケースの最初のアクション。 これは、ユース ケース内のステップとして要求モデル内に現れることもあれば、アクションとしてアクティビティ図に現れることもあります。 詳細については、 [UML ユース ケース図: ガイドライン](../modeling/uml-use-case-diagrams-guidelines.md)と[UML アクティビティ図: ガイドライン](../modeling/uml-activity-diagrams-guidelines.md)します。  
  
-   プログラム インターフェイスのメッセージ。 開発するシステムが、より大きなシステムのコンポーネントである場合は、コンポーネントのいずれかのインターフェイスの操作として記述する必要があります。 参照してください[コンポーネントとそのインターフェイス](#Components)します。  
  
-   システムによって監視されている特定の条件、または、日時などの定期的なイベント。  
  
### <a name="describe-the-computations"></a>計算を記述する  
 開始イベントに対するコンポーネントの応答を示すシーケンス図を描画します。  
  
 典型的なシーケンスに参加するコンポーネント インスタンスごとに生存線を描画します。 場合によっては、型ごとにインスタンスが 1 つ以上あります。 1 つのコンポーネントとしてシステム全体を記述した場合は、そのコンポーネントに含まれるパーツごとに生存線が 1 つあります。  
  
 詳細については、次を参照してください。 [UML シーケンス図: ガイドライン](../modeling/uml-sequence-diagrams-guidelines.md)します。  
  
 アクティビティ図が役に立つ場合もあります。 たとえば、コンポーネントに継続的なデータ フローがある場合は、それをオブジェクトのフローとして記述できます。 コンポーネントに複雑なアルゴリズムがある場合は、それを制御フローとして記述できます。 必ず、各アクションをどのコンポーネントが実行するのかを、コメントなどを使用して明確に記述してください。 詳細については、次を参照してください。 [UML アクティビティ図: ガイドライン](../modeling/uml-activity-diagrams-guidelines.md)します。  
  
### <a name="specify-the-operations"></a>操作を指定する  
 図は、各コンポーネントが実行する操作を示します。これらの操作は、シーケンス図のメッセージとして表されるか、アクティビティ図のアクションとして表されます。  
  
 コンポーネントごとに、これらの操作をまとめます。 コンポーネントの提供インターフェイスを作成し、そのインターフェイスに操作を追加します。 一般に、クライアントの型ごとに別のインターフェイスを使用します。 インターフェイスに操作が追加された最も簡単に**UML モデル エクスプ ローラー**します。 同様に、各コンポーネントが他のコンポーネントから使用する操作をまとめて、コンポーネントに接続された要求インターフェイスに配置します。  
  
 各操作の後に達成される内容を示すコメントを、アクティビティ図またはシーケンス図に追加すると便利です。 内の各操作の効果を記述することもできます。 その**ローカル事後条件**プロパティ。  
  
###  <a name="Data"></a> コンポーネントとインターフェイスのデータ モデル  
 コンポーネント インターフェイスの各操作のパラメーターおよび戻り値を定義します。 操作が Web サービス要求などの呼び出しを表している場合、パラメーターは、要求の一部として送信される情報に相当します。 パラメーターを使用するいくつかの値は、操作から返される、場所、**方向**プロパティに設定**アウト**します。  
  
 パラメーターと戻り値ごとに型があります。 これらの型は、UML クラス図を使用して定義できます。 これらの図で、実装の細部を表現する必要はありません。 たとえば、XML として送信されるデータを説明する場合は、関連付けを使用して XML ノード間の任意の種類の相互参照を表し、クラスを使用してノードを表すことができます。  
  
 コメントを使用して、関連付けおよび属性のビジネス上の制約を記述できます。 たとえば、顧客のすべての注文アイテムを、同じ供給業者から供給しなければならない場合は、注文アイテムと、製品カタログのアイテムの間の関連付けを参照し、カタログ アイテムとその供給業者の関連付けを参照することで記述できます。  
  
##  <a name="Patterns"></a> 設計パターン  
 デザイン パターンとは、ソフトウェアの特定の側面、特に、システムのさまざまなパーツで繰り返し発生する側面を設計する方法の概要です。 プロジェクト全体で同じアプローチを採用することで、設計コストを削減し、ユーザー インターフェイスの一貫性を保証し、コードを理解および変更するためのコストを削減できます。  
  
 よく知られていて、広く適用されている、Observer などの汎用的なデザイン パターンがいくつかあります。 さらに、特定のプロジェクトにのみ適用可能なパターンもあります。 たとえば、Web 販売システムの顧客の注文に変更を加えるコード内には、いくつかの操作が含められるはずです。 注文の状態がどの段階においても正確に表示されるように、これらのすべての操作は、データベースを更新するための特定のプロトコルに従う必要があります。  
  
 ソフトウェア アーキテクチャの作業の中には、デザイン全体に適用する必要があるパターンを決定する作業があります。 これは、通常、継続的に行われるタスクです。プロジェクトが進行するにつれて、新しいパターンや、既存のパターンに対する改善項目が明らかになるからです。 早い段階で、主要な設計パターンのそれぞれを用いるように開発計画を整理すると有効です。  
  
 ほとんどのデザイン パターンは、フレームワーク コード内に部分的に組み込むことができます。 たとえば、データベースが正しく処理されるように保証するデータベース アクセス層などの、特定のクラスまたはコンポーネントを使用するように開発者に要求してパターンのパーツを削減できます。  
  
 デザイン パターンについてはドキュメントに記述します。一般に、これらのパーツが含まれます。  
  
-   名前。  
  
-   適用可能なコンテキストの説明。 このパターンを適用するときに開発者が考慮しなければならない条件。  
  
-   解決される問題の簡単な説明。  
  
-   主要なパーツおよびそれらの関係のモデル これらは、関連付けと依存関係を持つ、クラス、またはコンポーネントとインターフェイスである可能性があります。 これらの要素は、通常、次の 2 つのカテゴリに分類されます。  
  
    -   パターンを使用するコード中のすべての箇所に開発者が複製しなければならない要素。 テンプレートの型を使用すると、これらを記述することができます。 詳細については、次を参照してください。 [UML ユース ケース図: リファレンス](../modeling/uml-use-case-diagrams-reference.md)します。  
  
    -   開発者が使用しなければならないフレームワーク クラスを記述する要素。  
  
-   パーツ間の対話のモデル (シーケンス図またはアクティビティ図を使用)。  
  
-   名前付け規則。  
  
-   パターンが問題を解決する方法の説明。  
  
-   開発者が採用できるバリエーションの説明。  
  
## <a name="see-also"></a>関連項目  
 [UML モデルおよびダイアグラムを編集します。](../modeling/edit-uml-models-and-diagrams.md)   
 [コードを視覚化します。](../modeling/visualize-code.md)   
 [ユーザー要件のモデリング](../modeling/model-user-requirements.md)   
 [モデルからテストを開発します。](../modeling/develop-tests-from-a-model.md)   
 [開発プロセス内でのモデルの使用](../modeling/use-models-in-your-development-process.md)



