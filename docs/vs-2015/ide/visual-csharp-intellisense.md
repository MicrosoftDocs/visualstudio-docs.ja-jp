---
title: Visual C# の IntelliSense | Microsoft Docs
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-general
ms.topic: conceptual
helpviewer_keywords:
- IntelliSense [J#]
- Visual C#, IntelliSense
- IntelliSense [C#]
ms.assetid: 79ca304d-dc1e-4dc9-a2a6-7808df2e588e
caps.latest.revision: 26
author: gewarren
ms.author: gewarren
manager: jillfra
ms.openlocfilehash: ea48e1807291e935081f01e821cffafa794104f5
ms.sourcegitcommit: 1fc6ee928733e61a1f42782f832ead9f7946d00c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/22/2019
ms.locfileid: "60075760"
---
# <a name="visual-c-intellisense"></a>Visual C# の IntelliSense
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

Visual C# の IntelliSense は、エディターでコーディングする際、および[イミディエイト モード](../ide/reference/immediate-window.md) コマンド ウィンドウでデバッグしている間に使用可能です。  
  
## <a name="completion-lists"></a>入力候補一覧  
 Visual C# での IntelliSense コンプリート リストには、メンバーの一覧や入力候補などからのトークンが含まれています。 コンプリート リストでは、以下にすばやくアクセスできます。  
  
- 型または名前空間のメンバー  
  
- 変数、コマンド、および関数の名前  
  
- [コード スニペット](#CodeSnippets)  
  
- [言語キーワード](#Keywords)  
  
- [拡張メソッド](#ExtensionMethods)  
  
  C# でのコンプリート リストは非常に高機能でもあるため、コンテキストに基づいて、無関係なトークンを除外したり、トークンを事前に選択したりします。 詳細については、「[C# でフィルター処理されたコンプリート リスト](../misc/filtered-completion-lists-in-csharp.md)」および「[C# で事前に選択されたコンプリート リスト項目](../misc/pre-selected-completion-list-items-in-csharp.md)」を参照してください。  
  
### <a name="CodeSnippets"></a> コンプリート リストのコード スニペット  
 Visual C# のコンプリート リストには、コード スニペットが含まれており、事前に定義されたコードの本体をプログラムに簡単に挿入できます。 コード スニペットは、スニペットの [Shortcut 要素 (IntelliSense コード スニペット)](http://msdn.microsoft.com/052cc97a-5c70-42f8-b398-4c3adf670cfa) としてコンプリート リストに表示されます。  既定で Visual C# で利用できるコード スニペットの詳細については、「[Visual C# のコード スニペット](../ide/visual-csharp-code-snippets.md)」を参照してください。  
  
### <a name="Keywords"></a> コンプリート リストの言語キーワード  
 Visual C# のコンプリート リストには、言語キーワードも含まれています。 C# の言語キーワードの詳細については、「[C# のキーワード](http://msdn.microsoft.com/library/e929b0f2-4b92-4d37-8060-23d323b098ad)」を参照してください。  
  
### <a name="ExtensionMethods"></a> コンプリート リストでの拡張メソッド  
 Visual C# のコンプリート リストには、スコープ内にある拡張メソッドが含まれます。  
  
> [!NOTE]
>  Visual C# のコンプリート リストでは、<xref:System.String> オブジェクトのすべての拡張メソッドが表示されるわけではありません。  
  
 拡張メソッドでは、インスタンス メソッドとは異なるアイコンが使用されます。 表示されるアイコンの一覧については、「[[クラス ビュー] ウィンドウとオブジェクト ブラウザーのアイコン](../ide/class-view-and-object-browser-icons.md)」を参照してください。 同じ名前のインスタンス メソッドと拡張メソッドが両方ともスコープ内にある場合、コンプリート リストには拡張メソッドのアイコンが表示されます。  
  
### <a name="filtered-completion-lists"></a>フィルター処理されたコンプリート リスト  
 IntelliSense では、フィルターを使用して、不要なメンバーをコンプリート リストから削除します。  
  
 Visual C# では、次の項目用に表示されるコンプリート リストをフィルター処理します。  
  
- **インターフェイスおよび基本クラス**。 IntelliSense では、クラス宣言の基本およびインターフェイス リストおよび制約リストの両方で、インターフェイスおよび基本クラスのコンプリート リストから項目を自動的に削除します。 たとえば、列挙型は基本クラスのコンプリート リストには表示されません。これは、列挙型が基本クラスで使用できないためです。 基本クラスのコンプリート リストには、インターフェイスおよび名前空間だけが含まれます。 リストで項目を選択し、コンマを入力すると、コンプリート リストから基本クラスが削除されます。これは、Visual C# では多重継承がサポートされていないためです。 制約句の場合も、同様の動作になります。  
  
- **属性**:属性を型に適用した場合、コンプリート リストはフィルター処理され、<xref:System.Attribute> などそれらの型を含む名前空間からの型だけがリストに残ります。  
  
- `as` 演算子および `is` 演算子  
  
- **Catch 句**。  
  
- **オブジェクト初期化子:** 初期化できるメンバーだけがコンプリート リストに表示されます。  
  
- **new キーワード**:「`new`」と入力し、Space キーを押すと、コンプリート リストが表示されます。 コードの状況に応じて、リストの項目が自動的に選択されます。  たとえば、メソッドの宣言用と return ステートメント用の項目がコンプリート リストで自動的に選択されます。  
  
- **として演算子と is 演算子。**`as` または `is`  のキーワードを入力してから Space キーを押すと、フィルター処理されたコンプリート リストが自動的に表示されます。  
  
- イベント:キーワード `event` を入力した場合、コンプリート リストにはデリゲート型のみが含まれます。  
  
- パラメーターを入力すると、パラメーターに一致するメソッド オーバーロードが先頭になるよう、パラメーター ヘルプによって自動的に並べ替えが行われます。 複数のメソッド オーバーロードを使用できる場合は、上向きまたは下向きの矢印を使用し、一覧で次に使用できるオーバーロードに移動できます。  
  
## <a name="most-recently-used-members"></a>最近使用したメンバー  
 IntelliSense は、オブジェクト名の自動補完のために、ポップアップ [メンバーの一覧](../ide/using-intellisense.md)ボックスで最近選択したメンバーを記憶します。 次回メンバーの一覧を使用するときに、最近使用したメンバーが上部に表示されます。 最近使用したメンバーの履歴は、IDE の各セッションの間に消去されます。  
  
## <a name="override"></a>override  
 [override](http://msdn.microsoft.com/library/dd1907a8-acf8-46d3-80b9-c2ca4febada8) と入力してから Space キーを押すと、オーバーライドできる有効な基本クラス メンバーすべてが IntelliSense によりポップアップ リスト ボックスに表示されます。 `override` の後ろにメソッドの戻り値の型を入力すると、同じ型を返すメソッドのみが表示されます。 一致が見つからなかった場合はすべての基本クラスのメンバーが表示されます。  
  
## <a name="automatic-code-generation"></a>自動コード生成  
  
### <a name="add-using"></a>using を追加します。  
 using を追加する IntelliSense 操作の使用によって、作成中のコードにだけ集中できるので、それ以外の部分に注意を払う必要がなくなります。  
  
 using の追加操作を実行するには、解決できない型参照にカーソルを置きます。  たとえば、コンソール アプリケーションを作成し、`Main` メソッド本体に `XmlTextReader` を追加すると、解決できない型参照と見なされ、`XmlTextReader` の右端の文字の下にスマート タグが表示されます。  
  
 ![スマート タグ イメージを使用して追加](../ide/media/addusesmart.gif "AddUseSmart")  
  
 using を追加する機能は、**[IntelliSense]** メニューまたはコンテキスト メニューの **[競合の解決]** サブメニューから選択して呼び出します。また、スマート タグから呼び出すこともできます。 スマート タグは、バインドされていない型の上または横にカーソルが置かれた場合にのみ表示されます。  
  
 ![拡張スマート タグ イメージを使用して追加](../ide/media/addusesmartexp.gif "AddUseSmartExp")  
  
### <a name="organize-usings"></a>using の整理  
 **[using の整理]** オプションは、ソース コードの動作を変更することなく、`using` と `extern` の宣言を並べ替えおよび削除します。 時間の経過に伴い、不要で整理されていない `using` ディレクティブのために、ソース ファイルが肥大化して読みにくくなる場合があります。 **[using の整理]** オプションは、使用されない `using` ディレクティブを削除してソース コードをコンパクトにし、並べ替えて読みやすくします。  
  
 Visual Studio IDE で使用可能なオプションを参照するには、**[編集]** メニューで、**[IntelliSense]** をポイントしてから、**[using の整理]** をポイントします。 IDE には、`usings` ディレクティブの並び替えや削除に関する以下のオプションがあります。  
  
### <a name="implement-interface"></a>インターフェイスの実装  
 IntelliSense を使用すると、コード エディターでの作業中に[インターフェイス](http://msdn.microsoft.com/library/7da38e81-4f99-4bc5-b07d-c986b687eeba)を簡単に実装できます。 通常、インターフェイスを適切に実装するには、クラス内で、インターフェイスのすべてのメンバーについてメソッド宣言を作成する必要があります。 IntelliSense を使用した場合、クラス宣言でインターフェイスの名前を入力すると、スマート タグが表示されます。 スマート タグには、インターフェイスを自動的に実装する際のオプションが表示され、名前付けを明示的に行うか、暗黙的に行うかを選択できます。 明示的な名前付けを使用した場合、メソッド宣言にインターフェイス名が追加されます。逆に暗黙的な名前付けを使用した場合、メソッド宣言には所属するインターフェイスは明示されません。 明示的に名前付けされたインターフェイス メソッドには、インターフェイスのインスタンスからアクセスすることしかできず、クラスのインスタンスからアクセスすることはできません。 詳細については、「[明示的なインターフェイスの実装](http://msdn.microsoft.com/library/181c901f-0d4c-4f29-97fc-895079617bf2)」を参照してください。  
  
 インターフェイスの実装機能では、そのインターフェイスに必要な最低限の数のメソッド スタブが生成されます。 基本クラスにインターフェイスの一部だけが実装されている場合、これらのスタブは再生成されません。  
  
### <a name="implement-abstract-base-class"></a>抽象基本クラスの実装  
 IntelliSense には、コード エディターでの作業中、抽象基本クラスのメンバーを自動的に実装するためのオプションが用意されています。  通常、抽象基本クラスのメンバーを実装するには、派生クラスで抽象基本クラスのメソッドごとに新しいメソッド定義を作成する必要があります。 IntelliSense を使用した場合、クラス宣言で抽象基本クラスの名前を入力すると、スマート タグが表示されます。  このスマート タグで、基本クラスのメソッドを自動的に実装するためのオプションを選択できます。  
  
 抽象基本クラスの実装機能によって生成されるメソッド スタブは、MethodStub.snippet ファイルで定義されたコード スニペットがベースになります。 コード スニペットは変更できます。 詳細については、「[チュートリアル:コード スニペットを作成](../ide/walkthrough-creating-a-code-snippet.md)です。  
  
### <a name="generate-from-usage"></a>使用法から生成  
 **[使用法から生成]** 機能では、クラスとメンバーを定義する前にそれらを使用することができます。 使用されますが、まだ定義されていないクラス、コンストラクター、メソッド、プロパティ、フィールド、または列挙型に対してスタブを生成することができます。 コード内の現在の場所を離れずに、新しい型とメンバーを生成することができます。 これにより、ワークフローの中断を最小限にします。  
  
 未定義の識別子の下にそれぞれ波線の下線が表示されます。 識別子の上にマウス ポインターを置くと、ヒントにエラー メッセージが表示されます。  
  
 適切なオプションを表示するには、次の手順のいずれかを使用することができます。  
  
- 未定義の識別子をクリックします。 左端の文字の下に短い下線が表示されます。 短い下線の上にマウス ポインターを置くと、スマート タグ (アイコン) が表示されます。 スマート タグをクリックします。  
  
- 未定義の識別子をクリックして、Ctrl + .  (ピリオド) を押します。  
  
- 未定義の識別子を右クリックして、**[生成]** をクリックします。  
  
  表示されるオプションは、次のとおりです。  
  
- **プロパティ スタブの生成**  
  
- **フィールド スタブの生成**  
  
- **メソッド スタブの生成**  
  
- **クラスの生成**  
  
- **新しい型の生成** (クラス、構造体、インターフェイス、または列挙型)  
  
## <a name="generate-event-handlers"></a>イベント ハンドラーの生成  
 コード エディターで、IntelliSense はイベント フィールドにメソッド (イベント ハンドラー) をフックするのに役立ちます。  
  
 .cs ファイルのイベント フィールドの後に `+=` 演算子を入力すると、IntelliSense では Tab キーを押すオプションの使用が求められます。 これで、イベントを処理するメソッドを示すデリゲートの新しいインスタンスを挿入します。  
  
 ![オート フック ボタン](../ide/media/vxautohookup.gif "vxAutoHookUp")  
  
 Tab キーを押すと、IntelliSense は自動的にステートメントを完了し、コード エディターに選択されたテキストとしてイベント ハンドラーの参照を表示します。 自動イベント フックアップを完了するには、IntelliSense はイベント ハンドラーの空のスタブを作成するために、もう一度 Tab キーを押すように要求します。  
  
 ![イベント ハンドラーの作成](../ide/media/vxgenerateeventhandler.gif "vxGenerateEventHandler")  
  
> [!NOTE]
>  IntelliSense によって作成された新しいデリゲートが既存のイベント ハンドラーを参照する場合、IntelliSense はヒントのこの情報と通信します。 その後、この参照を変更できます。テキストはコード エディターで既に選択されています。 それ以外の場合、自動イベント フックアップはこの時点で完了します。  
  
 Tab キーを押すと、IntelliSense は正しいシグネチャでメソッドをスタブして、イベント ハンドラーの本体にカーソルを置きます。  
  
> [!NOTE]
>  **[ビュー]** メニュー (Ctrl + -) の **[戻る]** コマンドを使用して、イベント フックアップ ステートメントに戻ります。  
  
 次のタスクは、IntelliSense が `button1_Click` という名前のイベント ハンドラーを、`button1.Click` という名前のイベント フィールドに自動的にフックアップする方法について示しています。  
  
## <a name="see-also"></a>関連項目  
 [Visual Studio IDE](../ide/visual-studio-ide.md)
