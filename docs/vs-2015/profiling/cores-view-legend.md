---
title: コア ビューの凡例 | Microsoft Docs
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-debug
ms.topic: conceptual
f1_keywords:
- vs.cv.cores.legend
helpviewer_keywords:
- Concurrency Visualizer, Cores View Legend
ms.assetid: e160384c-fcfe-49b3-86b7-229adb736c51
caps.latest.revision: 17
author: MikeJo5000
ms.author: mikejo
manager: jillfra
ms.openlocfilehash: 05f768f6ff928ab00ebbd503c1ae9826dab8cd38
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/02/2020
ms.locfileid: "68161308"
---
# <a name="cores-view-legend"></a>コア ビューの凡例
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

コア ビューの凡例では、各スレッドが色と名前で示されます。 クロスコアのコンテキスト スイッチの回数、コンテキスト スイッチの合計回数、クロスコアのコンテキスト スイッチの割合を示す列が含まれます。 凡例の行は、クロスコアのコンテキスト スイッチの回数が多い順に並べられています。  
  
 凡例で行を選んで、タイムラインに表示されるスレッドをフィルター処理できます。 選んだスレッドのみがタイムラインに表示されます。 行を選ばないと、すべての行がタイムラインに表示されます。  
  
 同じ論理コア内でのコンテキスト スイッチより、クロスコアのコンテキスト スイッチの方が、オーバーヘッドとパフォーマンスのコストが大きくなります。 コンテキスト スイッチでは、プロセッサのレジスタが保存されて復元され、オペレーティング システムのカーネル コードが実行され、変換ルックアサイド バッファーのエントリが再度読み込まれて、プロセッサのパイプラインがフラッシュされます。 クロスコアのコンテキスト スイッチでは、キャッシュ データが別のコア上のこのスレッドに対して無効なため、他のコンテキスト スイッチよりさらに負荷が大きくなります。 これに対し、同じコア上でのコンテキスト スイッチの場合は、有効なデータがまだキャッシュに存在する可能性があります。 スレッド アフィニティを管理しようとしてクロスコアのコンテキスト スイッチが増加し、パフォーマンスが低下する場合は、この問題に対処するかどうかを検討してください。 最初にスレッド アフィニティを除去して、クロスコアの動作を確認します。  
  
 次の表では凡例の要素について説明します。  
  
|要素|定義|  
|-------------|----------------|  
|スレッド名|前のコア タイムラインでのスレッドの色と、そのスレッドの名前が示されます。|  
|クロス コアのコンテキスト スイッチ|異なる論理コア間で行われた、スレッドのコンテキスト スイッチの回数。 異なるプロセッサ ダイ間のクロスコア コンテキスト スイッチと、同じダイ上でのスイッチは、区別されません。|  
|合計コンテキスト スイッチ数|サンプリング期間中に特定のスレッドでのコンテキスト スイッチの合計回数。 スレッドのコンテキストが変わるたびに (たとえば、実行から同期に)、コンテキスト スイッチが 1 回カウントされます。|  
|クロス コアのコンテキスト スイッチの割合|クロスコア コンテキスト スイッチの回数をコンテキスト スイッチの合計回数で割った割合として計算されます。 この割合が高いほど、この特定のスレッドのパフォーマンスに対するクロスコア コンテキスト スイッチのオーバーヘッドの全体的な影響が大きくなります。|  
  
## <a name="see-also"></a>参照  
 [コア ビュー](../profiling/cores-view.md)
