---
title: アプリケーション パターン
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-sdk
ms.topic: conceptual
ms.assetid: 8ed68602-4e28-46fe-b39f-f41979b308a2
caps.latest.revision: 8
ms.author: gregvanl
manager: jillfra
ms.openlocfilehash: cc14aadfafb16fcae571ab66e5811ea465cb55a9
ms.sourcegitcommit: 26178b116cbf7353fee6ca989b8d872114f7b405
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/01/2020
ms.locfileid: "89284415"
---
# <a name="application-patterns-for-visual-studio"></a>Visual Studio のアプリケーション パターン
[!INCLUDE[vs2017banner](../../includes/vs2017banner.md)]

## <a name="window-interactions"></a><a name="BKMK_WindowInteractions"></a> ウィンドウの相互作用

### <a name="overview"></a>概要
 Visual Studio で使用される2つの主なウィンドウの種類は、ドキュメントエディターとツールウィンドウです。 まれですが、可能なのは、大きなモードレスダイアログです。 これらはすべてモードレスであり、シェルでは、パターンが基本的に異なります。 このトピックでは、ドキュメントウィンドウ、ツールウィンドウ、モードレスダイアログの違いについて説明します。 モーダルダイアログのパターンについて [は、ダイアログで説明](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Dialogs)します。

### <a name="comparing-window-usage-patterns"></a>ウィンドウの使用パターンの比較
 ドキュメント**ウィンドウ**は、ほとんどの場合、ドキュメントウェル内に表示されます。 これにより、補助ツールウィンドウを配置するための "センターステージ" がドキュメントエディターに与えられます。

 **ツールウィンドウ**は、多くの場合、別の小さなウィンドウとして表示されます。これは、IDE の端に対して折りたたまれて表示、非表示、または自動非表示にすることができます。 ただし、ウィンドウの **ウィンドウ/ドッキング** プロパティをオフにすることで、ドキュメントウェル内に表示されることがあります。 これにより、より大きな効果が得られます。また、Visual Studio に統合しようとすると、機能によってツールウィンドウとドキュメントウィンドウのどちらを表示するかを決定する必要があります。

 Visual Studio では、**モードレスダイアログ**は推奨されません。 大きな範囲の場合は、定義上、フローティングツールウィンドウであり、そのように実装する必要があります。 通常のツールウィンドウのサイズがシェルの辺にドッキングされている場合、モードレスダイアログが許可されます。 また、ユーザーがダイアログをセカンダリモニターに移動する可能性がある場合にも許可されます。

 どのコンテナーの種類が必要かについては、慎重に検討してください。 次の表に、UI デザインの一般的な使用パターンに関する考慮事項を示します。

||ドキュメントウィンドウ|ツールウィンドウ|モードレスダイアログ|
|-|---------------------|-----------------|---------------------|
|**Position**|常にドキュメントウェル内に配置され、IDE の端にはドッキングされません。 メインシェルとは別にフローティングできるように、"プルオフ" にすることができます。|通常、タブは IDE の端の周りにドッキングされますが、フローティング、自動非表示 (固定解除)、またはドキュメントウェル内にドッキングするようにカスタマイズできます。|IDE とは別の大きなフローティングウィンドウ。|
|**コミットモデル**|*遅延コミット*<br /><br /> ドキュメントにデータを保存するには、ユーザーは [ファイル]、[保存]、[名前を付けて保存]、または [すべてを保存] コマンドを発行する必要があります。 ドキュメントウィンドウには、その中のデータの概念が "ダーティ" になり、保存コマンドの1つにコミットされます。 ドキュメントウィンドウを閉じると、すべての内容がディスクに保存されるか、または失われます。|*即時コミット*<br /><br /> 保存モデルはありません。 ファイルの編集を支援するインスペクターツールウィンドウでは、ファイルがアクティブなエディターまたはデザイナーで開かれていて、エディターまたはデザイナーが保存を所有している必要があります。|*遅延または即時コミット*<br /><br /> 多くの場合、大規模なモードレスダイアログでは、変更をコミットし、ダイアログセッション内で行われた変更をロールバックする "キャンセル" 操作を許可するアクションが必要です。  これにより、ツールウィンドウでは、ツールウィンドウのモードレスダイアログが常に即時コミットモデルになります。|
|**可視性**|*開く/作成 (ファイル) して閉じる*<br /><br /> ドキュメントウィンドウを開くには、既存のドキュメントを開くか、テンプレートを使用して新しいドキュメントを作成します。 "開く" コマンドはありません \<specific editor> 。|*表示/非表示*<br /><br /> 単一インスタンスのツールウィンドウは、非表示にしたり表示したりすることができます。 ツールウィンドウ内の内容と状態は、[表示] または [非表示] のいずれの場合でも保持されます。 複数インスタンスのツールウィンドウは、非表示にするだけでなく、閉じてもかまいません。 複数インスタンスのツールウィンドウが閉じている場合、ツールウィンドウ内のコンテンツと状態は破棄されます。|*コマンドから起動*<br /><br /> ダイアログは、タスクベースのコマンドから起動されます。|
|**選ぶ**|*複数インスタンス*<br /><br /> 複数のエディターを同時に開いて別のファイルを編集することもできますが、エディターによっては同じファイルを複数のエディターで開くこともできます ( **ウィンドウ > 新しいウィンドウ** のコマンド)。<br /><br /> 1つのエディターが1つまたは複数のファイルを同時に編集している可能性があります (プロジェクトデザイナー)。|*1つまたは複数のインスタンス*<br /><br /> コンテンツは、コンテキスト (プロパティブラウザーと同様) を反映するか、他のウィンドウ (タスク一覧、ソリューションエクスプローラー) にフォーカスまたはコンテキストをプッシュするように変更されます。<br /><br /> 単一インスタンスと複数インスタンスの両方のツールウィンドウは、特に重要な理由がない限り、アクティブなドキュメントウィンドウに関連付けられている必要があります。|*単一インスタンス*|
|**使用例**|コードエディターなどの**テキストエディター**<br /><br /> フォームデザイナーやモデリング画面などの**デザインサーフェイス**<br /><br /> マニフェストデザイナーなど、**ダイアログと同様のレイアウトを制御**します。|**ソリューションエクスプローラー**には、ソリューション内に含まれるソリューションとプロジェクトが用意されています。<br /><br /> **サーバーエクスプローラー**には、ユーザーがウィンドウで開くことを選択したサーバーとデータ接続の階層ビューが用意されています。 クエリなどのデータベース階層からオブジェクトを開くと、ドキュメントウィンドウが開き、ユーザーがクエリを編集できるようになります。<br /><br /> **プロパティブラウザー**には、ドキュメントウィンドウまたは別のツールウィンドウで選択されたオブジェクトのプロパティが表示されます。 これらのプロパティは、階層的なグリッドビューまたは複雑なダイアログに似たコントロールで表示され、ユーザーはこれらのプロパティの値を設定できます。||

## <a name="tool-windows"></a><a name="BKMK_ToolWindows"></a> ツールウィンドウ

### <a name="overview"></a>概要
 ツールウィンドウは、ドキュメントウィンドウで発生するユーザーの作業をサポートします。 これらは、Visual Studio が提供し操作できる基本的なルートオブジェクトを表す階層を表示するために使用できます。

 IDE で新しいツールウィンドウを検討する場合、作成者は次のことを行う必要があります。

- タスクに適した既存のツールウィンドウを使用し、同様の機能を持つ新しいツールウィンドウを作成することはできません。 新しいツールウィンドウを作成するのは、似たウィンドウに統合できない、または既存のウィンドウをピボットハブに変換することができない、大幅に異なる "ツール" が提供されている場合だけにしてください。

- 必要に応じて、ツールウィンドウの上部に標準のコマンドバーを使用します。

- コントロールの表示とキーボードナビゲーションのために、他のツールウィンドウに既に存在するパターンとの一貫性を確保します。

- 他のツールウィンドウでのコントロールの表示との一貫性を確保します。

- ドキュメント固有のツールウィンドウは、親ドキュメントがアクティブになったときにのみ表示されるように、可能な場合は自動的に表示される必要があります。

- キーボードでウィンドウコンテンツがナビゲート可能であることを確認します (方向キーをサポートします)。

#### <a name="tool-window-states"></a>ツールウィンドウの状態
 Visual Studio ツールウィンドウの状態は異なります。その中には、ユーザーがアクティブ化するもの (自動非表示機能など) があります。 オート参照などの他の状態では、ツールウィンドウを正しいコンテキストで表示し、不要な場合は非表示にすることができます。 合計で5つのツールウィンドウの状態があります。

- **ドッキングまたは固定** されたツールウィンドウは、ドキュメント領域の4辺のいずれかに接続できます。 プッシュピンアイコンがツールウィンドウのタイトルバーに表示されます。 ツールウィンドウは、シェルとその他のツールウィンドウの端に沿って水平方向または垂直方向にドッキングでき、タブでリンクすることもできます。

- **自動非表示** ツールウィンドウは固定解除されています。 ウィンドウは、ドキュメント領域の端にタブ (ツールウィンドウの名前とアイコン) が表示されたままになります。 ツールウィンドウは、ユーザーがタブの上にマウスを置いたときにスライドアウトします。

- 自動的に**表示**されるツールウィンドウは、エディターなどの別の UI が起動されるか、フォーカスが得られると自動的に表示されます。

- **フローティング** ツールウィンドウを IDE の外側に移動します。 これは、マルチモニターの構成に便利です。

- **タブ付きドキュメント** ツールウィンドウは、ドキュメントウェル内にドッキングできます。 これは、オブジェクトブラウザーなどの大規模なツールウィンドウで、フレームの端にドッキングした場合よりも、より実際に使用する必要がある場合に便利です。

  ![Visual Studio でのツール ウィンドウの状態](../../extensibility/ux-guidelines/media/0702-01-toolwindowstates.png "0702-01_ToolWindowStates")

  **Visual Studio でのツール ウィンドウの状態**

#### <a name="single-instance-and-multi-instance"></a>単一インスタンスと複数インスタンス
 ツールウィンドウは、単一インスタンスまたは複数インスタンスです。 いくつかの単一インスタンスツールウィンドウは、アクティブなドキュメントウィンドウに関連付けられている場合がありますが、マルチインスタンスツールウィンドウには関連付けられない場合があります。 複数インスタンスツールウィンドウは、ウィンドウの新しいインスタンスを作成することによって、ウィンドウ/新しいウィンドウコマンドに応答します。 次の図は、ウィンドウのインスタンスがアクティブなときに [新しいウィンドウ] コマンドを有効にするツールウィンドウを示しています。

 ![Visual Studio でツール ウィンドウを有効にするコマンド](../../extensibility/ux-guidelines/media/0702-02-toolwindowenablingcommand.png "0702-02_ToolWindowEnablingCommand")

 **ウィンドウのインスタンスがアクティブなときに ' 新しいウィンドウ ' コマンドを有効にするツールウィンドウ**

 単一インスタンスツールウィンドウは非表示にしたり表示したりすることができますが、マルチインスタンスツールウィンドウは閉じたり、非表示にしたりすることもできます。 すべてのツールウィンドウは、ドッキング、タブリンク、フローティング、またはマルチドキュメントインターフェイス (MDI) 子ウィンドウとして設定できます (ドキュメントウィンドウに似ています)。 すべてのツールウィンドウは、[ウィンドウ] メニューの適切なウィンドウ管理コマンドに応答する必要があります。

 ![Visual Studio でのウィンドウの管理コマンド](../../extensibility/ux-guidelines/media/0702-03-windowmanagementcontrols.png "0702-03_WindowManagementControls")

 **Visual Studio の [ウィンドウ] メニューのウィンドウ管理コマンド**

#### <a name="document-specific-tool-windows"></a>ドキュメント固有のツールウィンドウ
 一部のツールウィンドウは、特定の種類のドキュメントに基づいて変更するように設計されています。 これらのウィンドウは、IDE のアクティブなドキュメントウィンドウに適用される機能を反映して更新されます。

 選択したエディターを反映するように内容を変更するツールウィンドウの例としては、ツールボックスとドキュメントアウトラインがあります。 ウィンドウにコンテキストを提供しないエディターにフォーカスがある場合、これらのウィンドウにはウォーターマークが表示されます。

#### <a name="navigable-list-tool-windows"></a>ナビゲーション可能リストツールウィンドウ
 一部のツールウィンドウには、ユーザーが操作できるナビゲーション可能な項目の一覧が表示されます。 この種類のウィンドウでは、ウィンドウがアクティブでない場合でも、リスト内の現在の項目に対するフィードバックが常に表示されます。 リストは、ウィンドウで現在選択されている項目を変更することで、 **GoToNextLocation** および **GoToPrevLocation** コマンドに応答する必要があります。

 誘導可能なリストツールウィンドウの例としては、ソリューションエクスプローラーと [検索結果] ウィンドウなどがあります。

### <a name="tool-window-types"></a>ツールウィンドウの種類

#### <a name="common-tool-windows-and-their-functions"></a>一般的なツールウィンドウとその機能

|型|ツールウィンドウ|関数|
|----------|-----------------|--------------|
|**Hierarchy**|ソリューション エクスプローラー|プロジェクト、その他のファイル、およびソリューション項目に含まれるドキュメントの一覧を表示する階層ツリー。 プロジェクト内の項目の表示は、プロジェクトの種類を所有するパッケージ (参照ベース、ディレクトリベース、混合モードなど) によって定義されます。|
|**Hierarchy**|クラス ビュー|ファイル自体に依存せず、ドキュメントのワーキングセット内のクラスおよびさまざまな要素の階層ツリー。|
|**Hierarchy**|[サーバー エクスプローラー]|ソリューション内のすべてのサーバーとデータ接続を表示する階層ツリー。|
|**Hierarchy**|ドキュメント アウトライン|アクティブなドキュメントの階層構造。|
|**グリッド**|プロパティ|選択したオブジェクトのプロパティの一覧と、それらのプロパティを編集するための値ピッカーを表示するグリッド。|
|**グリッド**|タスク一覧|ユーザーがタスクとコメントを作成/編集/削除できるグリッド。|
|**コンテンツ**|Help|"操作方法" から各種のヘルプを表示するためのさまざまな方法にユーザーがアクセスできるウィンドウです。 MSDN フォーラムへの動画。|
|**コンテンツ**|ダイナミック ヘルプを表示する|現在の選択項目に適用できるヘルプトピックへのリンクを表示するツールウィンドウ。|
|**コンテンツ**|オブジェクト ブラウザー|左ペインの階層オブジェクトコンポーネントの一覧と、右側の列のオブジェクトのプロパティとメソッドを含む2列のフレームセット。|
|**ダイアログ**|検索、高度な検索|ソリューション内のさまざまなファイルの検索と置換をユーザーに許可するダイアログ。|
|**その他**|ツールボックス|デザインサーフェイスにドロップされる要素を格納するために使用されるツールウィンドウ。これにより、すべてのデザイナーに一貫性のあるドラッグソースが提供されます。|
|**その他**|スタート ページ|開発者向けニュース、Visual Studio ヘルプ、最新のプロジェクトのフィードにアクセスできる、Visual Studio に対するユーザーのポータル。 また、カスタムスタートページを作成するには、"Common7\IDE\StartPages\" Visual Studio program files ディレクトリから Visual Studio documents ディレクトリの StartPages フォルダーに StartPage ファイルをコピーし、手動で XAML を編集するか、Visual Studio または別のコードエディターで開くこともできます。|
|**デバッガー:** タスクのデバッグとアクティビティの監視に固有の windows のグループ|Autos||
|**デバッガー:** タスクのデバッグとアクティビティの監視に固有の windows のグループ|即時||
|**デバッガー:** タスクのデバッグとアクティビティの監視に固有の windows のグループ|出力|出力ウィンドウは、宣言するテキストイベントまたは状態がある場合にいつでも使用できます。|
|**デバッガー:** タスクのデバッグとアクティビティの監視に固有の windows のグループ|メモリ||
|**デバッガー:** タスクのデバッグとアクティビティの監視に固有の windows のグループ|ブレークポイント||
|**デバッガー:** タスクのデバッグとアクティビティの監視に固有の windows のグループ|実行中||
|**デバッガー:** タスクのデバッグとアクティビティの監視に固有の windows のグループ|Documents||
|**デバッガー:** タスクのデバッグとアクティビティの監視に固有の windows のグループ|呼び出し履歴||
|**デバッガー:** タスクのデバッグとアクティビティの監視に固有の windows のグループ|ローカル||
|**デバッガー:** タスクのデバッグとアクティビティの監視に固有の windows のグループ|」||
|**デバッガー:** タスクのデバッグとアクティビティの監視に固有の windows のグループ|逆アセンブリ||
|**デバッガー:** タスクのデバッグとアクティビティの監視に固有の windows のグループ|レジスタ||
|**デバッガー:** タスクのデバッグとアクティビティの監視に固有の windows のグループ|Threads||

## <a name="document-editor-conventions"></a><a name="BKMK_DocumentEditorConventions"></a> ドキュメントエディターの規則

### <a name="document-interactions"></a>ドキュメントの相互作用
 "ドキュメントウェル" は IDE 内の最大の領域であり、ユーザーがタスクを完了するために特に注目しているのは、補足ツールウィンドウで支援されています。 ドキュメントエディターは、ユーザーが Visual Studio 内で開いて保存する作業の基本単位を表します。 ソリューションエクスプローラーまたはその他のアクティブな階層ウィンドウに関連付けられている選択の強力な意味を保持します。 ユーザーは、これらの階層ウィンドウのいずれかをポイントし、ドキュメントが含まれている場所と、Visual Studio パッケージによって提供されるソリューション、プロジェクト、または別のルートオブジェクトとの関係を把握できる必要があります。

 ドキュメントの編集には、一貫したユーザーエクスペリエンスが必要です。 ユーザーがウィンドウ管理やコマンドの検索ではなく作業に集中できるようにするには、そのドキュメントの種類を編集するためのユーザータスクに最適なドキュメントビューの方法を選択します。

#### <a name="common-interactions-for-the-document-well"></a>ドキュメントウェルの一般的な対話

- 「 **新しいファイル** と **ファイルを開く** 」の一般的なエクスペリエンスで、一貫性のある相互作用モデルを維持します。

- ドキュメントウィンドウが開いたときに、関連するウィンドウおよびメニューの関連機能を更新します。

- メニューコマンドは、[ **編集**]、[ **書式**]、[ **表示** ] メニューなどの一般的なメニューに適切に統合されています。 大量の特化したコマンドが使用可能な場合は、ドキュメントにフォーカスがあるときにのみ表示される新しいメニューを作成できます。

- 埋め込みツールバーは、エディターの上部に配置できます。 これは、エディターの外に別のツールバーを表示する場合に適しています。

- ソリューションエクスプローラーまたは同様の [アクティブな階層] ウィンドウで常に選択を維持します。

- ソリューションエクスプローラー内のドキュメントをダブルクリックすると、 **開い**たときと同じ操作が実行されます。

- 1つのドキュメントの種類で複数のエディターを使用できる場合、ユーザーは [ファイルを **開くアプリケーション** の選択] ダイアログボックスでファイルを右クリックし、ショートカットメニューの [ファイルを **開くアプリケーション** の選択] をクリックして、特定のドキュメントの種類の既定の操作を上書きまたはリセットできる必要があります。

- ドキュメントウェルでウィザードを構築しないでください。

### <a name="user-expectations-for-specific-document-types"></a>特定のドキュメントの種類に対するユーザーの期待
 ドキュメントエディターにはいくつかの基本的な種類があり、それぞれには同じ種類の他のユーザーと一貫性のある一連の相互作用があります。

- **テキストベースのエディター:** コードエディター、ログファイル

- **デザインサーフェイス:** WPF フォームデザイナー、Windows フォーム

- **ダイアログスタイルエディター:** マニフェストデザイナー、プロジェクトプロパティ

- **モデルデザイナー:** ワークフローデザイナー、codemap、アーキテクチャ図、進行状況

  ドキュメントウェルを使用するエディター以外の型もいくつかあります。 ドキュメント自体を編集することはありませんが、ドキュメントウィンドウの標準的な対話に従う必要があります。

- **レポート:** IntelliTrace レポート、Hyper-v レポート、プロファイラーレポート

- **ダッシュボード:** 診断ハブ

#### <a name="text-based-editors"></a>テキストベースのエディター

- ドキュメントは [プレビュー] タブモデルに含まれており、ドキュメントを開くことなくプレビューできます。

- ドキュメントの構造は、ドキュメントアウトラインなどのコンパニオンツールウィンドウ内で表現できます。

- IntelliSense (該当する場合) は、他のコードエディターと一貫して動作します。

- ポップアップまたは補助 UI は、CodeLens など、既存の同様の UI に似たスタイルとパターンに従います。

- ドキュメントの状態に関するメッセージは、ドキュメントの上部またはステータスバーに表示されます。

- ユーザーは、[共有フォントおよび色] ページまたはエディター固有の [ **ツール > オプション** ] ページを使用して、フォントおよび色の外観をカスタマイズできる必要があります。

#### <a name="design-surfaces"></a>デザインサーフェイス

- 空のデザイナーには、開始方法を示すウォーターマークが画面に表示されます。

- ビュー切り替えメカニズムは、ダブルクリックなどの既存のパターンに従ってコードエディターを開くか、ドキュメントウィンドウ内のタブを使用して両方のペインとの対話を可能にします。

- 特別なツールウィンドウが必要でない限り、デザインサーフェイスに要素を追加するには、ツールボックスを使用する必要があります。

- 画面上の項目は、一貫した選択モデルに従います。

- 埋め込みのツールバーには、ドキュメント固有のコマンドだけが含まれます。 **保存**などの一般的なコマンドは含まれません。

#### <a name="dialog-style-editors"></a>ダイアログスタイルエディター

- コントロールレイアウトは、通常のダイアログレイアウト規則に従う必要があります。

- エディター内のタブは、ドキュメントタブの外観と一致しないようにする必要があります。これらは、許可されている2つの内部タブスタイルのいずれかと一致している必要があります。

- ユーザーは、キーボードのみを使用してコントロールと対話できる必要があります。エディターをアクティブにし、コントロールまたは標準のニーモニックを使用して tab キーを使用して、

- デザイナーでは、共通の保存モデルを使用する必要があります。 [保存] または [コミット] ボタンの全体を画面に配置する必要はありませんが、他のボタンは適切な場合があります。

#### <a name="model-designers"></a>モデルデザイナー

- 空のデザイナーには、開始方法を示すウォーターマークが画面に表示されます。

- デザインサーフェイスに要素を追加するには、ツールボックスを使用する必要があります。

- 画面上の項目は、一貫した選択モデルに従います。

- 埋め込みのツールバーには、ドキュメント固有のコマンドだけが含まれます。 **保存**などの一般的なコマンドは含まれません。

- 画面に凡例が表示されることがあります。これは、指示または透かしのいずれかになります。

- ユーザーは、[共有フォントおよび色] ページまたはエディター固有の [ **ツール > オプション** ] ページを使用して、フォントや色の外観をカスタマイズできる必要があります。

#### <a name="reports"></a>Reports

- 通常、レポートは情報専用であり、保存モデルには参加しません。 ただし、展開や折りたたみを行う他の関連情報やセクションへのリンクなど、相互作用が含まれる場合があります。

- 画面上のほとんどのコマンドは、ボタンではなくハイパーリンクにする必要があります。

- レイアウトにはヘッダーを含め、標準的なレポートレイアウトガイドラインに従う必要があります。

#### <a name="dashboards"></a>ダッシュボード

- ダッシュボードには相互作用モデルはありませんが、他のさまざまなツールを提供する手段として機能します。

- これらは、保存モデルには参加しません。

- ユーザーは、エディターをアクティブにしてコントロールを編集するか、標準のニーモニックを使用することによって、キーボードのみを使用してコントロールを操作できる必要があります。

## <a name="dialogs"></a><a name="BKMK_Dialogs"></a> 対話

### <a name="introduction"></a>はじめに
 通常、Visual Studio のダイアログでは、ユーザーの作業の1単位単位がサポートされ、その後、破棄されます。

 ダイアログが必要であると判断した場合は、次の3つの選択肢があります。

1. 機能を Visual Studio の共有ダイアログの1つに統合します。

2. 既存の同様のダイアログで検出されたパターンを使用して、独自のダイアログを作成します。

3. 対話とレイアウトのガイドラインに従って、新しいダイアログを作成します。

   このトピックでは、Visual Studio ワークフロー内で適切なダイアログパターンを選択する方法と、ダイアログのデザインのための一般的な規則について説明します。

### <a name="themes"></a>テーマ
 Visual Studio のダイアログでは、次の2つの基本的なスタイルのいずれかに従います。

#### <a name="standard-unthemed"></a>標準 (テーマなし)
 ダイアログの大部分は標準ユーティリティダイアログであり、テーマを設定しないようにする必要があります。 一般的なコントロールを再テンプレートしたり、定型的な "最新の" ボタンまたはコントロールを作成したりしないでください。 コントロールと chrome の外観 [は、ダイアログボックスの標準の Windows デスクトップ相互作用ガイドライン](https://msdn.microsoft.com/library/windows/desktop/dn742499\(v=vs.85\).aspx)に従います。

#### <a name="themed"></a>テーマ
 特別な "署名" ダイアログのテーマを設定することができます。 テーマ付きダイアログには、スタイルに関連付けられている特殊な対話パターンもあります。 次の要件を満たしている場合にのみ、ダイアログのテーマを作成します。

- このダイアログは、よく見られる一般的なエクスペリエンスであり、多くのユーザー ([ **新しいプロジェクト** ] ダイアログボックスなど) で使用されます。

- このダイアログには、目立つ製品ブランド要素 ([ **アカウント設定** ] ダイアログなど) が含まれています。

- このダイアログは、他のテーマ付きダイアログを含む大きなフローの不可欠な部分として表示されます (たとえば、[ **接続済みサービスの追加** ] ダイアログ)。

- このダイアログは、製品バージョンを昇格または区別するための戦略的な役割を果たす、エクスペリエンスの重要な部分です。

  テーマ付きダイアログを作成する場合は、適切な環境の色を使用して、正しいレイアウトと相互作用のパターンに従います。 (「 [Visual Studio のレイアウト」を](../../extensibility/ux-guidelines/layout-for-visual-studio.md)参照してください)

### <a name="dialog-design"></a>ダイアログのデザイン
 適切にデザインされたダイアログでは、次の要素を考慮します。

- サポートされているユーザータスク

- ダイアログテキストのスタイル、言語、および用語

- 制御の選択肢と UI の規則

- ビジュアルレイアウトの指定とコントロールの配置

- キーボード アクセス

#### <a name="content-organization"></a>コンテンツ組織
 これらの基本的な種類のダイアログでは、次の点を考慮してください。

- [単純なダイアログ](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_SimpleDialogs) では、1つのモーダルウィンドウにコントロールが表示されます。 このプレゼンテーションには、フィールドピッカーやアイコンバーなど、複雑なコントロールパターンのバリエーションが含まれている場合があります。

- 1つの UI が複数のコントロールグループで構成されている場合は、レイヤー化された[ダイアログボックス](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_LayeredDialogs)を使用して、画面を最大限に活用できます。 ダイアログのグループ化は、タブコントロール、ナビゲーションリストコントロール、またはボタンを使用して、ユーザーが任意の時点で表示するグループを選択できるようにします。

- [ウィザード](../../extensibility/ux-guidelines/application-patterns-for-visual-studio.md#BKMK_Wizards) は、タスクの完了に向けた論理的な一連の手順をユーザーに指示する場合に便利です。 一連の選択肢が順次パネルに用意されており、前のパネルで選択した内容に応じて異なるワークフロー ("分岐") が導入されることがあります。

#### <a name="simple-dialogs"></a><a name="BKMK_SimpleDialogs"></a> 単純なダイアログ
 単純なダイアログは、1つのモーダルウィンドウ内のコントロールを表示するためのものです。 このプレゼンテーションには、フィールドピッカーなどの複雑なコントロールパターンのバリエーションが含まれている場合があります。 単純なダイアログの場合は、標準の一般的なレイアウトに加えて、複雑なコントロールのグループ化に必要な特定のレイアウトに従います。

 ![Visual Studio での単純なダイアログ](../../extensibility/ux-guidelines/media/0704-01-createstrongnamekey.png "0704-01_CreateStrongNameKey")

 **厳密な名前のキーの作成は、Visual Studio の単純なダイアログの例です。**

#### <a name="layered-dialogs"></a><a name="BKMK_LayeredDialogs"></a> レイヤードダイアログ
 階層化されたダイアログには、タブ、ダッシュボード、および埋め込みツリーが含まれます。 1つの UI に複数のコントロールグループが用意されている場合に、それらを最大限に活用するために使用されます。 グループ化されたグループ化により、ユーザーはいつでも表示するグループを選択できるようになります。

 最も単純なケースでは、グループ化を切り替えるメカニズムはタブコントロールです。 使用できる代替手段がいくつかあります。 最適なスタイルを選択する方法については、「優先順位付けとレイヤー化」を参照してください。

 [ **ツール > オプション** ] ダイアログボックスは、埋め込みツリーを使用したレイヤーダイアログの例です。

 ![Visual Studio での階層ダイアログ](../../extensibility/ux-guidelines/media/0704-02-toolsoptions.png "0704-02_ToolsOptions")

 **ツール > オプションは、Visual Studio の複数層のダイアログの例です。**

#### <a name="wizards"></a><a name="BKMK_Wizards"></a> ウィザード
 ウィザードは、タスクの完了時に論理的な一連の手順をユーザーに指示する場合に便利です。 連続したパネルに一連の選択肢が用意されています。ユーザーは、次の手順に進む前に各ステップを続行する必要があります。 十分な既定値を使用できるようになると、 **[完了** ] ボタンが有効になります。

 モーダルウィザードは、次のタスクに使用されます。

- 分岐が含まれます。ユーザーの選択に応じて異なるパスが提供されます。

- ステップ間の依存関係が含まれます。後続の手順は、前の手順のユーザー入力に依存します。

- UI を使用して、提供される選択肢と各手順の可能な結果を説明する必要がある。

- トランザクションはトランザクションであり、変更がコミットされる前に一連のステップが完全に完了する必要があります。

### <a name="common-conventions"></a>一般的な規則
 ダイアログで最適なデザインと機能を実現するには、ダイアログのサイズ、位置、標準、コントロールの構成と配置、UI テキスト、タイトルバー、コントロールボタン、およびアクセスキーに関する規則に従います。

 レイアウト固有のガイドラインについては、「 [Visual Studio のレイアウト](../../extensibility/ux-guidelines/layout-for-visual-studio.md)」を参照してください。

#### <a name="size"></a>Size
 ダイアログは最低 1024 x 768 の画面解像度に収まる必要があり、最初のダイアログサイズは900x700 ピクセルを超えないようにする必要があります。 ダイアログのサイズは変更できますが、必須ではありません。

 サイズ変更可能なダイアログには、次の2つの推奨事項があります。

1. 最小サイズは、ダイアログに対して定義されたで、クリッピングなしでコントロールセットを最適化し、妥当なローカライズ拡大に合わせて調整します。

2. ユーザーがスケーリングしたサイズはセッションからセッションに保持されます。 たとえば、ユーザーがダイアログを150% にスケーリングした場合、ダイアログの後続の起動は150% で表示されます。

#### <a name="position"></a>[位置]
 ダイアログは、最初の起動時に IDE 内の中央に表示される必要があります。 サイズ変更ができないダイアログの場合は、ダイアログの最後の位置を永続化する必要がないため、後続の起動時に中央に表示されます。 サイズ変更可能なダイアログの場合は、後で起動するときにサイズを永続化する必要があります。 モーダルであるサイズ変更可能なダイアログの場合、位置を永続化する必要はありません。 IDE 内でそれらを中央に表示すると、ユーザーの表示構成が変更されたときに、予期しない、または使用できない位置でダイアログが表示される可能性がなくなります。 サイズを再設定できるモードレスダイアログの場合、ダイアログは大規模なワークフローの不可欠な部分として頻繁に使用される可能性があるため、その後の起動時にユーザーの位置を維持する必要があります。

 ダイアログで他のダイアログを生成する必要がある場合は、最上位のダイアログボックスを親から右へ、または下に重ねて、新しい場所に移動したことをユーザーに明確にする必要があります。

#### <a name="modality"></a>モダリティ
 モーダルである場合は、続行する前にユーザーがダイアログを完了またはキャンセルする必要があることを意味します。 モーダルダイアログでは、ユーザーが環境の他の部分と対話できないようにするため、機能のタスクフローでは、できるだけ控えめに使用する必要があります。 モーダル操作が必要な場合、Visual Studio には、機能を統合できる多数の共有ダイアログが用意されています。 新しいダイアログを作成する必要がある場合は、同様の機能を持つ既存のダイアログの相互作用パターンに従います。

 新しいコードを記述しているときに、 **検索** と **置換** など、2つのアクティビティを同時に実行する必要がある場合、ダイアログはモードレスであるため、ユーザーは簡単に切り替えることができます。 通常、Visual Studio では、この種類のエディターでサポートされているリンクタスクにツールウィンドウを使用します。

#### <a name="control-configuration"></a>制御の構成
 Visual Studio で同じことを実現する既存のコントロール構成との一貫性を確保します。

#### <a name="title-bars"></a>タイトル バー

- タイトルバーのテキストには、それを起動したコマンドの名前が反映されている必要があります。

- ダイアログのタイトルバーにはアイコンを使用できません。 システムで必要な場合は、Visual Studio のロゴを使用します。

- ダイアログには、最小化ボタンと最大化ボタンを含めることはできません。

- タイトルバーの [ヘルプ] ボタンは非推奨となりました。 新しいダイアログに追加しないでください。 存在する場合は、タスクに関連するヘルプトピックを起動する必要があります。

  ![Visual Studio のタイトル バーの仕様](../../extensibility/ux-guidelines/media/0704-03-titlebarspecs.png "0704-03_TitleBarSpecs")

  **Visual Studio ダイアログのタイトルバーのガイドライン仕様。**

#### <a name="control-buttons"></a>コントロールボタン
 一般に、[OK] を**クリック**すると、 / **Cancel** / ダイアログボックスの右下隅に [**ヘルプ**のキャンセル] ボタンが横方向に配置されます。 ダイアログボックスの下部に、コントロールボタンと視覚的な混乱をもたらすボタンが他にもある場合は、代替の垂直スタックが許可されます。

 ![Visual Studio でのコントロール ボタンの構成](../../extensibility/ux-guidelines/media/0704-04-controlbuttonconfig.png "0704-04_ControlButtonConfig")

 **Visual Studio ダイアログのコントロールボタンの許容される構成**

 ダイアログには、既定のコントロールボタンが含まれている必要があります。 既定として使用する最適なコマンドを決定するには、次のオプションの中から選択します (優先順位順に記載されています)。

- 既定として [最も安全で安全性の高い] コマンドを選択します。 これは、データ損失を防ぎ、意図しないシステムアクセスを避けるために、最も可能性の高いコマンドを選択することを意味します。

- データの損失とセキュリティが要因ではない場合は、利便性に基づいて既定のコマンドを選択します。 最も可能性の高いコマンドを既定値として含めると、ダイアログが頻繁にまたは繰り返し実行されるタスクをサポートする場合に、ユーザーのワークフローが向上します。

  既定のコマンドに対して永続的に破壊的な操作を選択しないでください。 そのようなコマンドが存在する場合は、代わりに、より安全なコマンドを既定値として選択します。

#### <a name="access-keys"></a>アクセス キー
 **OK** / **キャンセル**の / **ヘルプ**ボタンにアクセスキーは使用しないでください。 これらのボタンは、既定ではショートカットキーにマップされます。

|ボタン名|ショートカット キー|
|-----------------|-----------------------|
|OK|次に、|
|キャンセル|Esc|
|Help|F1|

#### <a name="imagery"></a>画像
 ダイアログでは、画像を控えめに使用します。 スペースを使用するためだけに、ダイアログで大きいアイコンを使用しないでください。 画像は、警告アイコンや状態アニメーションなど、ユーザーにメッセージを伝えるための重要な部分である場合にのみ使用してください。

### <a name="prioritizing-and-layering"></a><a name="BKMK_PrioritizingAndLayering"></a> 優先順位付けとレイヤー化

#### <a name="prioritizing-your-ui"></a>UI の優先順位付け
 特定の UI 要素を forefront に取り込み、より高度な動作とオプション (わかりにくいコマンドを含む) をダイアログに配置することが必要になる場合があります。 ダイアログが表示されたときに、一般的に使用される機能を forefront に提供します。また、ダイアログを表示するときに、UI に既定でテキストラベルを表示するようにします。

#### <a name="layering-your-ui"></a>UI のレイヤー化
 ダイアログが必要であると判断したが、ユーザーに提示する関連機能が簡単なダイアログに表示できない場合は、UI をレイヤー化する必要があります。 Visual Studio で使用される最も一般的なレイヤー方法は、タブと廊下、またはダッシュボードです。 場合によっては、展開および折りたたみが可能な領域が適切な場合があります。 通常、アダプティブ UI は Visual Studio では推奨されません。

 タブに似たコントロールを使用して UI をレイヤー化する方法には、さまざまな利点と欠点があります。 以下の一覧を確認して、状況に適したレイヤー化手法を選択していることを確認してください。

##### <a name="tabbing"></a>タブ移動

|切り替えメカニズム|長所と適切な使用方法|欠点と不適切な使用|
|-------------------------|------------------------------------|-----------------------------------------|
|タブ コントロール|ダイアログページを論理的に関連するセットにグループ化する<br /><br /> ダイアログ内の関連するコントロールの5未満 (またはダイアログボックスの1行に表示されるタブの数) に役立ちます。<br /><br /> タブラベルは、コンテンツを簡単に識別できる1つまたは2つの単語である必要があります。<br /><br /> 共通のシステムダイアログスタイル<br /><br /> 例: **ファイルエクスプローラー > 項目のプロパティ**|わかりやすい短いラベルを作成するのは難しい場合がある<br /><br /> 通常は、1つのダイアログで5つ以上のタブをスケールしません。<br /><br /> 1つの行に複数のタブがある場合は不適切です。代替のレイヤー化手法を使用する<br /><br /> 拡張不可|
|サイドバーのナビゲーション|タブよりも多くのカテゴリに対応できる単純な切り替えデバイス<br /><br /> カテゴリの単純なリスト (階層なし)<br /><br /> 拡張可能<br /><br /> 例: **カスタマイズ... > コマンドの追加**|グループが3つ未満の場合は、水平方向のスペースを使用するのが適切ではありません。<br /><br /> タスクはドロップダウンにより適している可能性があります|
|ツリー コントロール|無制限のカテゴリを許可<br /><br /> カテゴリのグループ化や階層化を可能にします。<br /><br /> 拡張可能<br /><br /> 例: **ツール > オプション**|入れ子になった階層が多いと、水平スクロールが過剰になる場合がある<br /><br /> Visual Studio のツリービューが過剰になっている|
|ウィザード|タスクベースの順次的な手順を実行して、タスクの完了を支援します。 このウィザードは高レベルのタスクを表し、個々のパネルはタスク全体を実現するために必要なサブタスクを表します。<br /><br /> ユーザーが複数のエディターとツールウィンドウを使用してタスクを完了する必要がある場合と同様に、タスクが Ui 境界を越える場合に便利です。<br /><br /> タスクに分岐が必要な場合に便利です。<br /><br /> タスクにステップ間の依存関係が含まれている場合に便利です。<br /><br /> 複数の同様のタスクを1つのダイアログに表示して、同じようなダイアログの数を減らすことができる場合に便利です。|シーケンシャルワークフローを必要としないタスクには適していません。<br /><br /> ウィザードによって混乱を招き、手順が多すぎると、ユーザーが混乱する可能性があります<br /><br /> ウィザードの画面が本質的に制限されている|

##### <a name="hallways-or-dashboards"></a>廊下またはダッシュボード
 廊下とダッシュボードは、他のダイアログやウィンドウへのポイントの起動として機能するダイアログまたはパネルです。 適切に設計された "廊下" では、最も一般的なオプション、コマンド、および設定のみがすぐに反映されるため、ユーザーは簡単に一般的なタスクを実行できます。 現実世界の廊下と同様に、doorways は、その背後にある部屋にアクセスすることができます。ここでは、あまり一般的ではない UI が、メインの廊下からアクセスできる関連機能の個別の "ルーム" (多くの場合は他のダイアログ) に収集されます。

 または、あまり一般的ではない機能を別の場所にリファクタリングするのではなく、単一のコレクションで使用可能なすべての機能を提供する UI は単なるダッシュボードです。

 ![Outlook での廊下の概念](../../extensibility/ux-guidelines/media/0704-08-hallway.png "0704-08_Hallway")

 **廊下 Outlook で追加の UI を公開するための概念**

##### <a name="adaptive-ui"></a>アダプティブ UI
 使用状況またはユーザーの自己報告エクスペリエンスに基づいて UI を表示または非表示にすることは、必要な UI を表示しながら他の部分を非表示にするもう1つの方法です。 これは、Visual Studio では、UI を表示するか非表示にするかを決定するためのアルゴリズムが複雑になる可能性があるため、この方法は推奨されません。一部のケースでは、規則が常に間違っています。

## <a name="projects"></a><a name="BKMK_Projects"></a> イベント

### <a name="projects-in-the-solution-explorer"></a>ソリューションエクスプローラー内のプロジェクト
 ほとんどのプロジェクトは、参照ベース、ディレクトリベース、または混合として分類されます。 3種類のプロジェクトはすべて、ソリューションエクスプローラーで同時にサポートされます。 プロジェクトを操作する際のユーザーエクスペリエンスのルートは、このウィンドウ内で行われます。 プロジェクトノードは参照、ディレクトリ、または混合モードのプロジェクトですが、プロジェクト固有のユーザーパターンに左右逆方向する前に、一般的な相互作用パターンを出発点として適用する必要があります。

 プロジェクトは常に次のようになります。

- プロジェクトの内容を整理するためのプロジェクトフォルダーの追加機能のサポート

- プロジェクトの永続化のための一貫したモデルを維持する

  プロジェクトでは、次の場合に一貫性のある相互作用モデルも保持する必要があります。

- プロジェクト項目の削除

- 保存 (ドキュメントを)

- プロジェクトプロパティの編集

- 代替ビューでのプロジェクトの編集

- ドラッグアンドドロップ操作

### <a name="drag-and-drop-interaction-model"></a>ドラッグアンドドロップによる相互作用モデル
 プロジェクトは、通常、参照ベース (ストレージ内のプロジェクト項目への参照のみを保持できる)、ディレクトリベース (プロジェクトの階層内に物理的に格納されているプロジェクト項目のみを永続化できる)、または混合 (参照または物理項目を保持できる) として分類されます。 IDE では、3種類のプロジェクトすべてを **ソリューションエクスプローラー**内で同時に実行できます。

 ドラッグアンドドロップの観点からは、次の特性を **ソリューションエクスプローラー**内のプロジェクトの種類ごとに適用する必要があります。

- **参照ベースのプロジェクト:** 重要な点は、プロジェクトがストレージ内の項目への参照を囲むようにドラッグしていることです。 参照ベースのプロジェクトが移動操作のソースとして機能する場合、プロジェクトから項目への参照のみを削除する必要があります。 実際には、この項目をハードドライブから削除しないでください。 参照ベースのプロジェクトが移動 (またはコピー) 操作のターゲットとして機能する場合は、項目のプライベートコピーを作成せずに、元のソース項目への参照を追加する必要があります。

- **ディレクトリベースのプロジェクト:** ドラッグアンドドロップの観点から見ると、プロジェクトでは、参照ではなく物理的な項目をドラッグしています。 ディレクトリベースのプロジェクトが移動操作のソースとして機能する場合は、最終的には、物理項目をハードドライブから削除するだけでなく、プロジェクトから削除する必要があります。 ディレクトリベースのプロジェクトは、移動 (またはコピー) 操作のターゲットとして機能する場合、ターゲットの場所にソース項目のコピーを作成する必要があります。

- **混合ターゲットプロジェクト:** ドラッグアンドドロップの観点から見ると、この種類のプロジェクトの動作は、ドラッグされている項目の性質 (ストレージ内の項目への参照または項目自体) に基づいています。 参照と物理項目の正しい動作は、前述のとおりです。

  **ソリューションエクスプローラー**にプロジェクトの種類が1つしかない場合、ドラッグアンドドロップ操作が簡単になります。 各プロジェクトシステムは独自のドラッグアンドドロップ動作を定義できるため、Windows エクスプローラーのドラッグアンドドロップ動作に基づく特定のガイドラインに従って、予測可能なユーザーエクスペリエンスを確保する必要があります。

- **ソリューションエクスプローラー**の変更されていないドラッグ操作 (Ctrl キーと Shift キーが押されていない場合) は、移動操作になります。

- Shift + ドラッグ操作でも、移動操作が必要になります。

- Ctrl + ドラッグ操作によってコピー操作が実行されます。

- 参照ベースのプロジェクトシステムと混合プロジェクトシステムでは、ソース項目へのリンク (または参照) を追加するという概念がサポートされています。 これらのプロジェクトがドラッグアンドドロップ操作の対象である場合 ( **Ctrl + Shift** キーが押されている場合)、プロジェクトに追加されている項目への参照になります。

  すべてのドラッグアンドドロップ操作は、参照ベース、ディレクトリベース、および混合プロジェクトの組み合わせでは適切ではありません。 特に、ソースディレクトリベースのプロジェクトは移動の完了時にソース項目を削除する必要があるため、ディレクトリベースのソースプロジェクトと参照ベースのターゲットプロジェクトの間で移動操作を許可することは問題になります。 その後、ターゲットの参照ベースのプロジェクトは、削除された項目への参照で終了します。

  また、ターゲットの参照ベースのプロジェクトがソース項目の独立したコピーを作成することはできないため、これらの種類のプロジェクト間でコピー操作を許可することは誤解されます。 同様に、ディレクトリベースのプロジェクトで参照を保持できないため、ディレクトリベースのターゲットプロジェクトに Ctrl + Shift をドラッグすることはできません。 ドラッグアンドドロップ操作がサポートされていない場合、IDE ではドロップが禁止され、ユーザーはドロップ不可カーソルを表示しないようにする必要があります (以下のポインターテーブルを参照してください)。

  ドラッグアンドドロップ動作を適切に実装するには、ドラッグのソースプロジェクトが、ターゲットプロジェクトに対して、その性質 (たとえば、参照またはディレクトリベースかどうか) を伝える必要があります。 この情報は、ソースによって提供されるクリップボード形式によって示されます。 ドラッグ (またはクリップボードのコピー操作) のソースとして、プロジェクトが参照ベースまたはディレクトリベースのどちらであるかに応じて、 **CF_VSREFPROJECTITEM**S または **CF_VSSTGPROJECTITEMS** のいずれかを提供する必要があります。 これらの形式はどちらも、Windows **CF_HDROP**形式に似ていますが、文字列のリストは、ファイル名ではなく、2つの**NULL**で終わる、( **Ivssolution:: getprojrefofitem**または **:: getprojrefofitem**から返される) **projref** strings のリストである点が異なります。

  ドロップ (またはクリップボードの貼り付け操作) の対象として、プロジェクトは **CF_VSREFPROJECTITEMS** と **CF_VSSTGPROJECTITEMS**の両方を受け入れる必要があります。ただし、ドラッグアンドドロップ操作の正確な処理は、ターゲットプロジェクトとソースプロジェクトの性質によって異なります。 ソースプロジェクトは、 **CF_VSREFPROJECTITEMS** または **CF_VSSTGPROJECTITEMS**を提供するかどうかによって、その性質を宣言します。 ドロップのターゲットは独自の性質を理解するため、移動、コピー、またはリンクを実行するかどうかを決定するのに十分な情報が得られます。 また、ctrl キー、Shift キー、または Ctrl キーと Shift キーの両方を押すことによって実行するドラッグアンドドロップ操作を変更することもできます。 ドロップターゲットは、その **DragEnter** メソッドと **system.windows.dragdrop.dragover>** メソッドで事前に実行される操作を正確に示すことが重要です。 **ソリューションエクスプローラー**によって、ソースプロジェクトとターゲットプロジェクトが同じプロジェクトであるかどうかが自動的に認識されます。

  Visual Studio のインスタンス間でのプロジェクトアイテムのドラッグ (たとえば、devenv.exe のインスタンス間) は、特にサポートされていません。 また、 **ソリューションエクスプローラー** はこれを直接無効にします。

  ユーザーは、アイテムを選択して目的の場所にドラッグすることにより、ドラッグアンドドロップ操作の効果を常に判断し、項目がドロップされる前に次のマウスポインターのどれが表示されるかを確認できます。

|マウス ポインター|コマンド|説明|
|-------------------|-------------|-----------------|
|![マウスの [ドロップしない] アイコン](../../extensibility/ux-guidelines/media/0706-01-mousenodrop.png "0706-01_MouseNoDrop")|ドロップなし|指定された場所に項目をドロップできません。|
|![マウスの [コピー] アイコン](../../extensibility/ux-guidelines/media/0706-02-mousecopy.png "0706-02_MouseCopy")|コピー|項目はターゲットの場所にコピーされます。|
|![マウスの [移動] アイコン](../../extensibility/ux-guidelines/media/0706-03-mousemove.png "0706-03_MouseMove")|移動|項目はターゲットの場所に移動されます。|
|![マウスの [参照の追加] アイコン](../../extensibility/ux-guidelines/media/0706-04-mouseaddref.png "0706-04_MouseAddRef")|参照の追加|選択した項目への参照が、ターゲットの場所に追加されます。|

#### <a name="reference-based-projects"></a>参照ベースのプロジェクト
 次の表は、参照ベースのターゲットプロジェクトに対して押されたソース項目と修飾子キーの性質に基づいて実行する必要がある、ドラッグアンドドロップ (および切り取り/コピー/貼り付け) 操作をまとめたものです。

|||ソース項目: 参照/リンク|ソース項目: 物理項目またはファイルシステム (CF_HDROP)|
|-|-|----------------------------------|-------------------------------------------------------------|
|修飾子なし|アクション|移動|リンク|
|修飾子なし|移行先|元の項目への参照を追加します|元の項目への参照を追加します|
|修飾子なし|source|元の項目への参照を削除します|元の項目を保持する|
|修飾子なし|結果|**DROPEFFECT_MOVE**がアクションとして返されるのは、:D の rop と項目がストレージ内の元の場所に残り**ます。**|**DROPEFFECT_LINK**がアクションとして返されるのは、:D の rop と項目がストレージ内の元の場所に残り**ます。**|
|Shift + ドラッグ|アクション|移動|ドロップなし|
|Shift + ドラッグ|移行先|元の項目への参照を追加します|ドロップなし|
|Shift + ドラッグ|source|元の項目への参照を削除します|ドロップなし|
|Shift + ドラッグ|結果|**DROPEFFECT_MOVE**がアクションとして返されるのは、:D の rop と項目がストレージ内の元の場所に残り**ます。**|ドロップなし|
|Ctrl + ドラッグ|アクション|コピー|ドロップなし|
|Ctrl + ドラッグ|移行先|元の項目への参照を追加します|ドロップなし|
|Ctrl + ドラッグ|source|元の項目への参照を保持します|ドロップなし|
|Ctrl + ドラッグ|結果|**DROPEFFECT_COPY**がアクションとして返されるのは、:D の rop と項目がストレージ内の元の場所に残り**ます。**|ドロップなし|
|Ctrl + Shift + ドラッグ|アクション|リンク|リンク|
|Ctrl + Shift + ドラッグ|移行先|元の項目への参照を追加します|元の項目への参照を追加します|
|Ctrl + Shift + ドラッグ|source|元の項目への参照を保持します|元の項目を保持する|
|Ctrl + Shift + ドラッグ|結果|**DROPEFFECT_LINK**がアクションとして返されるのは、:D の rop と項目がストレージ内の元の場所に残り**ます。**|**DROPEFFECT_LINK**がアクションとして返されるのは、:D の rop と項目がストレージ内の元の場所に残り**ます。**|
|Ctrl + Shift + ドラッグ|注意|エクスプローラーでのショートカットのドラッグアンドドロップの動作と同じです。||
|切り取り/貼り付け|アクション|移動|リンク|
|切り取り/貼り付け|移行先|元の項目への参照を追加します|元の項目への参照を追加します|
|切り取り/貼り付け|source|元の項目への参照を保持します|元の項目を保持する|
|切り取り/貼り付け|結果|項目はストレージ内の元の場所に残ります|項目はストレージ内の元の場所に残ります|
|コピー/貼り付け|アクション|コピー|リンク|
|コピー/貼り付け|source|元の項目への参照を追加します|元の項目への参照を追加します|
|コピー/貼り付け|結果|元の項目への参照を保持します|元の項目を保持する|
|コピー/貼り付け|アクション|項目はストレージ内の元の場所に残ります|項目はストレージ内の元の場所に残ります|

#### <a name="directory-based-projects"></a>ディレクトリベースのプロジェクト
 次の表は、ディレクトリベースのターゲットプロジェクトに対して押されたソース項目と修飾子キーの性質に基づいて実行する必要がある、ドラッグアンドドロップ (および切り取り/コピー/貼り付け) 操作をまとめたものです。

|||ソース項目: 参照/リンク|ソース項目: 物理項目またはファイルシステム (CF_HDROP)|
|-|-|----------------------------------|-------------------------------------------------------------|
|修飾子なし|アクション|移動|移動|
|修飾子なし|移行先|項目をターゲットの場所にコピーします|項目をターゲットの場所にコピーします|
|修飾子なし|source|元の項目への参照を削除します|元の項目への参照を削除します|
|修飾子なし|結果|**DROPEFFECT_ の移動** がアクションとして返され **ます。:D の rop** と項目はストレージ内の元の場所に残ります|**DROPEFFECT_ の移動** がアクションとして返され **ます。:D の rop** と項目はストレージ内の元の場所に残ります|
|Shift + ドラッグ|アクション|移動|移動|
|Shift + ドラッグ|移行先|項目をターゲットの場所にコピーします|項目をターゲットの場所にコピーします|
|Shift + ドラッグ|source|元の項目への参照を削除します|元の場所から項目を削除します|
|Shift + ドラッグ|結果|**DROPEFFECT_ の移動** がアクションとして返され **ます。:D の rop** と項目はストレージ内の元の場所に残ります|**DROPEFFECT_ の移動** がアクションとして返され **ます。:D の rop** と項目はストレージ内の元の場所に残ります|
|Ctrl + ドラッグ|アクション|コピー|コピー|
|Ctrl + ドラッグ|移行先|項目をターゲットの場所にコピーします|項目をターゲットの場所にコピーします|
|Ctrl + ドラッグ|source|元の項目への参照を保持します|元の項目への参照を保持します|
|Ctrl + ドラッグ|結果|**DROPEFFECT_ コピー** がアクションとして返され **ます。:D** は、rop と項目はストレージ内の元の場所に残ります|**DROPEFFECT_ コピー** がアクションとして返され **ます。:D** は、rop と項目はストレージ内の元の場所に残ります|
|Ctrl + Shift + ドラッグ||ドロップなし|ドロップなし|
|切り取り/貼り付け|アクション|移動|移動|
|切り取り/貼り付け|移行先|項目をターゲットの場所にコピーします|項目をターゲットの場所にコピーします|
|切り取り/貼り付け|source|元の項目への参照を削除します|元の場所から項目を削除します|
|切り取り/貼り付け|結果|項目はストレージ内の元の場所に残ります|項目はストレージ内の元の場所から削除されます|
|コピー/貼り付け|アクション|コピー|コピー|
|コピー/貼り付け|移行先|元の項目への参照を追加します|項目をターゲットの場所にコピーします|
|コピー/貼り付け|source|元の項目を保持する|元の項目を保持する|
|コピー/貼り付け|結果|項目はストレージ内の元の場所に残ります|項目は元の場所のストレージに残ります|

#### <a name="mixed-target-projects"></a>混合ターゲットプロジェクト
 次の表は、混合ターゲットプロジェクトに対して押されたソース項目と修飾子キーの性質に基づいて実行する必要がある、ドラッグアンドドロップ (および切り取り/コピー/貼り付け) 操作をまとめたものです。

|||ソース項目: 参照/リンク|ソース項目: 物理項目またはファイルシステム (CF_HDROP)|
|-|-|----------------------------------|-------------------------------------------------------------|
|修飾子なし|アクション|移動|移動|
|修飾子なし|移行先|元の項目への参照を追加します|項目をターゲットの場所にコピーします|
|修飾子なし|source|元の項目への参照を削除します|元の項目への参照を削除します|
|修飾子なし|結果|**DROPEFFECT_ の移動** がアクションとして返され **ます。:D の rop** と項目はストレージ内の元の場所に残ります|**DROPEFFECT_ の移動** がアクションとして返されました **::D の rop** と項目はストレージ内の元の場所から削除されています|
|Shift + ドラッグ|アクション|移動|移動|
|Shift + ドラッグ|移行先|元の項目への参照を追加します|項目をターゲットの場所にコピーします|
|Shift + ドラッグ|source|元の項目への参照を削除します|元の場所から項目を削除します|
|Shift + ドラッグ|結果|**DROPEFFECT_ の移動** がアクションとして返され **ます。:D の rop** と項目はストレージ内の元の場所に残ります|**DROPEFFECT_ の移動** がアクションとして返されました **::D の rop** と項目はストレージ内の元の場所から削除されています|
|Ctrl + ドラッグ|アクション|コピー|コピー|
|Ctrl + ドラッグ|移行先|元の項目への参照を追加します|項目をターゲットの場所にコピーします|
|Ctrl + ドラッグ|source|元の項目への参照を保持します|元の項目を保持する|
|Ctrl + ドラッグ|結果|**DROPEFFECT_ コピー** がアクションとして返され **ます。:D** は、rop と項目はストレージ内の元の場所に残ります|**DROPEFFECT_ コピー** がアクションとして返され **ます。:D** は、rop と項目はストレージ内の元の場所に残ります|
|Ctrl + Shift + ドラッグ|アクション|リンク|リンク|
|Ctrl + Shift + ドラッグ|移行先|元の項目への参照を追加します|元のソース項目への参照を追加します|
|Ctrl + Shift + ドラッグ|source|元の項目への参照を保持します|元の項目を保持する|
|Ctrl + Shift + ドラッグ|結果|**DROPEFFECT_ リンク** がアクションとして返され **ます::D の rop** と項目はストレージ内の元の場所に残ります|**DROPEFFECT_ リンク** がアクションとして返され **ます::D の rop** と項目はストレージ内の元の場所に残ります|
|切り取り/貼り付け|アクション|移動|移動|
|切り取り/貼り付け|移行先|項目をターゲットの場所にコピーします|項目をターゲットの場所にコピーします|
|切り取り/貼り付け|source|元の項目への参照を削除します|元の場所から項目を削除します|
|切り取り/貼り付け|結果|項目はストレージ内の元の場所に残ります|項目はストレージ内の元の場所から削除されます|
|コピー/貼り付け|アクション|コピー|コピー|
|コピー/貼り付け|移行先|元の項目への参照を追加します|項目をターゲットの場所にコピーします|
|コピー/貼り付け|source|元の項目を保持する|元の項目を保持する|
|コピー/貼り付け|結果|項目はストレージ内の元の場所に残ります|項目はストレージ内の元の場所に残ります|

 **ソリューションエクスプローラー**でドラッグを実装するときは、次の点について考慮する必要があります。

- 複数の選択シナリオを対象とした設計。

- ファイル名 (完全パス) はターゲットプロジェクト全体で一意である必要があります。または、drop を許可しないでください。

- フォルダー名は、削除されるレベルで一意である必要があります (大文字と小文字は区別されません)。

- ドラッグ時に開いたり閉じたりするファイルには、動作の違いがあります (上記のシナリオでは説明しません)。

- 最上位レベルのファイルの動作は、フォルダー内のファイルと若干異なります。

  他にも注意が必要な問題は、デザイナーまたはエディターを開いているアイテムに対して移動操作を処理する方法です。 想定される動作は次のとおりです (すべてのプロジェクトの種類に適用されます)。

1. 開いているエディターまたはデザイナーに未保存の変更がない場合は、エディター/デザイナーウィンドウが自動的に閉じられます。

2. 開いているエディター/デザイナーの変更が保存されていない場合、ドラッグのソースはドロップが発生するまで待機し、次のようなプロンプトでウィンドウを閉じる前に、開いているドキュメントにコミットされていない変更を保存するようにユーザーに依頼します。

   ```
   ==========================================================
        One or more open documents have unsaved changes.
   Do you want to save uncommitted changes before proceeding?
                     [Yes]  [No]  [Cancel]
   ==========================================================
   ```

   これにより、ターゲットがコピーを作成する前に、進行中の作業を保存できるようになります。 この処理を可能にする新しいメソッド **IVsHierarchyDropDataSource2:: OnBeforeDropNotify** が追加されました。

   その後、ターゲットは、ストレージ内の項目の状態をコピーします (ユーザーが [ **いいえ**] を選択した場合、エディターに保存されていない変更は含まれません)。 ターゲットのコピーが完了した後 ( **IVsHierarchyDropDataSource::D の rop**)、移動操作の削除部分 ( **IVsHierarchyDropDataSource:: OnDropNotify**) を完了する機会がソースに与えられます。

   変更が保存されていないエディターは、開いたままにしておく必要があります。 変更が保存されていないドキュメントについては、移動操作のコピー部分は実行されますが、削除部分は中止されます。 ユーザーが [ **いいえ**] を選択した場合の複数選択のシナリオでは、未保存の変更のあるドキュメントを閉じたり削除したりする必要はありませんが、未保存の変更のないドキュメントは閉じて削除する必要があります。
