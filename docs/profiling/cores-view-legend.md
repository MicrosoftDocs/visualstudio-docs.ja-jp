---
title: コア ビューの凡例 | Microsoft Docs
ms.custom: ''
ms.date: 11/04/2016
ms.technology: vs-ide-debug
ms.topic: conceptual
f1_keywords:
- vs.cv.cores.legend
helpviewer_keywords:
- Concurrency Visualizer, Cores View Legend
ms.assetid: e160384c-fcfe-49b3-86b7-229adb736c51
author: mikejo5000
ms.author: mikejo
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: ee31b1547f9607f54cc5db9d056b997f071633ff
ms.sourcegitcommit: 0aafcfa08ef74f162af2e5079be77061d7885cac
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 06/04/2018
ms.locfileid: "34691588"
---
# <a name="cores-view-legend"></a>コア ビューの凡例
コア ビューの凡例では、各スレッドが色と名前で示されます。 クロスコアのコンテキスト スイッチの回数、コンテキスト スイッチの合計回数、クロスコアのコンテキスト スイッチの割合を示す列が含まれます。 凡例の行は、クロスコアのコンテキスト スイッチの回数が多い順に並べられています。  
  
 凡例で行を選んで、タイムラインに表示されるスレッドをフィルター処理できます。 選んだスレッドのみがタイムラインに表示されます。 行を選ばないと、すべての行がタイムラインに表示されます。  
  
 同じ論理コア内でのコンテキスト スイッチより、クロスコアのコンテキスト スイッチの方が、オーバーヘッドとパフォーマンスのコストが大きくなります。 コンテキスト スイッチでは、プロセッサのレジスタが保存されて復元され、オペレーティング システムのカーネル コードが実行され、変換ルックアサイド バッファーのエントリが再度読み込まれて、プロセッサのパイプラインがフラッシュされます。 クロスコアのコンテキスト スイッチでは、キャッシュ データが別のコア上のこのスレッドに対して無効なため、他のコンテキスト スイッチよりさらに負荷が大きくなります。 これに対し、同じコア上でのコンテキスト スイッチの場合は、有効なデータがまだキャッシュに存在する可能性があります。 スレッド アフィニティを管理しようとしてクロスコアのコンテキスト スイッチが増加し、パフォーマンスが低下する場合は、この問題に対処するかどうかを検討してください。 最初にスレッド アフィニティを除去して、クロスコアの動作を確認します。  
  
 次の表では凡例の要素について説明します。  
  
|要素|定義|  
|-------------|----------------|  
|スレッド名|前のコア タイムラインでのスレッドの色と、そのスレッドの名前が示されます。|  
|クロス コアのコンテキスト スイッチ|異なる論理コア間で行われた、スレッドのコンテキスト スイッチの回数。 異なるプロセッサ ダイ間のクロスコア コンテキスト スイッチと、同じダイ上でのスイッチは、区別されません。|  
|合計コンテキスト スイッチ数|サンプリング期間中に特定のスレッドでのコンテキスト スイッチの合計回数。 スレッドのコンテキストが変わるたびに (たとえば、実行から同期に)、コンテキスト スイッチが 1 回カウントされます。|  
|クロス コアのコンテキスト スイッチの割合|クロスコア コンテキスト スイッチの回数をコンテキスト スイッチの合計回数で割った割合として計算されます。 この割合が高いほど、この特定のスレッドのパフォーマンスに対するクロスコア コンテキスト スイッチのオーバーヘッドの全体的な影響が大きくなります。|  
  
## <a name="see-also"></a>関連項目  
 [コア ビュー](../profiling/cores-view.md)