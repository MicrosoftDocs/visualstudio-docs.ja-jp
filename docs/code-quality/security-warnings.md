---
title: セキュリティの警告
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security warnings
- managed code analysis warnings, security warnings
- warnings, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 9b5a03c9cb7ae7c5a5c81bd452dbb04d8db4c09d
ms.sourcegitcommit: ed17ca9ae5f92c229c4e46233bcfe0a49d29ec43
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/10/2020
ms.locfileid: "88052623"
---
# <a name="security-warnings"></a>セキュリティの警告

セキュリティ警告は、より安全なライブラリとアプリケーションをサポートします。 この警告によって、プログラムにセキュリティ上の欠陥が含まれるのを防ぐことができます。 この警告のいずれかを無効にする場合、明確にコードに理由を記載し、開発プロジェクトの指定されたセキュリティ管理者にも報告します。

## <a name="in-this-section"></a>このセクションの内容

|ルール|説明|
|----------|-----------------|
|[CA2100:SQL クエリのセキュリティ脆弱性を確認](../code-quality/ca2100.md)|メソッドに渡された文字列引数から構築された文字列を使用して System.Data.IDbCommand.CommandText プロパティが設定されています。 この規則では、文字列引数にユーザー入力が含まれていることが想定されています。 ユーザー入力から構築された SQL コマンド文字列には、SQL 注入攻撃に対する脆弱性があります。|
|[CA2102:汎用ハンドラーの CLSCompliant でない例外をキャッチします](../code-quality/ca2102.md)|アセンブリ内の RuntimeCompatibilityAttribute でマークされていないメンバーまたは RuntimeCompatibility(WrapNonExceptionThrows = false) でマークされているメンバーには、System.Exception を処理する catch ブロックがあり、その直後に汎用 catch ブロックはありません。|
|[CA2103:命令型のセキュリティを確認します](../code-quality/ca2103.md)|メソッドが強制セキュリティを使用しています。また、そのメソッドで、確認要求がアクティブな場合でも変更できるステータス情報または戻り値を使用して、アクセス許可を構築している可能性があります。 できる限り、宣言セキュリティを使用します。|
|[CA2104:読み取り専用の変更可能な参照型を宣言しません](../code-quality/ca2104.md)|外部から参照できる型に、変更可能な参照型である、外部から参照可能な読み取り専用のフィールドがあります。 変更可能な型とは、インスタンス データを変更できる型です。|
|[CA2105:配列フィールドを読み取り専用にすることはできません](../code-quality/ca2105.md)|配列を含むフィールドに読み取り専用 (Visual Basic では ReadOnly) 修飾子を適用すると、そのフィールドで参照先の配列を変更できません。 ただし、読み取り専用フィールドに格納された配列の要素は変更できます。|
|[CA2106:アサートをセキュリティで保護します](../code-quality/ca2106.md)|メソッドによってアクセス許可がアサートされますが、呼び出し元に対してセキュリティ チェックが実行されていません。 セキュリティ チェックを実行せずにセキュリティ アクセス許可をアサートすると、悪用される可能性があるセキュリティの弱点がコード内に残る場合があります。|
|[CA2107:拒否および許可のみの使用を確認します](../code-quality/ca2107.md)|PermitOnly メソッドと CodeAccessPermission を使用します。 Deny セキュリティアクションは、.NET セキュリティに関する高度な知識を持つユーザーのみが使用する必要があります。 コードにこのセキュリティ アクションを使用する場合、セキュリティを再確認する必要があります。|
|[CA2108:値型での宣言セキュリティを確認します](../code-quality/ca2108.md)|パブリックまたはプロテクトの値型が、データ アクセスまたはリンク確認要求で保護されています。|
|[CA2109:表示するイベント ハンドラーを確認します](../code-quality/ca2109.md)|パブリックまたはプロテクトのイベント ハンドラー メソッドが検出されました。 イベント ハンドラー メソッドは、絶対に必要な場合を除き公開しないでください。|
|[CA2111:ポインターは参照可能にすることはできません](../code-quality/ca2111.md)|ポインターがプライベート、内部、読み取り専用のいずれでもありません。 悪意のあるコードで、ポインターの値が変更される可能性があります。結果的に、メモリの任意の位置にアクセスされたり、アプリケーション エラーやシステム障害の原因になります。|
|[CA2112:セキュリティで保護された型はフィールドを公開してはなりません](../code-quality/ca2112.md)|パブリック型またはプロテクト型に、パブリック フィールドが含まれ、リンク確認要求で保護されています。 リンク確認要求で保護されている型のインスタンスに対するアクセス権がコードにある場合、その型のフィールドにアクセスするためにリンク確認要求に適合する必要はありません。|
|[CA2114:メソッド セキュリティは型のスーパーセットでなければなりません](../code-quality/ca2114.md)|メソッドでは、同じアクションについて、メソッド レベルと型レベルの宣言セキュリティの両方を指定することはできません。|
|[CA2115:ネイティブ リソースを使用しているときには GC.KeepAlive を呼び出します](../code-quality/ca2115.md)|この規則では、アンマネージ コードでまだ使用されているのに、アンマネージ リソースが終了されたときに発生する可能性のあるエラーを検出します。|
|[CA2116:APTCA メソッドは APTCA メソッドのみを呼び出すことができます](../code-quality/ca2116.md)|APTCA (AllowPartiallyTrustedCallers) 属性が完全に信頼されたアセンブリにあり、部分的に信頼された呼び出し元を許可しない別のアセンブリのコードをアセンブリが実行する場合、セキュリティ上の弱点になります。|
|[CA2117:APTCA 型は APTCA 基本型のみを拡張することができます](../code-quality/ca2117.md)|APTCA (AllowPartiallyTrustedCallers) 属性が完全に信頼されたアセンブリにあり、アセンブリの型が部分的に信頼された呼び出し元を許可しない型から継承する場合、セキュリティ上の弱点になります。|
|[CA2118:SuppressUnmanagedCodeSecurityAttribute の使用法を確認してください](../code-quality/ca2118.md)|COM 相互運用機能またはプラットフォーム呼び出し機能を使用するアンマネージ コードを実行するメンバーの場合、SuppressUnmanagedCodeSecurityAttribute によって、既定のセキュリティ システムの動作が変わります。 この属性は、主にパフォーマンスを向上するために使用されますが、パフォーマンスが向上するとセキュリティ上のリスクも高くなります。|
|[CA2119:プライベート インターフェイスを満たすメソッドをシールします](../code-quality/ca2119.md)|継承可能なパブリック型により、internal (Visual Basic では Friend) インターフェイスのオーバーライド可能なメソッド実装が提供されます。 この規則違反を修正するには、アセンブリの外側でメソッドがオーバーライドされないようにします。|
|[CA2120:シリアル化コンストラクターをセキュリティで保護します](../code-quality/ca2120.md)|この型には、System.Runtime.Serialization.SerializationInfo オブジェクトおよび System.Runtime.Serialization.StreamingContext オブジェクトを使用するコンストラクター (シリアル化コンストラクターのシグネチャ) があります。 このコンストラクターはセキュリティ チェックで保護されていませんが、型に含まれる標準コンストラクターの 1 つ以上は保護されています。|
|[CA2121:静的コンストラクターはプライベートでなければなりません](../code-quality/ca2121.md)|システムで静的コンストラクターが呼び出されてから、型の最初のインスタンスが作成されるか、静的メンバーが参照されます。 静的コンストラクターがプライベートである場合、システム以外のコードから呼び出すことができます。 コンストラクターで実行される操作によっては、これによって予期しない動作が発生することがあります。|
|[CA2122:リンク要求を含むメソッドを間接的に公開しません](../code-quality/ca2122.md)|パブリック メンバーまたはプロテクト メンバーはリンク確認要求を含み、セキュリティ チェックを実行しないメンバーから呼び出されています。 リンク確認要求では、直接の呼び出し元のアクセス許可しかチェックされません。|
|[CA2123:オーバーライドのリンク要求はベースと同一でなければなりません](../code-quality/ca2123.md)|この規則は、メソッドをその基本メソッド (別の型のインターフェイスまたは仮想メソッド) とマッチングし、それぞれについてリンク確認要求を比較します。 この規則に違反すると、悪意のある呼び出し元が、保護されていないメソッドを呼び出すだけで、リンク確認要求を省略できます。|
|[CA2124:脆弱性のある finally 句を外側の try でラップします](../code-quality/ca2124.md)|パブリック メソッドまたはプロテクト メソッドに try/finally ブロックが含まれています。 この finally ブロックはセキュリティの状態をリセットすると思われますが、それ自体が finally ブロックで囲まれていません。|
|[CA2126:型のリンク要求には継承要求が必要です](../code-quality/ca2126.md)|シールされていないパブリックな型がリンク確認要求によって保護され、オーバーライド可能なメソッドを持っています。 その型またはメソッドが継承確認要求によって保護されていません。|
|[CA2130:セキュリティ上重要な定数は透過的である必要がある](../code-quality/ca2130.md)|実行時に検索の必要がない値がコンパイラのインライン定数に設定されているため、定数値に対して透過性は適用されません。 透過的なコードからは定数にアクセスできないとコード レビューアーが考えることがないよう、定数フィールドは透過的セキュリティなフィールドとして定義する必要があります。|
|[CA2131:セキュリティ上重要な型は型等価性に参加してはならない](../code-quality/ca2131.md)|型は型の等価性に関与し、型自体、または型のメンバーまたはフィールドのいずれかが SecurityCriticalAttribute 属性でマークされています。 この規則は、すべての重要な型、または型の等価性に関与する重要なメソッドあるいはフィールドが定義されたすべての型に対して適用されます。 こうした型が CLR によって検出されると、CLR による型の読み込みが失敗し、実行時に TypeLoadException が発生します。 通常は、tlbimp やコンパイラによって型の等価性を実装するのではなく、ユーザーが手動で実装した場合に、この規則が適用されます。|
|[CA2132:既定のコンストラクターは、基本型の既定コンストラクターと同程度以上、重要であることが必要](../code-quality/ca2132.md)|SecurityCriticalAttribute でマークされている型およびメンバーを Silverlight アプリケーション コードで使用することはできません。 セキュリティが重要な型やメンバーは、.NET Framework for Silverlight クラス ライブラリの信頼されているコードからのみ使用できます。 派生クラスにおけるパブリックな構築または保護された構築の透過性は、基底クラスと同程度以上である必要があるため、アプリケーション内のクラスを、SecurityCritical としてマークされたクラスから派生させることはできません。|
|[CA2133:デリゲートは透過性の整合がとれたメソッドにバインドする必要がある](../code-quality/ca2133.md)|この警告は、SecurityCriticalAttribute でマークされているデリゲートを、透過的メソッドまたは SecuritySafeCriticalAttribute でマークされているメソッドにバインドするメソッドに対して適用されます。 この警告は、透過的なデリゲートまたはセーフ クリティカルなデリゲートを、クリティカル メソッドにバインドするメソッドに対しても適用されます。|
|[CA2134:メソッドは、基本メソッドをオーバーライドしている場合、透過性の整合性を保つ必要がある](../code-quality/ca2134.md)|この規則は、SecurityCriticalAttribute でマークされているメソッドが、透過的メソッドまたは SecuritySafeCriticalAttribute でマークされているメソッドをオーバーライドするときに適用されます。 また、透過的メソッドまたは SecuritySafeCriticalAttribute が適用されたメソッドが、SecurityCriticalAttribute が適用されたメソッドをオーバーライドした場合も、この規則が適用されます。 この規則は、仮想メソッドをオーバーライドする場合やインターフェイスを実装する場合に適用されます。|
|[CA2135:レベル 2 のアセンブリは LinkDemand を含んではならない](../code-quality/ca2135.md)|LinkDemands は、レベル 2 のセキュリティ規則セットでは使用が非推奨とされます。 LinkDemands を使用して Just-In-Time (JIT) コンパイル時にセキュリティを適用するのではなく、メソッド、型、およびフィールドに SecurityCriticalAttribute 属性を設定します。|
|[CA2136:メンバーには、透過性注釈の競合があってはならない](../code-quality/ca2136.md)|透過性属性は、大きいスコープのコード要素から小さいスコープの要素に適用されます。 大きいスコープのコード要素の透過性属性は、最初の要素に含まれているコード要素の透過性属性よりも優先されます。 たとえば、SecurityCriticalAttribute 属性でマークされたクラスに SecuritySafeCriticalAttribute 属性でマークされたメソッドを含めることはできません。|
|[CA2137:透過的メソッドは、検証可能な IL のみを含まなければならない](../code-quality/ca2137.md)|メソッドに検証できないコードが含まれているか、メソッドから参照渡しで型が返されます。 この規則は、透過的セキュリティ コードが、検証できない MSIL (Microsoft Intermediate Language) を実行しようとすると適用されます。 ただし、規則には完全な IL 検証ツールは含まれていないため、代わりにヒューリスティックを使用して、ほとんどの MSIL 検証違反が検出されます。|
|[CA2138:透過的メソッドは、SuppressUnmanagedCodeSecurity 属性を持つメソッドを呼び出してはならない](../code-quality/ca2138.md)|SuppressUnmanagedCodeSecurityAttribute 属性が適用されたメソッドを、透過的セキュリティ メソッドが呼び出します。|
|[CA2139:透過的メソッドは、HandleProcessCorruptingExceptions 属性を使用してはならない](../code-quality/ca2139.md)|この規則は、透過的な任意のメソッドに対して適用され、HandleProcessCorruptedStateExceptionsAttribute 属性を使用して例外の処理を処理しようとします。 例外の処理は、などの例外の CLR バージョン4.0 例外の分類です <xref:System.AccessViolationException> 。 HandleProcessCorruptedStateExceptionsAttribute 属性はセキュリティ クリティカルなメソッドでのみ使用できる属性で、透過的メソッドに適用された場合は無視されます。|
|[CA2140:透過的コードは、セキュリティ上重要な項目を参照してはならない](../code-quality/ca2140.md)|SecurityTransparentAttribute でマークされたメソッドが、SecurityCritical とマークされたパブリックでないメンバーを呼び出しています。 このルールは、transparent と critical が混在しているアセンブリ内のすべてのメソッドと型を分析し、transparent code から SecurityTreatAsSafe とマークされていない非パブリックの重要なコードへの呼び出しにフラグを設定します。|
|[CA2141: 透過的メソッドは、LinkDemand を満たしてはならない](../code-quality/ca2141.md)|透過的メソッドは、AllowPartiallyTrustedCallersAttribute (APTCA) 属性が適用されていないアセンブリ内のメソッドを呼び出します。また、透過的セキュリティ メソッドは、データ型またはメソッドに対する LinkDemand の要件を満たします。|
|[CA2142:透過的コードは、LinkDemand を使用して保護されてはならない](../code-quality/ca2142.md)|この規則は、アクセスするために LinkDemands を要求する透過的メソッドに対して適用されます。 透過的セキュリティ コードでは、操作のセキュリティ検証を行うことができないため、アクセス許可を要求できません。|
|[CA2143:透過的メソッドは、セキュリティ確認要求を使用してはならない](../code-quality/ca2143.md)|透過的セキュリティ コードでは、操作のセキュリティ検証を行うことができないため、アクセス許可を要求できません。 透過的セキュリティ コードは、フル アクセス要求を使用して、セキュリティ上の決定を行う必要があります。セーフ クリティカルなコードでは、透過的なコードを使用してフル アクセス要求を行うことはできません。|
|[CA2144:透過的コードは、バイト配列からアセンブリを読み込んではならない](../code-quality/ca2144.md)|透過的なコードはセキュリティ上重要な操作を実行できないため、透過的なコードのセキュリティ レビューは、クリティカル コードのセキュリティ レビューほど完全ではありません。 バイト配列から読み込まれるアセンブリは透過的なコード内で認識されない場合がありますが、監査を必要とする、クリティカルなコード、またはさらに重要であるセーフ クリティカルなコードがそのバイト配列に含まれる可能性があります。|
|[CA2145:透過的メソッドを SuppressUnmanagedCodeSecurityAttribute で修飾してはならない](../code-quality/ca2145.md)|SuppressUnmanagedCodeSecurityAttribute 属性で修飾されたメソッドには、それを呼び出すメソッドに対して適用される暗黙的な LinkDemand があります。 この LinkDemand では、呼び出し元のコードがセキュリティ クリティカルなコードである必要があります。 SuppressUnmanagedCodeSecurity を使用するメソッドに SecurityCriticalAttribute 属性を設定すると、メソッドの呼び出し元に対してこの要件がより明確になります。|
|[CA2146:型は、基本型およびインターフェイスと同程度以上、重要でなければならない](../code-quality/ca2146.md)|派生型に透過的セキュリティ属性が設定されていて、この属性が基本型または実装されたインターフェイスほど重要ではない場合に、この規則が適用されます。 クリティカルな基本型から派生したり、クリティカルなインターフェイスを実装したりできるのは、クリティカルなデータ型だけです。また、セーフ クリティカルな基本型から派生したり、セーフ クリティカルなインターフェイスを実装したりできるのは、クリティカルまたはセーフ クリティカルなデータ型だけです。|
|[CA2147:透過コードは、セキュリティ アサートを使用してはならない](../code-quality/ca2147.md)|この規則では、完全に透過的なアセンブリまたは透過的/クリティカル混在のアセンブリ内のすべてのメソッドと型を分析し、宣言的または強制的に使用されている Assert にフラグを設定します。|
|[CA2149:透過的メソッドは、ネイティブ コード内に呼び出しを行ってはならない](../code-quality/ca2149.md)|この規則は、P/Invoke などを使用してネイティブコードを直接呼び出す透過的メソッドに対して適用されます。 この規則に違反すると、レベル 2 の透過性モデルで MethodAccessException が発生し、レベル 1 の透過性モデルで UnmanagedCode に対するフル アクセス要求が発生します。|
|[CA2151:クリティカル型のフィールドはセキュリティ クリティカルである必要があります](../code-quality/ca2151.md)|セキュリティ クリティカルな型を使用するには、型を参照するコードがセキュリティ クリティカルであるか、セキュリティ セーフ クリティカルである必要があります。 これは、参照が間接的である場合にも当てはまります。 そのため、透過的セキュリティまたはセキュリティ セーフ クリティカルなフィールドが存在すると、透過的なコードはこのフィールドにアクセスできないので、紛らわしくなります。|
|[CA2153:破損状態例外の処理を回避する](../code-quality/ca2153.md)|[破損状態例外 (CSE)](https://msdn.microsoft.com/magazine/dd419661.aspx) は、メモリの破損がプロセス内に存在していることを示します。 プロセスをクラッシュさせるのではなくこれらの例外をキャッチすることは、攻撃者が破損したメモリ領域にセキュリティ上の弱点を見出すことができた場合に、セキュリティ上の脆弱性となる可能性があります。|
|[CA2300:安全ではないデシリアライザー BinaryFormatter を使用しないでください](../code-quality/ca2300.md)|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2301:最初に BinaryFormatter.Binder を設定しないで BinaryFormatter.Deserialize を呼び出さないでください](../code-quality/ca2301.md)|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2302:BinaryFormatter.Deserialize を呼び出す前に BinaryFormatter.Binder が設定されていることを確認します](../code-quality/ca2302.md)|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2305:安全ではないデシリアライザー LosFormatter を使用しないでください](../code-quality/ca2305.md)|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2310:安全ではないデシリアライザー NetDataContractSerializer を使用しないでください](../code-quality/ca2310.md)|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2311:最初に NetDataContractSerializer.Binder を設定しないで逆シリアル化しないでください](../code-quality/ca2311.md)|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2312:NetDataContractSerializer.Binder を設定してから逆シリアル化してください](../code-quality/ca2312.md)|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2315:安全ではないデシリアライザー ObjectStateFormatter を使用しないでください](../code-quality/ca2315.md)|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2321:SimpleTypeResolver を使って JavaScriptSerializer で逆シリアル化しないでください](../code-quality/ca2321.md)|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2322:逆シリアル化する前に JavaScriptSerializer が SimpleTypeResolver によって初期化されていないことを確認してください](../code-quality/ca2322.md)|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2326: None 以外の TypeNameHandling 値は使用しないでください](../code-quality/ca2326.md)|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2327: 安全でない JsonSerializerSettings を使用しないでください](../code-quality/ca2327.md)|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2328: JsonSerializerSettings が安全であることを確認してください](../code-quality/ca2328.md)|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2329: セキュリティで保護されていない構成が JsonSerializer で使用されている場合は、逆シリアル化を行わないでください](../code-quality/ca2329.md)|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2330: 逆シリアル化の際に、JsonSerializer の構成は確実にセキュリティで保護してください](../code-quality/ca2330.md)|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2350:DataTable.ReadXml() の入力が信頼されていることを確認してください](ca2350.md)|信頼されていない入力を使用してを逆シリアル化すると <xref:System.Data.DataTable> 、攻撃者は悪意のある入力を行ってサービス拒否攻撃を仕掛けることができます。 不明なリモートコード実行の脆弱性がある可能性があります。|
|[CA2351:DataSet.ReadXml() の入力が信頼されていることを確認してください](ca2351.md)|信頼されていない入力を使用してを逆シリアル化すると <xref:System.Data.DataSet> 、攻撃者は悪意のある入力を行ってサービス拒否攻撃を仕掛けることができます。 不明なリモートコード実行の脆弱性がある可能性があります。|
|[CA2352:シリアル化可能な型の安全でない DataSet または DataTable は、リモート コード実行攻撃に対して脆弱になる可能性があります](ca2352.md)|でマークされたクラスまたは構造体に、 <xref:System.SerializableAttribute> フィールドまたはプロパティが含まれてい <xref:System.Data.DataSet> ますが、が <xref:System.Data.DataTable> ありません <xref:System.CodeDom.Compiler.GeneratedCodeAttribute> 。|
|[CA2353:シリアル化可能な型の安全でない DataSet または DataTable](ca2353.md)|XML シリアル化属性またはデータコントラクト属性でマークされたクラスまたは構造体に、フィールドまたはプロパティが含まれてい <xref:System.Data.DataSet> <xref:System.Data.DataTable> ます。|
|[CA2354:逆シリアル化されたオブジェクト グラフの安全でない DataSet または DataTable は、リモート コード実行攻撃に対して脆弱になる可能性があります](ca2354.md)|シリアル化されたを使用して逆シリアル <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> 化すると、キャストされた型のオブジェクトグラフにまたはを含めることができ <xref:System.Data.DataSet> <xref:System.Data.DataTable> ます。|
|[CA2355:逆シリアル化されたオブジェクト グラフの安全でない DataSet または DataTable](ca2355.md)|キャストまたは指定された型のオブジェクトグラフがまたはを含むことができる場合、逆シリアル化し <xref:System.Data.DataSet> <xref:System.Data.DataTable> ます。|
|[CA2356: web 逆シリアル化されたオブジェクトグラフ内の安全でないデータセットまたは DataTable](ca2356.md)|またはを持つメソッドには、 <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> またはを参照できるパラメーターがあり <xref:System.Data.DataSet> <xref:System.Data.DataTable> ます。|
|[CA2361: データセットを含む自動生成されたクラスを確認します。 ReadXml () は信頼されていないデータでは使用されません](ca2361.md)|信頼されていない入力を使用してを逆シリアル化すると <xref:System.Data.DataSet> 、攻撃者は悪意のある入力を行ってサービス拒否攻撃を仕掛けることができます。 不明なリモートコード実行の脆弱性がある可能性があります。|
|[CA2362: 自動生成されたシリアル化可能な型の Unsafe データセットまたは DataTable は、リモートのコード実行攻撃に対して脆弱になる可能性があります](ca2362.md)|で信頼できない入力を逆シリアル <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 化し、逆シリアル化されたオブジェクトグラフにまたはが含まれている場合 <xref:System.Data.DataSet> <xref:System.Data.DataTable> 、攻撃者は悪意のあるペイロードを使用してリモートのコード実行攻撃を行うことができます。|
|[CA3001:SQL インジェクションの脆弱性のコード レビュー](../code-quality/ca3001.md)|信頼されていない入力と SQL コマンドを使用する場合は、SQL インジェクション攻撃に注意してください。 SQL インジェクション攻撃によって、悪意のある SQL コマンドを実行し、アプリケーションのセキュリティと整合性を損なう可能性があります。|
|[CA3002:XSS の脆弱性のコード レビュー](../code-quality/ca3002.md)|Web 要求から信頼されていない入力を処理する場合は、クロスサイトスクリプティング (XSS) 攻撃に注意する必要があります。 XSS 攻撃によって、信頼できない入力が未加工の HTML 出力に挿入され、攻撃者が悪意のあるスクリプトを実行したり、web ページのコンテンツを改ざんしたりする可能性があります。|
|[CA3003:ファイル パス インジェクションの脆弱性のコード レビュー](../code-quality/ca3003.md)|Web 要求から信頼されていない入力を使用する場合は、ファイルへのパスを指定するときにユーザーが制御する入力を使用することに注意してください。|
|[CA3004:情報漏えいの脆弱性のコード レビュー](../code-quality/ca3004.md)|例外情報を公開すると、攻撃者がアプリケーションの内部を調べて、攻撃者が他の脆弱性を悪用するのを支援することができます。|
|[CA3006:プロセス コマンド インジェクションの脆弱性のコード レビュー](../code-quality/ca3006.md)|信頼されていない入力を使用する場合は、コマンドインジェクション攻撃に注意してください。 コマンドインジェクション攻撃は、基になるオペレーティングシステムで悪意のあるコマンドを実行し、サーバーのセキュリティと整合性を損なう可能性があります。|
|[CA3007:オープン リダイレクトの脆弱性のコード レビュー](../code-quality/ca3007.md)|信頼されていない入力を使用する場合は、開いているリダイレクトの脆弱性に注意してください。 攻撃者は、開いているリダイレクトの脆弱性を悪用して、web サイトを使用して正当な URL を表示することができますが、悪意のあるユーザーをフィッシングやその他の悪意のある web ページにリダイレクトする可能性があります。|
|[CA3008:XPath インジェクションの脆弱性のコード レビュー](../code-quality/ca3008.md)|信頼されていない入力を使用する場合は、XPath インジェクション攻撃に注意してください。 信頼されていない入力を使用して XPath クエリを作成すると、攻撃者がクエリを故意に操作して意図しない結果を返すことがあり、場合によってはクエリ対象の XML の内容を開示できます。|
|[CA3009:XML インジェクションの脆弱性のコード レビュー](../code-quality/ca3009.md)|信頼されていない入力を使用する場合は、XML インジェクション攻撃に注意してください。|
|[CA3010:XAML インジェクションの脆弱性のコード レビュー](../code-quality/ca3010.md)|信頼されていない入力を扱う場合は、XAML インジェクション攻撃に注意してください。 XAML は、オブジェクトのインスタンス化と実行を直接表すマークアップ言語です。 つまり、XAML で作成された要素は、システムリソース (ネットワークアクセスやファイルシステム IO など) とやり取りできます。|
|[CA3011:DLL インジェクションの脆弱性のコード レビュー](../code-quality/ca3011.md)|信頼できない入力を使用する場合は、信頼されていないコードを読み込むことに注意してください。 Web アプリケーションが信頼されていないコードを読み込む場合、攻撃者は悪意のある Dll をプロセスに挿入して、悪意のあるコードを実行できる可能性があります。|
|[CA3012:RegEx インジェクションの脆弱性のコード レビュー](../code-quality/ca3012.md)|信頼できない入力を使用する場合は、regex インジェクション攻撃に注意してください。 攻撃者は、regex インジェクションを使用して正規表現を故意に変更したり、regex が意図しない結果に一致するようにしたり、regex が過剰な CPU を消費してサービス拒否攻撃を受ける可能性があります。|
|[CA3061:URL でスキーマを追加しません](../code-quality/ca3061.md)|危険な外部参照が発生する可能性があるため、Add メソッドの unsafe オーバーロードは使用しないでください。|
|[CA3075:安全ではない DTD の処理](../code-quality/ca3075.md)|安全ではない DTDProcessing インスタンスを使用する場合、または外部エンティティ ソースを参照する場合、パーサーは信頼されていない入力を受け入れ、攻撃者に機密情報を漏えいしてしまう可能性があります。|
|[CA3076:安全ではない XSLT スクリプトの実行](../code-quality/ca3076.md)|.NET アプリケーションで XSLT (拡張可能なスタイルシート言語変換) を実行する場合、プロセッサは、攻撃者に機密情報を開示する可能性がある信頼できない URI 参照を解決し、サービス拒否攻撃やクロスサイト攻撃を安全で可能性があります。|
|[CA3077:API のデザイン、XML ドキュメント、および XML テキスト リーダーでの安全ではない処理](../code-quality/ca3077.md)|XMLDocument と XMLTextReader から派生する API をデザインする場合、DtdProcessing にご注意ください。 外部エンティティ ソースを参照または解決したり、XML に安全ではない値を設定したりする場合に、安全ではない DTDProcessing インスタンスを使用すると、情報漏えいにつながる可能性があります。|
|[CA3147:ValidateAntiForgeryToken で動詞ハンドラーをマークします](../code-quality/ca3147.md)|ASP.NET MVC コントローラーを設計するときは、クロスサイトリクエストの偽造攻撃に注意してください。 クロスサイト要求偽造攻撃は、認証されたユーザーから ASP.NET MVC コントローラーに悪意のある要求を送信できます。|
|[CA5122 P/Invoke 宣言を安全にクリティカルにすることはできません](../code-quality/ca5122.md)|メソッドは、セキュリティに対する配慮が必要な操作を行うときは SecuritySafeCritical としてマークされますが、透過的なコードによって使用される場合も安全です。 透過的なコードは、P/Invoke を通じてネイティブ コードを直接呼び出すことはありません。 そのため、P/Invoke をセキュリティ セーフ クリティカルとしてマークしても、透過的なコードはそれを呼び出すことができず、セキュリティ分析の際に紛らわしくなります。|
|[CA5359: 証明書の検証を無効にしません](../code-quality/ca5359.md)|証明書は、サーバーの id を認証するのに役立ちます。 クライアントはサーバー証明書を検証して、要求が目的のサーバーに送信されるようにする必要があります。 ServerCertificateValidationCallback が常にを返す場合 `true` 、すべての証明書が検証に合格します。|
|[CA5360: 逆シリアル化で危険なメソッドを呼び出さないでください](../code-quality/ca5360.md)|安全でない逆シリアル化は、信頼されていないデータを使用してアプリケーションのロジックを不適切に悪用したり、サービス拒否 (DoS) 攻撃を受けたり、逆シリアル化の際に任意のコードを実行したりする場合に発生する脆弱性です。 悪意のあるユーザーが、制御下にある信頼されていないデータを逆シリアル化するときに、これらの逆シリアル化機能を不正使用する可能性があります。 具体的には、逆シリアル化のプロセスで危険なメソッドを呼び出します。 安全に安全でない逆シリアル化攻撃によって、攻撃者は DoS 攻撃、認証バイパス、リモートコード実行などの攻撃を仕掛けることができます。|
|[CA5361: 強力な暗号の SChannel の使用を無効にしません](../code-quality/ca5361.md)|`Switch.System.Net.DontEnableSchUseStrongCrypto`をに設定すると `true` 、発信トランスポート層セキュリティ (TLS) 接続で使用される暗号化が弱くなります。 弱い暗号化を使用すると、アプリケーションとサーバーの間の通信の機密性が低下する可能性があるため、攻撃者が機微なデータを簡単に盗聴ことができます。|
|[CA5362: 逆シリアル化されたオブジェクト グラフで可能性のある参照サイクル](../code-quality/ca5362.md)|信頼されていないデータを逆シリアル化する場合、逆シリアル化されたオブジェクトグラフを処理するコードは、無限ループに入ることなく参照サイクルを処理する必要があります。 これには、逆シリアル化のコールバックの一部であるコードと、逆シリアル化の完了後にオブジェクトグラフを処理するコードの両方が含まれます。 そうしないと、攻撃者は参照サイクルを含む悪意のあるデータを使用してサービス拒否攻撃を実行する可能性があります。|
|[CA5363:要求の検証を無効にしません](../code-quality/ca5363.md)|要求の検証は、ASP.NET の機能の1つで、HTTP 要求を調べて、クロスサイトスクリプトを含む注入攻撃につながる可能性がある危険性のあるコンテンツが含まれているかどうかを判断します。|
|[CA5364: 非推奨のセキュリティ プロトコルを使用しないでください](../code-quality/ca5364.md)|トランスポート層セキュリティ (TLS) は、通常、ハイパーテキスト転送プロトコルセキュア (HTTPS) を使用して、コンピューター間の通信をセキュリティで保護します。 Tls の古いプロトコルバージョンは、TLS 1.2 および TLS 1.3 よりも安全性が低く、新しい脆弱性が発生する可能性が高くなります。 リスクを最小限に抑えるために、古いプロトコルバージョンを避けてください。|
|[CA5365: HTTP ヘッダーのチェックを無効にしません](../code-quality/ca5365.md)|HTTP ヘッダーチェックでは、応答ヘッダーに含まれる復帰文字と改行文字 (\r と \n) をエンコードできます。 このエンコーディングは、ヘッダーに含まれる信頼されていないデータをエコーするアプリケーションを悪用する注入攻撃を回避するのに役立ちます。|
|[CA5366: DataSet Read XML に XmlReader を使用します](../code-quality/ca5366.md)|を使用して <xref:System.Data.DataSet> 信頼できないデータを持つ XML を読み取ると、危険な外部参照が読み込まれる可能性があります。これは、 <xref:System.Xml.XmlReader> セキュリティで保護された競合回避モジュールを使用するか、DTD 処理を無効にして制限する必要があり|
|[CA5367: ポインター フィールドを持つ型をシリアル化しません](../code-quality/ca5367.md)|このルールでは、ポインターフィールドまたはプロパティを持つシリアル化可能なクラスがあるかどうかを確認します。 シリアル化できないメンバーは、静的メンバーまたはでマークされたフィールドなどのポインターにすることができ <xref:System.NonSerializedAttribute> ます。|
|[CA5368: ページから派生したクラスに ViewStateUserKey を設定します](../code-quality/ca5368.md)|プロパティを設定する <xref:System.Web.UI.Page.ViewStateUserKey> と、個々のユーザーのビューステート変数に識別子を割り当てて、攻撃者が変数を使用して攻撃を生成できないようにすることで、アプリケーションに対する攻撃を防ぐことができます。 そうしないと、クロスサイト要求の偽造に対する脆弱性が発生します。|
|[CA5369:逆シリアル化に XmlReader を使用します](../code-quality/ca5369.md)|信頼されていない DTD と XML スキーマを処理すると、危険な外部参照を読み込むことができます。これは、セキュリティで保護された競合回避モジュールを使用するか、DTD および XML インラインスキーマ処理を無効にして、XmlReader を使用して制限する|
|[CA5370:読み取りの検証に XmlReader を使用します](../code-quality/ca5370.md)|信頼されていない DTD と XML スキーマを処理すると、危険な外部参照を読み込むことができます。 この危険な読み込みは、セキュリティで保護された競合回避モジュールで XmlReader を使用するか、DTD および XML インラインスキーマ処理を無効にして制限できます。|
|[CA5371:スキーマの読み取りに XmlReader を使用します](../code-quality/ca5371.md)|信頼されていない DTD と XML スキーマを処理すると、危険な外部参照を読み込むことができます。 セキュリティで保護された競合回避モジュールで XmlReader を使用するか、DTD および XML インラインスキーマ処理を使用すると、この制限は無効になります。|
|[CA5372:XPathDocument に XmlReader を使用します](../code-quality/ca5372.md)|信頼されていないデータから XML を処理すると、危険な外部参照が読み込まれる可能性があります。これは、セキュリティで保護された競合回避モジュールを使用するか、DTD 処理を無効にして、XmlReader|
|[CA5373:廃止されたキー派生関数を使用しません](../code-quality/ca5373.md)|このルールは、弱いキー派生メソッドとの呼び出しを検出し <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> `Rfc2898DeriveBytes.CryptDeriveKey` ます。 <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName>弱いアルゴリズム PBKDF1 が使用されていました。|
|[CA5374: XslTransform を使用しません](../code-quality/ca5374.md)|このルール <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> では、がコード内でインスタンス化されているかどうかを確認します。 <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType>は互換性のために残されているため、使用しないでください。|
|[CA5375: アカウントの Shared Access Signature を使用しないでください](../code-quality/ca5375.md)|アカウント SAS は、blob コンテナー、テーブル、キュー、およびサービス SAS で許可されていないファイル共有に対する読み取り、書き込み、および削除操作へのアクセスを委任できます。 ただし、コンテナーレベルのポリシーはサポートされておらず、付与されるアクセス許可をより柔軟に制御することはできません。 悪意のあるユーザーがアクセスすると、ストレージアカウントが簡単に侵害されます。|
|[CA5376: SharedAccessProtocol HttpsOnly を使用します](../code-quality/ca5376.md)|SAS は、HTTP でプレーンテキストで転送できない機密データです。|
|[CA5377: コンテナー レベルのアクセス ポリシーを使用します](../code-quality/ca5377.md)|コンテナーレベルのアクセスポリシーは、いつでも変更または失効できます。 これにより、付与されるアクセス許可をより柔軟に制御できるようになります。|
|[CA5378: ServicePointManagerSecurityProtocols を無効にしません](../code-quality/ca5378.md)|`Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols`をに設定すると、 `true` Windows Communication Framework の (WCF) Transport Layer SECURITY (tls) 接続が tls 1.0 を使用するように制限されます。 このバージョンの TLS は非推奨とされます。|
|[CA5379: 弱いキー派生関数アルゴリズムを使用しません](../code-quality/ca5379.md)|クラスは、 <xref:System.Security.Cryptography.Rfc2898DeriveBytes> 既定でアルゴリズムを使用し <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> ます。 またはそれ以上のコンストラクターの一部のオーバーロードで使用するハッシュアルゴリズムを指定する必要があり <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> ます。 プロパティに <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> はアクセサーのみがあり、 `get` 修飾子はありません `overriden` 。|
|[CA5380:ルート ストアに証明書を追加しません](../code-quality/ca5380.md)|このルールは、信頼されたルート証明機関の証明書ストアに証明書を追加するコードを検出します。 既定では、信頼されたルート証明機関の証明書ストアは、Microsoft ルート証明書プログラムの要件を満たしている一連のパブリック Ca で構成されます。|
|[CA5381:証明書がルート ストアに追加されていないことを確認します](../code-quality/ca5381.md)|このルールは、信頼されたルート証明機関の証明書ストアに証明書を追加する可能性のあるコードを検出します。 既定では、信頼されたルート証明機関の証明書ストアは、Microsoft ルート証明書プログラムの要件を満たす公開証明機関 (Ca) のセットを使用して構成されます。|
|[CA5382: ASP.NET Core で安全な Cookie を使用します](../code-quality/ca5382.md)|HTTPS 経由で使用できるアプリケーションでは、セキュリティで保護された cookie を使用する必要があります。これは、cookie がトランスポート層セキュリティ (TLS) を使用してのみ送信されることをブラウザーに示すことを示します。|
|[CA5383: ASP.NET Core で安全な Cookie を使用することを確認します](../code-quality/ca5383.md)|HTTPS 経由で使用できるアプリケーションでは、セキュリティで保護された cookie を使用する必要があります。これは、cookie がトランスポート層セキュリティ (TLS) を使用してのみ送信されることをブラウザーに示すことを示します。|
|[CA5384: デジタル署名アルゴリズム (DSA) を使用しません](../code-quality/ca5384.md)|DSA は、弱い非対称暗号化アルゴリズムです。|
|[CA5385: 十分なキー サイズの Rivest–Shamir–Adleman (RSA) アルゴリズムを使用します](../code-quality/ca5385.md)|RSA キーが2048ビットより小さい場合は、ブルートフォース攻撃に対して脆弱になります。|
|[CA5386: SecurityProtocolType 値のハードコードを避けます](../code-quality/ca5386.md)|トランスポート層セキュリティ (TLS) は、通常、ハイパーテキスト転送プロトコルセキュア (HTTPS) を使用して、コンピューター間の通信をセキュリティで保護します。 Tls 1.2 と TLS 1.3 は最新ではありませんが、プロトコルバージョン TLS 1.0 および TLS 1.1 は非推奨とされます。 今後、TLS 1.2 および TLS 1.3 が非推奨とされる可能性があります。 アプリケーションがセキュリティで保護されていることを確認するには、プロトコルバージョンをハードコーディングし、少なくとも .NET Framework v 4.7.1 をターゲットにするようにします。|
|[CA5387: 反復回数が十分でない弱いキー派生関数は使用しません](../code-quality/ca5387.md)|このルールは、によって暗号化キーが生成されたかどうかを、イテレーション数が10万未満であるかどうかを確認 <xref:System.Security.Cryptography.Rfc2898DeriveBytes> します。 反復回数が多いほど、生成された暗号化キーを推測しようとする辞書攻撃に対する軽減に役立ちます。|
|[CA5388: 弱いキー派生関数を使用する場合は十分な反復回数を確保してください](../code-quality/ca5388.md)|このルールは、によって暗号化キーが生成されたかどうかを、 <xref:System.Security.Cryptography.Rfc2898DeriveBytes> 10万未満の反復回数で確認します。 反復回数が多いほど、生成された暗号化キーを推測しようとする辞書攻撃に対する軽減に役立ちます。|
|[CA5389:アーカイブ項目のパスをターゲット ファイル システム パスに追加しません](../code-quality/ca5389.md)|ファイルパスは相対パスにすることができ、予想されるファイルシステムのターゲットパスの外部でファイルシステムにアクセスする可能性があります。これにより、悪意のある構成の変更や、配置と待機の手法を使用したリモートでのコードの実行が可能になります。|
|[CA5390: 暗号化キーをハードコーディングしません](../code-quality/ca5390.md)|対称アルゴリズムを成功させるには、送信側と受信側だけが秘密キーを認識している必要があります。 キーがハードコーディングされている場合は、簡単に検出できます。 コンパイル済みバイナリでも、悪意のあるユーザーが簡単に抽出できます。 秘密キーが侵害されると、暗号文は直接復号化でき、保護されなくなります。|
|[CA5391: ASP.NET Core MVC コントローラーで偽造防止トークンを使用します](../code-quality/ca5391.md)|偽造防止 `POST` トークンを検証せずに、、、または要求を処理すると、 `PUT` `PATCH` `DELETE` クロスサイト要求偽造攻撃に対して脆弱になる可能性があります。 クロスサイト要求偽造攻撃は、認証されたユーザーから ASP.NET Core MVC コントローラーに悪意のある要求を送信できます。|
|[CA5392: P/Invoke に対して DefaultDllImportSearchPaths 属性を使用します](../code-quality/ca5392.md)|既定では、P/Invoke 関数でプローブを使用して、 <xref:System.Runtime.InteropServices.DllImportAttribute> 読み込むライブラリの現在の作業ディレクトリを含む多数のディレクトリが検出されます。 これは、特定のアプリケーションのセキュリティ上の問題であり、DLL のハイジャックにつながる可能性があります。|
|[CA5393: 安全でない DllImportSearchPath 値を使用しないでください](../code-quality/ca5393.md)|既定の DLL 検索ディレクトリとアセンブリディレクトリに悪意のある DLL が存在する可能性があります。 または、アプリケーションの実行場所によっては、アプリケーションのディレクトリに悪意のある DLL が存在する可能性があります。|
|[CA5394: 安全でないランダム度を使用しません](../code-quality/ca5394.md)|暗号強度の弱い擬似乱数ジェネレーターを使用すると、攻撃者がセキュリティを重視した値が生成されることを予測できます。|
|[CA5395: アクション メソッドの HttpVerb 属性がありません](../code-quality/ca5395.md)|データの作成、編集、削除、またはその他の変更を行うすべてのアクションメソッドは、クロスサイト要求偽造攻撃からの偽造防止属性で保護する必要があります。 GET 操作の実行は、副作用のない安全な操作であり、永続化されたデータを変更することはありません。|
|[CA5396: HttpCookie で HttpOnly を true に設定します](../code-quality/ca5396.md)|多層防御の手段として、セキュリティが重要な HTTP クッキーが HttpOnly としてマークされていることを確認します。 これは、web ブラウザーがスクリプトによる cookie へのアクセスを許可しないことを示します。 挿入された悪意のあるスクリプトは、cookie を盗む一般的な方法です。|
|[CA5397:非推奨の SslProtocols 値を使用しません](../code-quality/ca5397.md)|トランスポート層セキュリティ (TLS) は、通常、ハイパーテキスト転送プロトコルセキュア (HTTPS) を使用して、コンピューター間の通信をセキュリティで保護します。 Tls の古いプロトコルバージョンは、TLS 1.2 および TLS 1.3 よりも安全性が低く、新しい脆弱性が発生する可能性が高くなります。 リスクを最小限に抑えるために、古いプロトコルバージョンを避けてください。|
|[CA5398:ハードコーディングされた SslProtocols 値を回避します](../code-quality/ca5398.md)|トランスポート層セキュリティ (TLS) は、通常、ハイパーテキスト転送プロトコルセキュア (HTTPS) を使用して、コンピューター間の通信をセキュリティで保護します。 Tls 1.2 と TLS 1.3 は最新ではありませんが、プロトコルバージョン TLS 1.0 および TLS 1.1 は非推奨とされます。 今後、TLS 1.2 および TLS 1.3 が非推奨とされる可能性があります。 アプリケーションがセキュリティで保護されていることを確認するには、プロトコルバージョンをハードコーディングしないようにします。|
|[CA5399: HttpClient 証明書失効リストの確認を確実に無効にします](../code-quality/ca5399.md)|失効した証明書は信頼されていません。 攻撃者が悪意のあるデータを渡すか、または HTTPS 通信で機微なデータを盗むために使用される可能性があります。|
|[CA5400: HttpClient 証明書失効リストの確認が無効になっていないことをご確認ください](../code-quality/ca5400.md)|失効した証明書は信頼されていません。 攻撃者が悪意のあるデータを渡すか、または HTTPS 通信で機微なデータを盗むために使用される可能性があります。|
|[CA5401: 既定以外の IV で CreateEncryptor を使用しません](../code-quality/ca5401.md)|対称暗号化では、ディクショナリ攻撃を防ぐために、常に反復不可能な初期化ベクターを使用する必要があります。|
|[CA5402: 既定の IV で CreateEncryptor を使用します](../code-quality/ca5402.md)|対称暗号化では、ディクショナリ攻撃を防ぐために、常に反復不可能な初期化ベクターを使用する必要があります。|
