---
title: セキュリティの警告
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security warnings
- managed code analysis warnings, security warnings
- warnings, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: bf1f318d8138bb455e965d7df44ae45e192904e3
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/07/2019
ms.locfileid: "72018769"
---
# <a name="security-warnings"></a>セキュリティの警告

セキュリティ警告は、より安全なライブラリとアプリケーションをサポートします。 この警告によって、プログラムにセキュリティ上の欠陥が含まれるのを防ぐことができます。 この警告のいずれかを無効にする場合、明確にコードに理由を記載し、開発プロジェクトの指定されたセキュリティ管理者にも報告します。

## <a name="in-this-section"></a>このセクションの内容

|Rule|説明|
|----------|-----------------|
|[CA2100:セキュリティの脆弱性について SQL クエリを確認する @ no__t-0|メソッドに渡された文字列引数から構築された文字列を使用して System.Data.IDbCommand.CommandText プロパティが設定されています。 この規則では、文字列引数にユーザー入力が含まれていることが想定されています。 ユーザー入力から構築された SQL コマンド文字列には、SQL 注入攻撃に対する脆弱性があります。|
|[CA2102:一般的なハンドラーで CLSCompliant 以外の例外をキャッチする @ no__t-0|アセンブリ内の RuntimeCompatibilityAttribute でマークされていないメンバーまたは RuntimeCompatibility(WrapNonExceptionThrows = false) でマークされているメンバーには、System.Exception を処理する catch ブロックがあり、その直後に汎用 catch ブロックはありません。|
|[CA2103:強制セキュリティの確認 @ no__t-0|メソッドが強制セキュリティを使用しています。また、そのメソッドで、確認要求がアクティブな場合でも変更できるステータス情報または戻り値を使用して、アクセス許可を構築している可能性があります。 できる限り、宣言セキュリティを使用します。|
|[CA2104:読み取り専用の変更可能な参照型を宣言しないでください @ no__t-0|外部から参照できる型に、変更可能な参照型である、外部から参照可能な読み取り専用のフィールドがあります。 変更可能な型とは、インスタンス データを変更できる型です。|
|[CA2105:配列フィールドを読み取り専用にすることはできません @ no__t-0|配列を含むフィールドに読み取り専用 (Visual Basic では ReadOnly) 修飾子を適用すると、そのフィールドで参照先の配列を変更できません。 ただし、読み取り専用フィールドに格納された配列の要素は変更できます。|
|[CA2106:Secure assert @ no__t-0|メソッドによってアクセス許可がアサートされますが、呼び出し元に対してセキュリティ チェックが実行されていません。 セキュリティ チェックを実行せずにセキュリティ アクセス許可をアサートすると、悪用される可能性があるセキュリティの弱点がコード内に残る場合があります。|
|[CA2107:Deny をレビューし、使用のみを許可する @ no__t-0|PermitOnly メソッドと CodeAccessPermission を使用します。 Deny セキュリティアクションは、.NET セキュリティに関する高度な知識を持つユーザーのみが使用する必要があります。 コードにこのセキュリティ アクションを使用する場合、セキュリティを再確認する必要があります。|
|[CA2108:値型の宣言セキュリティを確認する @ no__t-0|パブリックまたはプロテクトの値型が、データ アクセスまたはリンク確認要求で保護されています。|
|[CA2109:表示されているイベントハンドラーを確認する @ no__t-0|パブリックまたはプロテクトのイベント ハンドラー メソッドが検出されました。 イベント ハンドラー メソッドは、絶対に必要な場合を除き公開しないでください。|
|[CA2111:ポインターを表示できません @ no__t-0|ポインターがプライベート、内部、読み取り専用のいずれでもありません。 悪意のあるコードで、ポインターの値が変更される可能性があります。結果的に、メモリの任意の位置にアクセスされたり、アプリケーション エラーやシステム障害の原因になります。|
|[CA2112:セキュリティで保護された型はフィールド @ no__t を公開しません。|パブリック型またはプロテクト型に、パブリック フィールドが含まれ、リンク確認要求で保護されています。 リンク確認要求で保護されている型のインスタンスに対するアクセス権がコードにある場合、その型のフィールドにアクセスするためにリンク確認要求に適合する必要はありません。|
|[CA2114:メソッドセキュリティは、型 @ no__t のスーパーセットでなければなりません。|メソッドでは、同じアクションについて、メソッド レベルと型レベルの宣言セキュリティの両方を指定することはできません。|
|[CA2115:GC を呼び出します。ネイティブリソースを使用する場合の KeepAlive @ no__t|この規則では、アンマネージ コードでまだ使用されているのに、アンマネージ リソースが終了されたときに発生する可能性のあるエラーを検出します。|
|[CA2116:APTCA メソッドは APTCA メソッドを呼び出す必要があります @ no__t-0|APTCA (AllowPartiallyTrustedCallers) 属性が完全に信頼されたアセンブリにあり、部分的に信頼された呼び出し元を許可しない別のアセンブリのコードをアセンブリが実行する場合、セキュリティ上の弱点になります。|
|[CA2117:APTCA 型は APTCA 基本型のみを拡張する @ no__t-0|APTCA (AllowPartiallyTrustedCallers) 属性が完全に信頼されたアセンブリにあり、アセンブリの型が部分的に信頼された呼び出し元を許可しない型から継承する場合、セキュリティ上の弱点になります。|
|[CA2118:SuppressUnmanagedCodeSecurityAttribute 使用状況の確認 @ no__t-0|COM 相互運用機能またはプラットフォーム呼び出し機能を使用するアンマネージ コードを実行するメンバーの場合、SuppressUnmanagedCodeSecurityAttribute によって、既定のセキュリティ システムの動作が変わります。 この属性は、主にパフォーマンスを向上するために使用されますが、パフォーマンスが向上するとセキュリティ上のリスクも高くなります。|
|[CA2119:プライベートインターフェイスを満たすメソッドをシールする @ no__t-0|継承可能なパブリック型により、internal (Visual Basic では Friend) インターフェイスのオーバーライド可能なメソッド実装が提供されます。 この規則違反を修正するには、アセンブリの外側でメソッドがオーバーライドされないようにします。|
|[CA2120:セキュリティで保護されたシリアル化コンストラクター @ no__t-0|この型には、System.Runtime.Serialization.SerializationInfo オブジェクトおよび System.Runtime.Serialization.StreamingContext オブジェクトを使用するコンストラクター (シリアル化コンストラクターのシグネチャ) があります。 このコンストラクターはセキュリティ チェックで保護されていませんが、型に含まれる標準コンストラクターの 1 つ以上は保護されています。|
|[CA2121:静的コンストラクターはプライベートでなければなりません](../code-quality/ca2121.md)|システムで静的コンストラクターが呼び出されてから、型の最初のインスタンスが作成されるか、静的メンバーが参照されます。 静的コンストラクターがプライベートである場合、システム以外のコードから呼び出すことができます。 コンストラクターで実行される操作によっては、これによって予期しない動作が発生することがあります。|
|[CA2122:リンク確認要求で間接的にメソッドを公開しないでください。 @ no__t-0|パブリック メンバーまたはプロテクト メンバーはリンク確認要求を含み、セキュリティ チェックを実行しないメンバーから呼び出されています。 リンク確認要求では、直接の呼び出し元のアクセス許可しかチェックされません。|
|[CA2123:オーバーライドリンク確認要求は、ベース @ no__t と同じである必要があります-0|この規則は、メソッドをその基本メソッド (別の型のインターフェイスまたは仮想メソッド) とマッチングし、それぞれについてリンク確認要求を比較します。 この規則に違反すると、悪意のある呼び出し元が、保護されていないメソッドを呼び出すだけで、リンク確認要求を省略できます。|
|[CA2124:脆弱性のある finally 句を外側の try @ no__t でラップする-0|パブリック メソッドまたはプロテクト メソッドに try/finally ブロックが含まれています。 この finally ブロックはセキュリティの状態をリセットすると思われますが、それ自体が finally ブロックで囲まれていません。|
|[CA2126:型のリンク要求には継承要求が必要です @ no__t-0|シールされていないパブリックな型がリンク確認要求によって保護され、オーバーライド可能なメソッドを持っています。 その型またはメソッドが継承確認要求によって保護されていません。|
|[CA2130:セキュリティクリティカルな定数は透過的 @ no__t-0|実行時に検索の必要がない値がコンパイラのインライン定数に設定されているため、定数値に対して透過性は適用されません。 透過的なコードからは定数にアクセスできないとコード レビューアーが考えることがないよう、定数フィールドは透過的セキュリティなフィールドとして定義する必要があります。|
|[CA2131:セキュリティクリティカルな型は、型の等価性 @ no__t には参加できません。|型は型の等価性に関与し、型自体、または型のメンバーまたはフィールドのいずれかが SecurityCriticalAttribute 属性でマークされています。 この規則は、すべての重要な型、または型の等価性に関与する重要なメソッドあるいはフィールドが定義されたすべての型に対して適用されます。 こうした型が CLR によって検出されると、CLR による型の読み込みが失敗し、実行時に TypeLoadException が発生します。 通常は、tlbimp やコンパイラによって型の等価性を実装するのではなく、ユーザーが手動で実装した場合に、この規則が適用されます。|
|[CA2132:既定のコンストラクターは、基本データ型の既定コンストラクター @ no__t と同じである必要があります。|SecurityCriticalAttribute でマークされている型およびメンバーを Silverlight アプリケーション コードで使用することはできません。 セキュリティが重要な型やメンバーは、.NET Framework for Silverlight クラス ライブラリの信頼されているコードからのみ使用できます。 派生クラスにおけるパブリックな構築または保護された構築の透過性は、基底クラスと同程度以上である必要があるため、アプリケーション内のクラスを、SecurityCritical としてマークされたクラスから派生させることはできません。|
|[CA2133:デリゲートは、透過性が一貫しているメソッドにバインドする必要があります @ no__t-0|この警告は、SecurityCriticalAttribute でマークされているデリゲートを、透過的メソッドまたは SecuritySafeCriticalAttribute でマークされているメソッドにバインドするメソッドに対して適用されます。 この警告は、透過的なデリゲートまたはセーフ クリティカルなデリゲートを、クリティカル メソッドにバインドするメソッドに対しても適用されます。|
|[CA2134:基本メソッドをオーバーライドする場合、メソッドは一貫性のある透明度を維持する必要がある @ no__t-0|この規則は、SecurityCriticalAttribute でマークされているメソッドが、透過的メソッドまたは SecuritySafeCriticalAttribute でマークされているメソッドをオーバーライドするときに適用されます。 また、透過的メソッドまたは SecuritySafeCriticalAttribute が適用されたメソッドが、SecurityCriticalAttribute が適用されたメソッドをオーバーライドした場合も、この規則が適用されます。 この規則は、仮想メソッドをオーバーライドする場合やインターフェイスを実装する場合に適用されます。|
|[CA2135:レベル2のアセンブリには、Linkdemand @ no__t を含めることはできません。|LinkDemands は、レベル 2 のセキュリティ規則セットでは使用が非推奨とされます。 LinkDemands を使用して Just-In-Time (JIT) コンパイル時にセキュリティを適用するのではなく、メソッド、型、およびフィールドに SecurityCriticalAttribute 属性を設定します。|
|[CA2136:メンバーには、競合する透過性注釈を含めることはできません @ no__t-0|透過性属性は、大きいスコープのコード要素から小さいスコープの要素に適用されます。 大きいスコープのコード要素の透過性属性は、最初の要素に含まれているコード要素の透過性属性よりも優先されます。 たとえば、SecurityCriticalAttribute 属性でマークされたクラスに SecuritySafeCriticalAttribute 属性でマークされたメソッドを含めることはできません。|
|[CA2137:透過的メソッドには、検証可能な IL @ no__t のみを含める必要があります。|メソッドに検証できないコードが含まれているか、メソッドから参照渡しで型が返されます。 この規則は、透過的セキュリティ コードが、検証できない MSIL (Microsoft Intermediate Language) を実行しようとすると適用されます。 ただし、規則には完全な IL 検証ツールは含まれていないため、代わりにヒューリスティックを使用して、ほとんどの MSIL 検証違反が検出されます。|
|[CA2138:Transparent メソッドでは、SuppressUnmanagedCodeSecurity 属性 @ no__t を指定してメソッドを呼び出すことはできません。|SuppressUnmanagedCodeSecurityAttribute 属性が適用されたメソッドを、透過的セキュリティ メソッドが呼び出します。|
|[CA2139:Transparent メソッドでは、HandleProcessCorruptingExceptions 属性 @ no__t を使用することはできません。|この規則は、透過的な任意のメソッドに対して適用され、HandleProcessCorruptedStateExceptionsAttribute 属性を使用して例外の処理を処理しようとします。 プロセスの破損例外は、<xref:System.AccessViolationException> などの例外の CLR バージョン4.0 例外の分類です。 HandleProcessCorruptedStateExceptionsAttribute 属性はセキュリティ クリティカルなメソッドでのみ使用できる属性で、透過的メソッドに適用された場合は無視されます。|
|[CA2140:透過的なコードでは、セキュリティ上重要な項目 @ no__t を参照することはできません。|SecurityTransparentAttribute でマークされたメソッドが、SecurityCritical とマークされたパブリックでないメンバーを呼び出しています。 このルールは、transparent と critical が混在しているアセンブリ内のすべてのメソッドと型を分析し、transparent code から SecurityTreatAsSafe とマークされていない非パブリックの重要なコードへの呼び出しにフラグを設定します。|
|[CA2141: 透過的メソッドは、LinkDemand を満たしてはならない](../code-quality/ca2141.md)|透過的メソッドは、AllowPartiallyTrustedCallersAttribute (APTCA) 属性が適用されていないアセンブリ内のメソッドを呼び出します。また、透過的セキュリティ メソッドは、データ型またはメソッドに対する LinkDemand の要件を満たします。|
|[CA2142:透過的なコードは、Linkdemand @ no__t を使用して保護することはできません。|この規則は、アクセスするために LinkDemands を要求する透過的メソッドに対して適用されます。 透過的セキュリティ コードでは、操作のセキュリティ検証を行うことができないため、アクセス許可を要求できません。|
|[CA2143:透過的メソッドでは、セキュリティ確認要求を使用しないでください。 @ no__t-0|透過的セキュリティ コードでは、操作のセキュリティ検証を行うことができないため、アクセス許可を要求できません。 透過的セキュリティ コードは、フル アクセス要求を使用して、セキュリティ上の決定を行う必要があります。セーフ クリティカルなコードでは、透過的なコードを使用してフル アクセス要求を行うことはできません。|
|[CA2144:透過的なコードでは、バイト配列 @ no__t からアセンブリを読み込むことはできません。|透過的なコードはセキュリティ上重要な操作を実行できないため、透過的なコードのセキュリティ レビューは、クリティカル コードのセキュリティ レビューほど完全ではありません。 バイト配列から読み込まれるアセンブリは透過的なコード内で認識されない場合がありますが、監査を必要とする、クリティカルなコード、またはさらに重要であるセーフ クリティカルなコードがそのバイト配列に含まれる可能性があります。|
|[CA2145:Transparent メソッドは SuppressUnmanagedCodeSecurityAttribute @ no__t で修飾しないでください。|SuppressUnmanagedCodeSecurityAttribute 属性で修飾されたメソッドには、それを呼び出すメソッドに対して適用される暗黙的な LinkDemand があります。 この LinkDemand では、呼び出し元のコードがセキュリティ クリティカルなコードである必要があります。 SuppressUnmanagedCodeSecurity を使用するメソッドに SecurityCriticalAttribute 属性を設定すると、メソッドの呼び出し元に対してこの要件がより明確になります。|
|[CA2146:型は少なくとも基本型とインターフェイス @ no__t-0 と同じである必要があります|派生型に透過的セキュリティ属性が設定されていて、この属性が基本型または実装されたインターフェイスほど重要ではない場合に、この規則が適用されます。 クリティカルな基本型から派生したり、クリティカルなインターフェイスを実装したりできるのは、クリティカルなデータ型だけです。また、セーフ クリティカルな基本型から派生したり、セーフ クリティカルなインターフェイスを実装したりできるのは、クリティカルまたはセーフ クリティカルなデータ型だけです。|
|[CA2147:透過的メソッドは、セキュリティアサート @ no__t を使用することはできません。|この規則では、完全に透過的なアセンブリまたは透過的/クリティカル混在のアセンブリ内のすべてのメソッドと型を分析し、宣言的または強制的に使用されている Assert にフラグを設定します。|
|[CA2149:透過的メソッドはネイティブコード @ no__t を呼び出すことはできません。|この規則は、P/Invoke などを使用してネイティブコードを直接呼び出す透過的メソッドに対して適用されます。 この規則に違反すると、レベル 2 の透過性モデルで MethodAccessException が発生し、レベル 1 の透過性モデルで UnmanagedCode に対するフル アクセス要求が発生します。|
|[CA2151:重要な型のフィールドはセキュリティクリティカル @ no__t-0|セキュリティ クリティカルな型を使用するには、型を参照するコードがセキュリティ クリティカルであるか、セキュリティ セーフ クリティカルである必要があります。 これは、参照が間接的である場合にも当てはまります。 そのため、透過的セキュリティまたはセキュリティ セーフ クリティカルなフィールドが存在すると、透過的なコードはこのフィールドにアクセスできないので、紛らわしくなります。|
|[CA2153:破損状態の例外の処理を回避する @ no__t-0|[破損状態例外 (CSE)](https://msdn.microsoft.com/magazine/dd419661.aspx) は、メモリの破損がプロセス内に存在していることを示します。 プロセスをクラッシュさせるのではなくこれらの例外をキャッチすることは、攻撃者が破損したメモリ領域にセキュリティ上の弱点を見出すことができた場合に、セキュリティ上の脆弱性となる可能性があります。|
|[CA2300:セキュリティで保護されていないデシリアライザー BinaryFormatter @ no__t を使用しないでください。|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2301:Binaryformatter を最初に設定しないで BinaryFormatter を呼び出さないでください。 Binder @ no__t-0|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2302:BinaryFormatter を呼び出す前に、BinaryFormatter が設定されていることを確認してください。逆シリアル化 @ no__t-0|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2305:セキュリティで保護されていないデシリアライザー LosFormatter @ no__t を使用しないでください。|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2310:セキュリティで保護されていないデシリアライザー NetDataContractSerializer @ no__t-0 を使用しない|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2311:最初に NetDataContractSerializer を設定しないで逆シリアル化しないでください。 @ no__t-0|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2312:@ No__t を逆シリアル化する前に NetDataContractSerializer が設定されていることを確認してください。|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2315:セキュリティで保護されていないデシリアライザー ObjectStateFormatter @ no__t-0 を使用しない|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2321:SimpleTypeResolver @ no__t を使用して JavaScriptSerializer で逆シリアル化しないでください。|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2322:JavaScriptSerializer が SimpleTypeResolver で初期化されていないことを確認してから、@ no__t を逆シリアル化してください。|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2326:None 以外の TypeNameHandling 値を使用しないでください。 @ no__t-0|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2327:安全でない JsonSerializerSettings @ no__t-0 を使用しない|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2328:JsonSerializerSettings が secure @ no__t-0 であることを確認します。|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2329:セキュリティで保護されていない構成 @ no__t を使用して JsonSerializer で逆シリアル化しないでください。|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA2330:No__t を逆シリアル化するときに、JsonSerializer にセキュリティで保護された構成があることを確認します。|安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。|
|[CA3001:SQL インジェクションの脆弱性に関するコードを確認する @ no__t-0|信頼されていない入力と SQL コマンドを使用する場合は、SQL インジェクション攻撃に注意してください。 SQL インジェクション攻撃によって、悪意のある SQL コマンドを実行し、アプリケーションのセキュリティと整合性を損なう可能性があります。|
|[CA3002:XSS 脆弱性のコードを確認する @ no__t-0|Web 要求から信頼されていない入力を処理する場合は、クロスサイトスクリプティング (XSS) 攻撃に注意する必要があります。 XSS 攻撃によって、信頼できない入力が未加工の HTML 出力に挿入され、攻撃者が悪意のあるスクリプトを実行したり、web ページのコンテンツを改ざんしたりする可能性があります。|
|[CA3003:ファイルパスインジェクションの脆弱性のコードを確認する @ no__t-0|Web 要求から信頼されていない入力を使用する場合は、ファイルへのパスを指定するときにユーザーが制御する入力を使用することに注意してください。|
|[CA3004:情報漏えいの脆弱性に関するコードを確認する @ no__t-0|例外情報を公開すると、攻撃者がアプリケーションの内部を調べて、攻撃者が他の脆弱性を悪用するのを支援することができます。|
|[CA3006:プロセスコマンドインジェクションの脆弱性のコードを確認する @ no__t-0|信頼されていない入力を使用する場合は、コマンドインジェクション攻撃に注意してください。 コマンドインジェクション攻撃は、基になるオペレーティングシステムで悪意のあるコマンドを実行し、サーバーのセキュリティと整合性を損なう可能性があります。|
|[CA3007:開いているリダイレクトの脆弱性のコードを確認する @ no__t-0|信頼されていない入力を使用する場合は、開いているリダイレクトの脆弱性に注意してください。 攻撃者は、開いているリダイレクトの脆弱性を悪用して、web サイトを使用して正当な URL を表示することができますが、悪意のあるユーザーをフィッシングやその他の悪意のある web ページにリダイレクトする可能性があります。|
|[CA3008:XPath インジェクションの脆弱性のコードを確認する @ no__t-0|信頼されていない入力を使用する場合は、XPath インジェクション攻撃に注意してください。 信頼されていない入力を使用して XPath クエリを作成すると、攻撃者がクエリを故意に操作して意図しない結果を返すことがあり、場合によってはクエリ対象の XML の内容を開示できます。|
|[CA3009:XML インジェクションの脆弱性に関するコードを確認する @ no__t-0|信頼されていない入力を使用する場合は、XML インジェクション攻撃に注意してください。|
|[CA3010:XAML インジェクションの脆弱性に関するコードを確認する @ no__t-0|信頼されていない入力を扱う場合は、XAML インジェクション攻撃に注意してください。 XAML は、オブジェクトのインスタンス化と実行を直接表すマークアップ言語です。 つまり、XAML で作成された要素は、システムリソース (ネットワークアクセスやファイルシステム IO など) とやり取りできます。|
|[CA3011:DLL インジェクションの脆弱性に関するコードを確認する @ no__t-0|信頼できない入力を使用する場合は、信頼されていないコードを読み込むことに注意してください。 Web アプリケーションが信頼されていないコードを読み込む場合、攻撃者は悪意のある Dll をプロセスに挿入して、悪意のあるコードを実行できる可能性があります。|
|[CA3012:Regex インジェクションの脆弱性に関するコードを確認する @ no__t-0|信頼できない入力を使用する場合は、regex インジェクション攻撃に注意してください。 攻撃者は、regex インジェクションを使用して正規表現を故意に変更したり、regex が意図しない結果に一致するようにしたり、regex が過剰な CPU を消費してサービス拒否攻撃を受ける可能性があります。|
|[CA3061:URL @ no__t でスキーマを追加しないでください。|危険な外部参照が発生する可能性があるため、Add メソッドの unsafe オーバーロードは使用しないでください。|
|[CA3075:安全ではない DTD の処理 @ no__t-0|安全ではない DTDProcessing インスタンスを使用する場合、または外部エンティティ ソースを参照する場合、パーサーは信頼されていない入力を受け入れ、攻撃者に機密情報を漏えいしてしまう可能性があります。|
|[CA3076:安全ではない XSLT スクリプトの実行 @ no__t-0|.NET アプリケーションで XSLT (Extensible Stylesheet Language Transformation) を安全ではない方法で実行すると、攻撃者に機密情報を漏えいする可能性のある、信頼されていない URI 参照がプロセッサにより解決されるおそれがあります。そのことは、サービス拒否攻撃やクロスサイト攻撃につながります。|
|[CA3077:API デザイン、XML ドキュメント、および XML テキストリーダー @ no__t の安全ではない処理|XMLDocument と XMLTextReader から派生する API をデザインする場合、DtdProcessing にご注意ください。 外部エンティティ ソースを参照または解決したり、XML に安全ではない値を設定したりする場合に、安全ではない DTDProcessing インスタンスを使用すると、情報漏えいにつながる可能性があります。|
|[CA3147:Validateアンチ Forgerytoken @ no__t に動詞ハンドラーをマークします|ASP.NET MVC コントローラーを設計するときは、クロスサイトリクエストの偽造攻撃に注意してください。 クロスサイト要求偽造攻撃は、認証されたユーザーから ASP.NET MVC コントローラーに悪意のある要求を送信できます。|
|[CA5122 P/Invoke 宣言をセーフ クリティカルにしないでください](../code-quality/ca5122.md)|メソッドは、セキュリティに対する配慮が必要な操作を行うときは SecuritySafeCritical としてマークされますが、透過的なコードによって使用される場合も安全です。 透過的なコードは、P/Invoke を通じてネイティブ コードを直接呼び出すことはありません。 そのため、P/Invoke をセキュリティ セーフ クリティカルとしてマークしても、透過的なコードはそれを呼び出すことができず、セキュリティ分析の際に紛らわしくなります。|
|[CA5361:強力な暗号の SChannel 使用を無効にする @ no__t-0|@No__t-0 を `true` に設定すると、送信トランスポート層セキュリティ (TLS) 接続で使用される暗号化が弱くなります。 弱い暗号化を使用すると、アプリケーションとサーバーの間の通信の機密性が低下する可能性があるため、攻撃者が機微なデータを簡単に盗聴ことができます。|
|[CA5363:要求の検証を無効にする @ no__t-0|要求の検証は、ASP.NET の機能の1つで、HTTP 要求を調べて、クロスサイトスクリプトを含む注入攻撃につながる可能性がある危険性のあるコンテンツが含まれているかどうかを判断します。|
|[CA5364:非推奨のセキュリティプロトコル @ no__t を使用しないでください。|トランスポート層セキュリティ (TLS) は、通常、ハイパーテキスト転送プロトコルセキュア (HTTPS) を使用して、コンピューター間の通信をセキュリティで保護します。 Tls の古いプロトコルバージョンは、TLS 1.2 および TLS 1.3 よりも安全性が低く、新しい脆弱性が発生する可能性が高くなります。 リスクを最小限に抑えるために、古いプロトコルバージョンを避けてください。|
|[CA5369:逆シリアル化に XmlReader を使用する @ no__t-0|信頼されていない DTD と XML スキーマを処理すると、危険な外部参照を読み込むことができます。これは、セキュリティで保護された競合回避モジュールを使用するか、DTD および XML インラインスキーマ処理を無効にして、XmlReader を使用して制限する|
|[CA5370:読み取りの検証に XmlReader を使用する @ no__t-0|信頼されていない DTD と XML スキーマを処理すると、危険な外部参照を読み込むことができます。 この危険な読み込みは、セキュリティで保護された競合回避モジュールで XmlReader を使用するか、DTD および XML インラインスキーマ処理を無効にして制限できます。|
|[CA5371:スキーマ読み取りに XmlReader を使用する @ no__t-0|信頼されていない DTD と XML スキーマを処理すると、危険な外部参照を読み込むことができます。 セキュリティで保護された競合回避モジュールで XmlReader を使用するか、DTD および XML インラインスキーマ処理を使用すると、この制限は無効になります。|
|[CA5372:No__t の XmlReader を使用してください。|信頼されていないデータから XML を処理すると、危険な外部参照が読み込まれる可能性があります。これは、セキュリティで保護された競合回避モジュールを使用するか、DTD 処理を無効にして、XmlReader|
|[CA5373:使用しないキー派生関数 @ no__t-0|このルールは、<xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> および `Rfc2898DeriveBytes.CryptDeriveKey` の弱いキー派生メソッドの呼び出しを検出します。 <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> では弱いアルゴリズム PBKDF1 が使用されていました。|
|[CA5378:ServicePointManagerSecurityProtocols @ no__t を無効にしないでください。|@No__t-0 を `true` に設定すると、Windows Communication Framework の (WCF) Transport Layer Security (TLS) 接続が TLS 1.0 を使用するように制限されます。 このバージョンの TLS は非推奨とされます。|
|[CA5380:ルートストア @ no__t に証明書を追加しないでください。|このルールは、信頼されたルート証明機関の証明書ストアに証明書を追加するコードを検出します。 既定では、信頼されたルート証明機関の証明書ストアは、Microsoft ルート証明書プログラムの要件を満たしている一連のパブリック Ca で構成されます。|
|[CA5381:証明書がルートストアに追加されていないことを確認する @ no__t-0|このルールは、信頼されたルート証明機関の証明書ストアに証明書を追加する可能性のあるコードを検出します。 既定では、信頼されたルート証明機関の証明書ストアは、Microsoft ルート証明書プログラムの要件を満たす公開証明機関 (Ca) のセットを使用して構成されます。|
|[CA5386:値 @ no__t をハードコーディングしないでください。|トランスポート層セキュリティ (TLS) は、通常、ハイパーテキスト転送プロトコルセキュア (HTTPS) を使用して、コンピューター間の通信をセキュリティで保護します。 Tls 1.2 と TLS 1.3 は最新ではありませんが、プロトコルバージョン TLS 1.0 および TLS 1.1 は非推奨とされます。 今後、TLS 1.2 および TLS 1.3 が非推奨とされる可能性があります。 アプリケーションがセキュリティで保護されていることを確認するには、プロトコルバージョンをハードコーディングし、少なくとも .NET Framework v 4.7.1 をターゲットにするようにします。|
|[CA5389:ターゲットファイルシステムパス @ no__t にアーカイブ項目のパスを追加しないでください。|ファイルパスは相対パスにすることができ、予想されるファイルシステムのターゲットパスの外部でファイルシステムにアクセスする可能性があります。これにより、悪意のある構成の変更や、配置と待機の手法を使用したリモートでのコードの実行が可能になります。|
|[CA5397:非推奨の SslProtocols 値 @ no__t を使用しないでください|ransport レイヤーセキュリティ (TLS) は、通常、ハイパーテキスト転送プロトコルセキュア (HTTPS) を使用して、コンピューター間の通信をセキュリティで保護します。 Tls の古いプロトコルバージョンは、TLS 1.2 および TLS 1.3 よりも安全性が低く、新しい脆弱性が発生する可能性が高くなります。 リスクを最小限に抑えるために、古いプロトコルバージョンを避けてください。|
|[CA5398:SslProtocols の値 @ no__t をハードコーディングしない|トランスポート層セキュリティ (TLS) は、通常、ハイパーテキスト転送プロトコルセキュア (HTTPS) を使用して、コンピューター間の通信をセキュリティで保護します。 Tls 1.2 と TLS 1.3 は最新ではありませんが、プロトコルバージョン TLS 1.0 および TLS 1.1 は非推奨とされます。 今後、TLS 1.2 および TLS 1.3 が非推奨とされる可能性があります。 アプリケーションがセキュリティで保護されていることを確認するには、プロトコルバージョンをハードコーディングしないようにします。|
