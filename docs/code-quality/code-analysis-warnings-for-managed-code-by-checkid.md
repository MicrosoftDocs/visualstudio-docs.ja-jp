---
title: コード品質ルールの概要
ms.date: 08/27/2020
ms.topic: reference
f1_keywords:
- CA1000
- CA1001
- CA1002
- CA1003
- CA1005
- CA1008
- CA1010
- CA1012
- CS1014
- CA1016
- CA1017
- CA1018
- CA1019
- CA1021
- CA1024
- CA1027
- CA1028
- CA1029
- CA1030
- CA1031
- CA1032
- CA1033
- CA1034
- CA1036
- CA1040
- CA1041
- CA1043
- CA1044
- CA1045
- CA1046
- CA1047
- CA1050
- CA1051
- CA1052
- CA1053
- CA1054
- CA1055
- CA1056
- CA1058
- CA1060
- CA1061
- CA1062
- CA1063
- CA1064
- CA1065
- CA1066
- CA1067
- CA1068
- CA1069
- CA1070
- CA1200
- CA1303
- CA1304
- CA1305
- CA1307
- CA1308
- CA1309
- CA1310
- CA1401
- CA1417
- CA1501
- CA1502
- CA1505
- CA1506
- CA1507
- CA1508
- CA1509
- CA1700
- CA1707
- CA1708
- CA1710
- CA1711
- CA1712
- CA1713
- CA1714
- CA1715
- CA1716
- CA1717
- CA1720
- CA1721
- CA1724
- CA1725
- CA1801
- CA1802
- CA1805
- CA1806
- CA1810
- CA1812
- CA1813
- CA1814
- CA1815
- CA1816
- CA1819
- CA1820
- CA1821
- CA1822
- CA1823
- CA1824
- CA1825
- CA1826
- CA1827
- CA1828
- CA1829
- CA1830
- CA1831
- CA1832
- CA1833
- CA1834
- CA1835
- CA1836
- CA1837
- CA1838
- CA2000
- CA2002
- CA2007
- CA2008
- CA2009
- CA2011
- CA2012
- CA2013
- CA2014
- CA2015
- CA2016
- CA2100
- CA2101
- CA2109
- CA2119
- CA2153
- CA2200
- CA2201
- CA2207
- CA2208
- CA2211
- CA2213
- CA2214
- CA2215
- CA2216
- CA2217
- CA2219
- CA2225
- CA2226
- CA2227
- CA2229
- CA2231
- CA2234
- CA2235
- CA2237
- CA2241
- CA2242
- CA2243
- CA2245
- CA2246
- CA2247
- CA2248
- CA2249
- CA2300
- CA2301
- CA2302
- CA2305
- CA2310
- CA2311
- CA2312
- CA2315
- CA2321
- CA2322
- CA2326
- CA2327
- CA2328
- CA2329
- CA2330
- CA2350
- CA2351
- CA2352
- CA2353
- CA2354
- CA2355
- CA2356
- CA2361
- CA2362
- CA3001
- CA3002
- CA3003
- CA3004
- CA3005
- CA3006
- CA3007
- CA3008
- CA3009
- CA3010
- CA3011
- CA3012
- CA3061
- CA3075
- CA3076
- CA3077
- CA5347
- CA5350
- CA5351
- CA5359
- CA5360
- CA5361
- CA5362
- CA5363
- CA5364
- CA5365
- CA5366
- CA5367
- CA5368
- CA5369
- CA5370
- CA5371
- CA5372
- CA5373
- CA5374
- CA5375
- CA5376
- CA5377
- CA5378
- CA5379
- CA5380
- CA5381
- CA5382
- CA5383
- CA5384
- CA5385
- CA5386
- CA5387
- CA5388
- CA5389
- CA5390
- CA5391
- CA5392
- CA5393
- CA5394
- CA5395
- CA5397
- CA5398
- CA5399
- CA5400
- CA5401
- CA5402
- CA5403
- IL3000
- IL3001
ms.assetid: 5cb221f6-dc59-4abf-9bfa-adbd6f907f96
author: mikadumont
ms.author: midumont
manager: jillfra
ms.workload:
- dotnet
ms.openlocfilehash: 8e4b728fab6eb47501bb0d1bb752d22c0c29a8b4
ms.sourcegitcommit: 5caad925ca0b5d136416144a279e984836d8f28c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/07/2020
ms.locfileid: "89509446"
---
# <a name="code-analysis-warnings-for-managed-code-by-checkid"></a>マネージコードのコード分析警告 (CheckId 別)

次の表に、マネージド コードのコード分析警告を警告の CheckId 識別子別に示します。

| CheckId | 警告 | 説明 |
|---------| - | - |
| CA1000 | [CA1000:ジェネリック型の静的メンバーを宣言しません](../code-quality/ca1000.md) | ジェネリック型の静的メンバーを呼び出すときには、その型の型引数も指定する必要があります。 推論をサポートしないジェネリック インスタンス メンバーを呼び出すときには、そのメンバーに型引数を指定する必要があります。 この 2 つの場合、型引数を指定するときに使用される構文は異なりますが、混同される可能性があります。 |
| CA1001 | [CA1001:破棄可能なフィールドを所有する型は、破棄可能でなければなりません](../code-quality/ca1001.md) | クラスが System.IDisposable 型であるインスタンス フィールドを宣言および実装していますが、IDisposable を実装していません。 IDisposable フィールドを宣言するクラスは間接的にアンマネージ リソースを所有しているため、IDisposable インターフェイスを実装する必要があります。 |
| CA1002 | [CA1002:ジェネリック リストを公開しません](../code-quality/ca1002.md) | < (Of \<(T> ) >) は、継承ではなくパフォーマンスを目的として設計されたジェネリックコレクションです。 このため、List には仮想メンバーは含まれません。 代わりに、継承を目的としたジェネリック コレクションを公開する必要があります。 |
| CA1003 | [CA1003:汎用イベント ハンドラーのインスタンスを使用します](../code-quality/ca1003.md) |型に void を返すデリゲートが含まれており、デリゲートのシグネチャに 2 つのパラメーター (1 つはオブジェクト、もう 1 つは EventArgs に割り当て可能な型) が含まれ、包含アセンブリの対象が Microsoft .NET Framework 2.0. です。 |
| CA1005 | [CA1005:ジェネリック型でパラメーターを使用しすぎないでください](../code-quality/ca1005.md) | ジェネリック型に含まれる型パラメーターが増えれば増えるほど、それぞれの型パラメーターが表す意味を調べることや覚えることが難しくなります。 通常は、1つの型パラメーター (List など) と、 \<T> 2 つの型パラメーターを持つケース (Dictionary など) があることが明らかです \<TKey, TValue> 。 しかし、型パラメーターが 3 つ以上になると、ほとんどのユーザーには意味を把握することが困難になります。 |
| CA1008 | [CA1008:Enums は 0 値を含んでいなければなりません](../code-quality/ca1008.md) | 初期化されていない列挙型の既定値は、他の値型と同様に、ゼロです。 フラグではない属性が付いた列挙型では、ゼロの値を使用してメンバーを定義する必要があります。これは、既定値を有効な列挙値にするためです。 FlagsAttribute 属性を適用した列挙型でゼロ値のメンバーを定義する場合、名前を "None" にして、列挙型に設定済みの値がないことを示します。 |
| CA1010 | [CA1010:コレクションは、ジェネリック インターフェイスを実装しなければなりません](../code-quality/ca1010.md) | コレクションの操作性を拡充するために、ジェネリック コレクション インターフェイスの 1 つを実装します。 これにより、コレクションを使用してジェネリック コレクション型を設定できます。 |
| CA1012 | [CA1012:抽象型にはコンストラクターを含めません](../code-quality/ca1012.md) | 抽象型上のコンストラクターは、派生型からのみ呼び出すことができます。 パブリック コンストラクターで型のインスタンスが作成され、抽象型のインスタンスは自分で作成できないため、パブリック コンストラクターが含まれる抽象型のデザインは不適切になります。 |
| CA1014 | [CA1014:アセンブリに CLSCompliantAttribute を設定します](../code-quality/ca1014.md) | 共通言語仕様 (CLS) には、名前付けの制約、データ型、および規則が定義されています。アセンブリを複数のプログラミング言語で使用する場合、この仕様に準拠する必要があります。 すべてのアセンブリに <xref:System.CLSCompliantAttribute> を使用して、CLS への準拠を明示することをお勧めします。 この属性が使用されていないアセンブリは、CLS に準拠しません。 |
| CA1016 | [CA1016:アセンブリに AssemblyVersionAttribute を設定します](../code-quality/ca1016.md) | .NET では、バージョン番号を使用してアセンブリを一意に識別し、厳密な名前を持つアセンブリの型にバインドします。 バージョン番号は、バージョンと発行者のポリシーと共に使用されます。 既定で、アプリケーションは、ビルドされたアセンブリのバージョンでのみ実行されます。 |
| CA1017 | [CA1017:アセンブリに ComVisibleAttribute を設定します](../code-quality/ca1017.md) |ComVisibleAttribute 属性によって、COM クライアントからマネージド コードにアクセスする方法が決まります。 アセンブリで COM の参照範囲を明示することをお勧めします。 COM の参照範囲は、アセンブリ全体に設定し、個々の型と型のメンバー用にオーバーライドできます。 この属性がない場合、アセンブリのコンテンツは COM クライアントから参照できます。 |
| CA1018 | [CA1018:属性を AttributeUsageAttribute に設定します](../code-quality/ca1018.md) | カスタム属性を定義する場合、AttributeUsageAttribute を使用してマークし、カスタム属性を適用できるソース コードの位置を示します。 属性の意味と用途によって、コード内の有効な位置が決まります。 |
| CA1019 | [CA1019:属性引数にアクセサーを定義します](../code-quality/ca1019.md) | 属性では、対象に適用するときに必ず指定する必須の引数を定義できます。 この引数は、コンストラクターに位置指定パラメーターで属性を指定できるようになるため、位置指定引数とも呼ばれます。 必須のすべての引数について、対応する読み取り専用のプロパティも属性で規定する必要があります。これは、引数値を実行時に取得できるようにするためです。 また、属性ではオプションの引数も定義できます。これは名前付き引数とも呼ばれます。 この引数は、名前でコンストラクターに属性を指定するときに使用されます。また、対応する読み取り/書き込みプロパティが必要です。 |
| CA1021 | [CA1021:out パラメーターを使用しません](../code-quality/ca1021.md) | (out または ref を使用した) 型の参照渡しには、ポインターの使用経験、値型と参照型の違いの理解、および複数の戻り値を持つメソッドの処理が必要です。 また、out パラメーターと ref パラメーターの違いはあまり理解されていません。 |
| CA1024 | [CA1024:適切な場所にプロパティを使用します](../code-quality/ca1024.md) | パブリック メソッドまたはプロテクト メソッドに、"Get" で始まる名前が付けられ、パラメーターは使用されていません。また、配列ではない値を返します。 このメソッドは、プロパティに変更できる可能性があります。 |
| CA1027 |[CA1027:列挙型を FlagsAttribute に設定します](../code-quality/ca1027.md) | 列挙型は、関連する名前付き定数が複数定義された値型です。 名前付き定数を有意に結合できる場合、列挙型に FlagsAttribute を適用します。 |
| CA1028 | [CA1028:列挙ストレージは Int32 でなければなりません](../code-quality/ca1028.md) | 列挙型は、関連する名前付き定数が複数定義された値型です。 既定で、System.Int32 データ型は、定数値を格納するために使用されます。 この基になる型を変更できる場合でも、ほとんどの場合、変更する必要はなく、推奨もされません。 |
| CA1030 | [CA1030:適切な場所にイベントを使用します](../code-quality/ca1030.md) |この規則では、通常はイベントに使用される名前を持つメソッドを検出します。 明示的に定義された状態変化に応答してメソッドが呼び出される場合、メソッドはイベント ハンドラーから呼び出す必要があります。 メソッドを呼び出すオブジェクトは、メソッドを直接呼び出すのではなく、イベントを発生させる必要があります。 |
| CA1031 | [CA1031:一般的な例外の種類はキャッチしません](../code-quality/ca1031.md) | 汎用的な例外はキャッチしないでください。 より具体的な例外をキャッチするか、汎用的な例外を catch ブロックの最後のステートメントでスローし直します。 |
| CA1032 |[CA1032:標準例外コンストラクターを実装します](../code-quality/ca1032.md) | コンストラクターを完全に宣言していないと、例外を正しく処理するのが困難になります。 |
| CA1033 | [CA1033:インターフェイス メソッドは、子型によって呼び出し可能でなければなりません](../code-quality/ca1033.md) | シールされていない外部から参照できる型によって、パブリック インターフェイスを持つメソッドを明示的に実装しています。また、同じ名前を持つ外部から参照できる代替のメソッドがありません。 |
| CA1034 | [CA1034:入れ子にされた型を参照可能にすることはできません](../code-quality/ca1034.md) | 入れ子にされた型とは、別の型のスコープ内で宣言された型のことです。 入れ子にされた型は、包含型のプライベート実装の詳細をカプセル化するときに便利です。 このような用途なので、入れ子にされた型は外部から参照できないようにします。 |
| CA1036 | [CA1036:比較可能な型でメソッドをオーバーライドします](../code-quality/ca1036.md) |パブリック型またはプロテクト型で System.IComparable インターフェイスを実装しています。 これによって、Object.Equals はオーバーライドされません。また、"等しい"、"等しくない"、"未満"、"より大きい" を示す言語固有の演算子はオーバーロードされません。 |
| CA1040 |[CA1040:空のインターフェイスは使用しません](../code-quality/ca1040.md) | インターフェイスには、動作や使用のコントラクトを実現するメンバーが定義されます。 インターフェイスで示される機能は、継承の階層構造内に型が存在するかどうかにかかわらず、どの型からも適用できます。 型ではインターフェイスのメンバーに実装することで、インターフェイスが実装されます。 空のインターフェイスではメンバーが定義されません。そのため、実装できるコントラクトも定義されません。 |
| CA1041 | [CA1041:ObsoleteAttribute メッセージを指定します](../code-quality/ca1041.md) | 型またはメンバーが System.ObsoleteAttribute 属性を使用してマークされていますが、この属性で ObsoleteAttribute.Message プロパティが指定されていません。 ObsoleteAttribute でマークされている型またはメンバーをコンパイルすると、属性の Message プロパティが表示されます。 これによって、ユーザーは旧式の型またはメンバーに関する情報を知ることができます。 |
| CA1043 | [CA1043:インデクサーには整数または文字列引数を使用します](../code-quality/ca1043.md) | インデクサー (つまり、インデックスされたプロパティ) では、インデックスに整数型または文字列型を使用します。 一般に、このような型はデータ構造のインデックス作成に使用され、ライブラリの操作性も改善されます。 Object 型の使用は、デザイン時に特定の整数型または文字列型を指定できない場合に限定してください。 |
| CA1044 | [CA1044:プロパティを書き込み専用にすることはできません](../code-quality/ca1044.md) | 読み取り専用のプロパティは許容され、必要な場合もよくありますが、書き込み専用のプロパティを使用することはデザインのガイドラインで禁止されています。 これは、値を設定できてもその値を参照できず、セキュリティが確保されないためです。 また、読み取りアクセスがないと、共有オブジェクトのステータスを参照できないため、実用性が制限されます。 |
| CA1045 |[CA1045:型を参照によって渡しません](../code-quality/ca1045.md) | (out または ref を使用した) 型の参照渡しには、ポインターの使用経験、値の型と参照型の違いの理解、および複数の戻り値を持つメソッドの処理が必要です。 一般ユーザー向けに設計されたライブラリアーキテクト `out` は、ユーザーがまたはパラメーターをマスターに使用することを想定しないでください `ref` 。 |
| CA1046 | [CA1046:参照型で、演算子 equals をオーバーロードしないでください](../code-quality/ca1046.md) | 参照型の場合、等値演算子は既定の実装でほぼ問題がありません。 既定で、2 つの参照が等値と見なされるのは、同じオブジェクトを参照する場合のみです。 |
| CA1047 |[CA1047:シールド型の保護されたメンバーを宣言しません](../code-quality/ca1047.md) | 型でプロテクト メンバーを宣言するのは、継承する型からメンバーにアクセスまたはオーバーライドできるようにするためです。 定義により、シールされた型から継承することはできません。これは、シールされた型のプロテクト メソッドを呼び出すことができないということを意味します。 |
| CA1050 | [CA1050:名前空間で型を宣言します](../code-quality/ca1050.md) | 型を名前空間内で宣言するのは、名前が衝突しないようにするためと、関連する型をオブジェクト階層形式で編成するためです。 |
| CA1051 | [CA1051:参照可能なインスタンス フィールドを宣言しません](../code-quality/ca1051.md) | フィールドの主な用途は、実装の詳細にする必要があります。 フィールドは private または internal にし、プロパティによって公開するようにします。 |
| CA1052 | [CA1052:スタティック ホルダー型はシールドされていなければなりません](../code-quality/ca1052.md) | パブリック型またはプロテクト型に静的メンバーしかなく、sealed (C# リファレンス) (NotInheritable) 修飾子を使用して宣言されていません。 継承を意図していない型は、sealed 修飾子を使用してマークし、基本型として使用できないようにします。 |
| CA1053 |[CA1053:スタティック ホルダー型はコンストラクターを含むことはできません](../code-quality/ca1053.md) | パブリック型または入れ子になったパブリック型で、静的なメンバーのみが宣言されています。また、パブリックまたはプロテクトの既定のコンストラクターが含まれます。 静的メンバーの呼び出しに型のインスタンスは必要ないため、コンストラクターは不要です。 安全性とセキュリティを確保するために、文字列引数を使用して文字列オーバーロードで URI (Uniform Resource Identifier) オーバーロードを呼び出してください。 |
| CA1054 | [CA1054:URI パラメーターを文字列にすることはできません](../code-quality/ca1054.md) | メソッドで URI の文字列形式を使用する場合、対応するオーバーロードを宣言し、URI クラスのインスタンスを使用します。こうすることで、安全な方法でこのサービスを実現できます。 |
| CA1055 | [CA1055:URI 戻り値を文字列にすることはできません](../code-quality/ca1055.md) | この規則では、メソッドは URI を返すと想定されます。 URI の文字列表現は解析エラーやエンコーディング エラーが発生しやすく、セキュリティ上の脆弱性の原因となる場合があります。 System.Uri クラスを使用すると、安全な方法でこのサービスを実現できます。 |
| CA1056 | [CA1056:URI プロパティを文字列にすることはできません](../code-quality/ca1056.md) | この規則では、プロパティは URI (Uniform Resource Identifier) を表すと想定されます。 URI の文字列表現は解析エラーやエンコーディング エラーが発生しやすく、セキュリティ上の脆弱性の原因となる場合があります。 System.Uri クラスを使用すると、安全な方法でこのサービスを実現できます。 |
| CA1058 | [CA1058:型は、一定の基本型を拡張することはできません](../code-quality/ca1058.md) | 外部から参照可能な型では、特定の基本型が拡張されます。 別の型を使用してください。 |
| CA1060 | [CA1060: NativeMethods クラスへの P/Invoke の移動](../code-quality/ca1060.md) | System.Runtime.InteropServices.DllImportAttribute 属性でマークされているメソッドなどのプラットフォーム呼び出しメソッド、または [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)] で Declare キーワードを使用して定義されたメソッドが、アンマネージ コードにアクセスしています。 これらのメソッドは、NativeMethods、SafeNativeMethods、UnsafeNativeMethods の各クラスのいずれかに含まれる必要があります。 |
| CA1061 |[CA1061:基底クラス メソッドを非表示にしません](../code-quality/ca1061.md) | 派生メソッドのパラメーター シグネチャ内のある型が、基本メソッドのパラメーター シグネチャ内のそれに対応する型より弱く型指定されていることが、両者の唯一の相違点である場合、基本型内のメソッドが派生型内の同じ名前のメソッドによって隠ぺいされます。 |
| CA1062 | [CA1062:パブリック メソッドの引数の検証](../code-quality/ca1062.md) | 外部から参照可能なメソッドに渡されるすべての参照引数について、null かどうかをチェックする必要があります。 |
| CA1063 | [CA1063:IDisposable を正しく実装します](../code-quality/ca1063.md) | すべての IDisposable 型は、Dispose パターンを適切に実装する必要があります。 |
| CA1064 | [CA1064:例外は public として設定する必要があります](../code-quality/ca1064.md) | 内部例外は、その内部スコープ内でのみ認識されます。 内部スコープの外側にある例外は、基本例外を使用しなければキャッチできません。 内部例外が、、またはから継承されている場合、外部コードには、例外の処理 <xref:System.Exception> <xref:System.SystemException> 内容を <xref:System.ApplicationException> 認識するのに十分な情報がありません。 |
| CA1065 | [CA1065:予期しない場所に例外を発生させません](../code-quality/ca1065.md) | 例外をスローしないはずのメソッドが例外をスローします。 |
| CA1066 | [CA1066: Equals をオーバーライドする際に IEquatable を実装します](../code-quality/ca1066.md) | 値型は <xref:System.Object.Equals%2A> メソッドをオーバーライドしますが、はを実装しません <xref:System.IEquatable%601> 。 |
| CA1067 | [CA1067: IEquatable を実装するときに Equals をオーバーライドします](../code-quality/ca1067.md) | 型はを実装し <xref:System.IEquatable%601> ますが、メソッドをオーバーライドしません <xref:System.Object.Equals%2A> 。 |
| CA1068 | [CA1068:CancellationToken パラメーターは最後に指定する必要があります](../code-quality/ca1068.md) | メソッドに、最後のパラメーターではない CancellationToken パラメーターが指定されています。 |
| CA1069 | [CA1069: 列挙型には重複する値を指定できません](../code-quality/ca1069.md) | 列挙には、同じ定数値が明示的に割り当てられている複数のメンバーがあります。 |
| CA1070 | [CA1070: イベント フィールドを virtual として宣言しません](../code-quality/ca1070.md) | [フィールドに似たイベント](/dotnet/csharp/language-reference/language-specification/classes#field-like-events)が virtual として宣言されました。 |
| CA1200 | [CA1200:プレフィックスで cref タグを使用しません](../code-quality/ca1200.md) | XML ドキュメントタグの [cref](/dotnet/csharp/programming-guide/xmldoc/cref-attribute) 属性は、"コード参照" を意味します。 タグの内部テキストが、型、メソッド、プロパティなど、コード要素であることを指定します。 プレフィックスでタグを使用するのは避けて `cref` ください。これにより、コンパイラが参照を検証できなくなります。 また、Visual Studio 統合開発環境 (IDE: integrated development environment) が、リファクタリング中にこれらのシンボル参照を検索および更新できないようにします。 |
| CA1303 | [CA1303:ローカライズされるパラメーターとしてリテラルを渡さない](../code-quality/ca1303.md) | 外部から参照できるメソッドは、.NET コンストラクターまたはメソッドにパラメーターとして文字列リテラルを渡し、その文字列はローカライズ可能である必要があります。 |
| CA1304 | [CA1304:CultureInfo を指定します](../code-quality/ca1304.md) | System.Globalization.CultureInfo パラメーターを受け入れるオーバーロードを持つメンバーを呼び出しているメソッドまたはコンストラクターが、CultureInfo パラメーターを使用するオーバーロードを呼び出していません。 CultureInfo オブジェクトまたは System.IFormatProvider オブジェクトが指定されない場合、オーバーロードされたメンバーから提示された既定値は、すべてのロケールに効果が及ばない可能性があります。 |
| CA1305 | [CA1305:IFormatProvider を指定します](../code-quality/ca1305.md) | System.IFormatProvider パラメーターを受け入れるオーバーロードを持つメンバーを 1 つ以上呼び出しているメソッドまたはコンストラクターが、IFormatProvider パラメーターを使用するオーバーロードを呼び出していません。 System.Globalization.CultureInfo オブジェクトまたは IFormatProvider オブジェクトが指定されない場合、オーバーロードされたメンバーから提示された既定値は、すべてのロケールに効果が及ばない可能性があります。 |
| CA1307 | [CA1307:意味を明確にするための StringComparison の指定](../code-quality/ca1307.md) | 文字列比較演算で、StringComparison パラメーターを設定しないメソッド オーバーロードが使用されています。 |
| CA1308 |[CA1308:文字列を大文字に標準化します](../code-quality/ca1308.md) | 文字列は大文字に正規化する必要があります。 小文字への変換時に 1 つの小さい文字グループをラウンド トリップさせることができません。 |
| CA1309 | [CA1309:順序を示す StringComparison を使用します](../code-quality/ca1309.md) | 非言語的な文字列比較演算で、StringComparison パラメーターが Ordinal または OrdinalIgnoreCase に設定されていません。 パラメーターを StringComparison.Ordinal または StringComparison.OrdinalIgnoreCase に明示的に設定することによって、多くの場合、コードの速度、正確さ、および信頼性が向上します。 |
| CA1310 | [CA1310:正確な StringComparison の指定](../code-quality/ca1310.md) | 文字列比較操作では、StringComparison パラメーターを設定せず、カルチャ固有の文字列比較を既定で使用するメソッドオーバーロードを使用します。 |
| CA1401 | [CA1401: P/Invoke を表示できません](../code-quality/ca1401.md) | パブリック型のパブリック メソッドまたはプロテクト メソッドに、System.Runtime.InteropServices.DllImportAttribute 属性があります ([!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)] では Declare キーワードでも実装されます)。 このようなメソッドは公開しないでください。 |
| CA1417 | [CA1417: `OutAttribute` P/invoke に文字列パラメーターを使用しません](../code-quality/ca1417.md) | で値によって渡される文字列パラメーター `OutAttribute` は、文字列がインターン文字列である場合、ランタイムを不安定にする可能性があります。 |
| CA1501 | [CA1501:継承を使用しすぎないでください](../code-quality/ca1501.md) | 型が、その継承階層内の 5 つ以上深いレベルにあります。 深いレベルで入れ子にされた型の確認、理解、および保守は困難です。 |
| CA1502 | [CA1502:メソッドの実装を複雑にしすぎないでください](../code-quality/ca1502.md) | この規則は、線形独立のメソッド経路数を示す尺度で、条件分岐の数と複雑さによって決まります。 |
| CA1505 | [CA1505:メンテナンスできないコードを使用しないでください](../code-quality/ca1505.md) | 型またはメソッドの保守容易性指数が低い値です。 保守容易性指数の低い型またはメソッドは、保守が困難な可能性があるため、デザインの変更を検討することをお勧めします。 |
| CA1506 | [CA1506:クラス結合度を大きくしすぎないでください](../code-quality/ca1506.md) | この規則は、型またはメソッドに含まれる一意の型参照の数をカウントすることによって、クラス結合度を計測します。 |
| CA1507 | [CA1507:文字列の代わりに nameof を使用します](../code-quality/ca1507.md) | 文字列リテラルは、式を使用できる引数として使用され `nameof` ます。 |
| CA1508 | [CA1508:使用されない条件付きコードを回避する](../code-quality/ca1508.md) | メソッドには、常にまたは実行時に評価される条件付きコードがあり `true` `false` ます。 これにより、条件の分岐でコードが停止し `false` ます。 |
| CA1509 | [CA1509: コード メトリック構成ファイルのエントリが無効です](../code-quality/ca1509.md) | [CA1501](ca1501.md)、 [CA1502](ca1502.md)、 [CA1505](ca1505.md) 、 [CA1506](ca1506.md)などのコードメトリックス規則には、無効なエントリを持つという名前の構成ファイルが指定されてい `CodeMetricsConfig.txt` ます。 |
| CA1700 | [CA1700:列挙型値に 'Reserved' という名前を指定しません](../code-quality/ca1700.md) | この規則では、"reserved" を含む名前の列挙体のメンバーは、現在使用されていなくても、将来的なバージョンでは名前を変更するか削除されるプレースホルダーと想定しています。 メンバーの名前変更や削除は、互換性に影響する変更点です。 |
| CA1707 | [CA1707:識別子はアンダースコアを含むことはできません](../code-quality/ca1707.md) | 名前付け規則では、識別子名にアンダースコア (_) 文字を含めることができません。 この規則により、名前空間、型、メンバー、およびパラメーターがチェックされます。 |
| CA1708 | [CA1708:識別子は、大文字と小文字の区別以外にも相違していなければなりません](../code-quality/ca1708.md) | 名前空間、型、メンバー、およびパラメーターの各識別子は、大文字/小文字以外のみでは区別できません。共通言語ランタイムを対象とする言語は、大文字と小文字を区別する必要はないためです。 |
| CA1710 | [CA1710:識別子は、正しいサフィックスを含んでいなければなりません](../code-quality/ca1710.md) |名前付け規則によると、特定の基本型を拡張した型、特定のインターフェイスを実装する型、またはそのような型の派生型は、基本型やインターフェイスに関連するサフィックスを名前に付けます。 |
| CA1711 | [CA1711:識別子は、不適切なサフィックスを含むことはできません](../code-quality/ca1711.md) | 規則では、特定の基本型を拡張する型、特定のインターフェイスを実装する型、またはそのような型から派生した型の名前にのみ、固有の予約済みサフィックスを末尾に付けます。 その他の型名では、予約済みのサフィックスを使用しないでください。 |
| CA1712 | [CA1712:列挙型値を型名のプレフィックスにしません](../code-quality/ca1712.md) | 型情報は開発ツールで表示されるため、列挙型のメンバー名には、型名のプレフィックスを付けません。 |
| CA1713 | [CA1713:イベントは、before または after プレフィックスを含むことはできません](../code-quality/ca1713.md) | イベント名が "Before" または "After" で始まっています。 特定のシーケンスで発生する関連イベントに名前を付ける場合、現在時制または過去時制を使用して、アクション シーケンスの相対的な位置を示します。 |
| CA1714 | [CA1714:フラグ列挙型は、複数形の名前を含んでいなければなりません](../code-quality/ca1714.md) | パブリック列挙体に System.FlagsAttribute 属性があり、その名前の末尾に "s" がありません。 FlagsAttribute でマークされた型は複数形の名前を持ちます。これは、この属性が複数の値を指定できることを示すからです。 |
| CA1715 | [CA1715:識別子は正しいプレフィックスを含んでいなければなりません](../code-quality/ca1715.md) | 外部から参照できるインターフェイスの名前が大文字の "I" から始まっていません。 外部から参照できる型またはメソッドのジェネリック型パラメーターの名前が、大文字の "T" から始まっていません。 |
| CA1716 | [CA1716:識別子はキーワードと同一にすることはできません](../code-quality/ca1716.md) | 名前空間の名前または型の名前が、プログラミング言語で、予約済みのキーワードと一致します。 名前空間と型の識別子は、共通言語ランタイムを対象にする言語で定義されているキーワードと一致しないようにします。 |
| CA1717 | [CA1717:FlagsAttribute 列挙型のみが複数形の名前を含んでいなければなりません](../code-quality/ca1717.md) | 名前付け規則では、列挙体の複数形の名前は同時に複数の列挙値を指定できることを意味します。 |
| CA1720 |[CA1720:識別子には型名を含めないでください](../code-quality/ca1720.md) | 外部から参照できるメンバーのパラメーター名にデータ型の名前が含まれているか、外部から参照できるメンバーの名前に言語固有のデータ型の名前が含まれています。 |
| CA1721 | [CA1721:プロパティ名は get メソッドと同一にすることはできません](../code-quality/ca1721.md) |パブリック メンバーまたはプロテクト メンバーの名前が、"Get" から始まっているか、パブリック プロパティまたはプロテクト プロパティの名前と一致します。 "Get" メソッドとプロパティには、それぞれの機能を明確に区別する名前を指定しなければなりません。 |
| CA1724 | [CA1724:型名は名前空間と同一にすることはできません](../code-quality/ca1724.md) | 型名は、.NET 名前空間の名前と同じにすることはできません。 この規則に違反すると、ライブラリが使いづらくなります。 |
| CA1725 | [CA1725:パラメーター名は基本宣言と同一でなければなりません](../code-quality/ca1725.md) | オーバーライド階層のパラメーターに対する一貫性のある名前付けによって、メソッド オーバーライドの有用性が高まります。 派生メソッドのパラメーター名が基本宣言のパラメーター名と異なる場合、メソッドが基本メソッドのオーバーライドであるか、またはメソッドの新しいオーバーライドであるかについて混乱が生じる可能性があります。 |
| CA1801 | [CA1801:使用されていないパラメーターの確認](../code-quality/ca1801.md) | メソッドのシグネチャに、メソッドの本体で使用されていないパラメーターがあります。 |
| CA1802 |[CA1802:適切な場所にリテラルを使用します](../code-quality/ca1802.md) |フィールドが static および read-only ([!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)] では Shared および ReadOnly) として宣言され、コンパイル時に計算できる値によって初期化されています。 コンパイル時には対象のフィールドに割り当てられた値が計算できるであるため、宣言を const (const in) フィールドに変更して、実行時で [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)] はなくコンパイル時に値が計算されるようにします。 |
| CA1805 | [CA1805:不必要に初期化しない](../code-quality/ca1805.md) | .NET ランタイムは、コンストラクターを実行する前に、参照型のすべてのフィールドを既定値に初期化します。 ほとんどの場合、フィールドを既定値に明示的に初期化することは冗長であり、メンテナンスコストがかかり、パフォーマンスが低下する可能性があります (アセンブリサイズの増加など)。 |
| CA1806 | [CA1806:メソッドの結果を無視しない](../code-quality/ca1806.md) | 新しく作成されたオブジェクトが現在まで使用されていないか、新しい文字列を作成して返すメソッドが呼び出されて作成された新しい文字列が現在まで使用されていません。あるいは、COM または P/Invoke メソッドから返された HRESULT またはエラー コードが現在まで使用されていません。 |
| CA1810 | [CA1810:参照型の静的フィールドをインラインで初期化します](../code-quality/ca1810.md) | 型で明示的な静的コンストラクターを宣言すると、Just-In-Time (JIT) コンパイラが、静的コンストラクターが呼び出されたことを確認するために、型の静的メソッドと静的インスタンス コンストラクターに個別にチェックを追加します。 静的コンストラクターのチェックによってパフォーマンスが低下することがあります。 |
| CA1812 | [CA1812:インスタンス化されていない内部クラスを使用しません](../code-quality/ca1812.md) | アセンブリ レベルの型のインスタンスが、アセンブリ内のコードから作成されません。 |
| CA1813 | [CA1813:アンシールド属性を使用しません](../code-quality/ca1813.md) | .NET には、カスタム属性を取得するためのメソッドが用意されています。 既定では、これらのメソッドで属性の継承階層が検索されます。 属性をシールすると、継承階層の全体が検索されなくなるため、パフォーマンスが向上します。 |
| CA1814 | [CA1814:複数次元の配列ではなくジャグ配列を使用します](../code-quality/ca1814.md) | ジャグ配列とは、その要素も配列である配列です。 要素を構成する配列のサイズは異なってもよいため、データ セットによっては無駄な空間が少なくなります。 |
| CA1815 | [CA1815:equals および operator equals を値型でオーバーライドします](../code-quality/ca1815.md) | 値型の場合、Equals を継承した実装が Reflection ライブラリを使用して、すべてのフィールドの内容を比較します。 Reflection は計算コストが高いため、場合によってはすべてのフィールドで等値性を比較する必要はありません。 ユーザーがインスタンスの比較または並べ替えを行うことや、ハッシュ テーブル キーとしてインスタンスを使用することが予想される場合には、値型に Equals を実装する必要があります。 |
| CA1816 | [CA1816:GC.SuppressFinalize を正しく呼び出します](../code-quality/ca1816.md) | Dispose を実装するメソッドが GC.SuppressFinalize を呼び出していないか、Dispose を実装しないメソッドが GC.SuppressFinalize を呼び出しています。または、あるメソッドが GC.SuppressFinalize を呼び出し、this (Visual Basic では Me) 以外のオブジェクトを渡しています。 |
| CA1819 | [CA1819:プロパティは、配列を返すことはできません](../code-quality/ca1819.md) | プロパティが読み取り専用であっても、プロパティで返される配列は書き込みから保護されません。 配列の改ざんを防ぐには、プロパティで配列のコピーを返す必要があります。 一般に、このようなプロパティを呼び出すときのパフォーマンス低下は理解されません。 |
| CA1820 | [CA1820:文字列の長さを使用して空の文字列をテストします](../code-quality/ca1820.md) | String.Length プロパティまたは String.IsNullOrEmpty メソッドを使用して文字列を比較する方法は、Equals を使用する場合よりもはるかに高速です。 |
| CA1821 | [CA1821:空のファイナライザーを削除します](../code-quality/ca1821.md) | オブジェクトの有効期間の追跡に関連するパフォーマンス オーバーヘッドが増大するため、ファイナライザーは可能な限り使用しないでください。 空のファイナライザーを使用すると、オーバーヘッドが増大するだけで何の利点もありません。 |
| CA1822 |[CA1822:メンバーを static に設定します](../code-quality/ca1822.md) | インスタンス データにアクセスしない、またはインスタンス メソッドを呼び出さないメンバーは、静的 ([!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)] では共有) としてマークできます。 メソッドを静的としてマークすると、コンパイラはこれらのメンバーに対する非仮想呼び出しサイトを出力します。 パフォーマンス重視のコードでは、これにより大きくパフォーマンスを向上できます。 |
| CA1823 | [CA1823:使用されていないプライベート フィールドを使用しません](../code-quality/ca1823.md) | アセンブリ内でアクセスされていないと思われるプライベート フィールドが検出されました。 |
| CA1824 |[CA1824:アセンブリを NeutralResourcesLanguageAttribute に設定します](../code-quality/ca1824.md) | NeutralResourcesLanguage 属性は、アセンブリのニュートラルカルチャのリソースを表示するために使用された言語をリソースマネージャーに通知します。 これにより、読み込んだ最初のリソースに対する検索のパフォーマンスが向上し、ワーキング セットを縮小できます。 |
| CA1825 |[CA1825:長さ 0 の配列割り当てを回避します](../code-quality/ca1825.md) | 長さ0の配列を初期化すると、不要なメモリ割り当てにつながります。 代わりに、を呼び出すことによって、静的に割り当てられた空の配列インスタンスを使用し <xref:System.Array.Empty%2A?displayProperty=nameWithType> ます。 メモリ割り当ては、このメソッドのすべての呼び出しで共有されます。 |
| CA1826 |[CA1826:Linq の列挙可能なメソッドの代わりにプロパティを使用します](../code-quality/ca1826.md) | <xref:System.Linq.Enumerable> LINQ メソッドが、同等のより効率的なプロパティをサポートする型で使用されました。 |
| CA1827 |[CA1827:Any が使用できる場合は Count/LongCount を使用しません](../code-quality/ca1827.md) | <xref:System.Linq.Enumerable.Count%2A> または <xref:System.Linq.Enumerable.LongCount%2A> メソッドが使用されました <xref:System.Linq.Enumerable.Any%2A> 。メソッドの方が効率的です。 |
| CA1828 |[CA1828:AnyAsync が使用できる場合は CountAsync/LongCountAsync を使用しません](../code-quality/ca1828.md) | <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.CountAsync%2A> または <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.LongCountAsync%2A> メソッドが使用されました <xref:Microsoft.EntityFrameworkCore.EntityFrameworkQueryableExtensions.AnyAsync%2A> 。メソッドの方が効率的です。 |
| CA1829 |[CA1829:Enumerable. Count メソッドではなく Length/Count プロパティを使用します](../code-quality/ca1829.md) | <xref:System.Linq.Enumerable.Count%2A> LINQ メソッドは、同等の、より効率的なまたはプロパティをサポートする型で使用されていま `Length` `Count` した。 |
| CA1830 |[CA1830:StringBuilder の厳密に型指定された Append および Insert メソッドのオーバーロードをお勧めします](../code-quality/ca1830.md) | <xref:System.Text.StringBuilder.Append%2A> と <xref:System.Text.StringBuilder.Insert%2A> は、を超える複数の型のオーバーロードを提供し <xref:System.String> ます。  可能であれば、ToString () と文字列ベースのオーバーロードを使用して、厳密に型指定されたオーバーロードを優先します。 |
| CA1831 |[CA1831: 該当する場合、文字列に範囲ベースのインデクサーの代わりに AsSpan を使用します](../code-quality/ca1831.md) | 文字列に対して範囲インデクサーを使用し、その値を暗黙的に ReadOnlySpan char 型に割り当てると、 &lt; &gt; の代わりにメソッドが <xref:System.String.Substring%2A?#System_String_Substring_System_Int32_System_Int32_> 使用され、 <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> 文字列の要求された部分のコピーが生成されます。 |
| CA1832 |[CA1832: 配列の ReadOnlySpan または ReadOnlyMemory 部分を取得するために、範囲ベースのインデクサーの代わりに AsSpan または AsMemory を使用します](../code-quality/ca1832.md) | 配列に対して範囲インデクサーを使用し、その値を型または型に暗黙的に割り当てると、 <xref:System.ReadOnlySpan%601> <xref:System.ReadOnlyMemory%601> の代わりにメソッドが <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> 使用され <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> ます。これにより、配列の要求された部分のコピーが生成されます。 |
| CA1833 |[CA1833: 配列の Span または Memory 部分を取得するために、範囲ベースのインデクサーの代わりに AsSpan または AsMemory を使用します](../code-quality/ca1833.md) | 配列に対して範囲インデクサーを使用し、その値を型または型に暗黙的に割り当てると、 <xref:System.Span%601> <xref:System.Memory%601> の代わりにメソッドが <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray%2A> 使用され <xref:System.Span%601.Slice%2A?#System_Span_1_Slice_System_Int32_System_Int32_> ます。これにより、配列の要求された部分のコピーが生成されます。 |
| CA1834 |[CA1834: 1 つの文字列に対して StringBuilder (char) を使用します。](../code-quality/ca1834.md) | <xref:System.Text.StringBuilder> には `Append` 、引数としてを受け取るオーバーロードがあり `char` ます。 `char`パフォーマンス上の理由から、オーバーロードの呼び出しを優先します。 |
| CA1835 |[CA1835: ' ReadAsync ' と ' WriteAsync ' に対して ' Memory' に基づくオーバーロードを優先します](../code-quality/ca1835.md) | ' Stream ' には、最初の引数として ' Memory byte ' を受け取る ' ReadAsync ' オーバーロード &lt; &gt; と、 &lt; &gt; 1 番目の引数として ' ReadOnlyMemory Byte ' を受け取る ' WriteAsync ' オーバーロードがあります。 より効率的なメモリベースのオーバーロードを呼び出すことをお勧めします。 |
| CA1836 |[CA1836: `IsEmpty` `Count` 使用可能な場合は優先します。](../code-quality/ca1836.md) | `IsEmpty` `Count` `Length` <xref:System.Linq.Enumerable.Count%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> <xref:System.Linq.Enumerable.LongCount%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%29> オブジェクトに項目が含まれているかどうかを判断するために、、、またはよりも効率的なプロパティを優先します。 |
| CA1837 | [CA1837: `Environment.ProcessId` の代わりにを使用します。 `Process.GetCurrentProcess().Id`](../code-quality/ca1837.md) | `Environment.ProcessId` はより単純で高速です `Process.GetCurrentProcess().Id` 。 |
| CA1838 | [CA1838: `StringBuilder` P/invoke のパラメーターを使用しない](../code-quality/ca1838.md) | ' StringBuilder ' のマーシャリングでは、常にネイティブバッファーコピーが作成されるため、1つのマーシャリング操作に複数の割り当てが行われます。 |
| CA2000 | [CA2000:スコープを失う前にオブジェクトを破棄](../code-quality/ca2000.md) | 例外的なイベントが発生するとオブジェクトのファイナライザーを実行できないため、オブジェクトに対するすべての参照がスコープ外になる前に、オブジェクトを明示的に破棄する必要があります。 |
| CA2002 |[CA2002:弱い ID を伴うオブジェクト上でロックしません](../code-quality/ca2002.md) |アプリケーション ドメインの境界を越えてオブジェクトに直接アクセスできる場合、そのオブジェクトの ID は不十分と表現されます。 スレッドで ID が不十分なオブジェクトをロックしようとすると、ブロックされることがあります。たとえば、異なるアプリケーション ドメインの別スレッドで、既に同じオブジェクトがロックされている場合です。 |
| CA2007 | [CA2007:タスクを直接待機しないでください](ca2007.md) | 非同期メソッドは[awaits](/dotnet/csharp/language-reference/keywords/await) 、を <xref:System.Threading.Tasks.Task> 直接待機します。 非同期メソッドがを直接待機する場合 <xref:System.Threading.Tasks.Task> 、継続はタスクを作成したのと同じスレッドで発生します。 この動作は、パフォーマンスに関してはコストが高く、UI スレッドでデッドロックが発生する可能性があります。 を呼び出して <xref:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)?displayProperty=nameWithType> 、継続の意図を知らせることを検討してください。 |
| CA2008 | [CA2008:TaskScheduler を渡さずにタスクを作成しない](ca2008.md) | タスクの作成または継続操作で、パラメーターを指定しないメソッドオーバーロードが使用さ <xref:System.Threading.Tasks.TaskScheduler> れています。 |
| CA2009 | [CA2009: ImmutableCollection 値で ToImmutableCollection を呼び出さないでください](ca2009.md) | `ToImmutable` メソッドは、名前空間から変更できないコレクションで不必要に呼び出されました <xref:System.Collections.Immutable> 。 |
| CA2011 | [CA2011: セッター内でプロパティを割り当てません](ca2011.md) | プロパティに、独自の [set アクセサー](/dotnet/csharp/programming-guide/classes-and-structs/using-properties#the-set-accessor)内で誤って値が割り当てられました。 |
| CA2012 | [CA2012: ValueTask を正しく使用する必要があります](ca2012.md) | メンバーの呼び出しから返される ValueTasks は、直接待機することを意図しています。  ValueTask を複数回使用しようとするか、完了する前に1つの結果に直接アクセスすると、例外または破損が発生する可能性があります。  このような ValueTask を無視すると、機能的なバグが示され、パフォーマンスが低下する可能性があります。 |
| CA2013 | [CA2013: 値の型と共に ReferenceEquals を使用しないでください](ca2013.md) | を使用して値を比較するときに <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> 、obja と Obja が値型の場合、メソッドに渡される前にボックス化され <xref:System.Object.ReferenceEquals%2A> ます。 これは、objA と Obja の両方が値型の同じインスタンスを表している場合でも、 <xref:System.Object.ReferenceEquals%2A> メソッドは false を返すことを意味します。 |
| CA2014 | [CA2014: ループで stackalloc を使用しないでください。](ca2014.md) | Stackalloc によって割り当てられるスタック領域は、現在のメソッドの呼び出しの最後にのみ解放されます。  ループでこれを使用すると、スタックが無制限に増加し、最終的にスタックオーバーフロー状態になる可能性があります。 |
| CA2015 | [CA2015: MemoryManager T から派生した型に対してファイナライザーを定義しません &lt;&gt;](ca2015.md) | から派生した型にファイナライザーを追加する <xref:System.Buffers.MemoryManager%601> と、メモリがによってまだ使用されている間は解放される可能性があり <xref:System.Span%601> ます。 |
| CA2016 | [CA2016:CancellationToken パラメーターを 1 つのメソッドに転送する](ca2016.md) | 操作の `CancellationToken` キャンセル通知が適切に反映されるように、またはトークンを意図的に伝達し `CancellationToken.None` ないことを示すために明示的に渡すメソッドにパラメーターを転送します。 |
| CA2100 | [CA2100:SQL クエリのセキュリティ脆弱性を確認](../code-quality/ca2100.md) | メソッドに渡された文字列引数から構築された文字列を使用して System.Data.IDbCommand.CommandText プロパティが設定されています。 この規則では、文字列引数にユーザー入力が含まれていることが想定されています。 ユーザー入力から構築された SQL コマンド文字列には、SQL 注入攻撃に対する脆弱性があります。 |
| CA2101 |[CA2101: P/Invoke 文字列引数のマーシャリングを指定します。](../code-quality/ca2101.md) | プラットフォーム呼び出しメンバーが、部分信頼の呼び出し元を許可し、文字列パラメーターを持ち、さらにその文字列を明示的にマーシャリングしていません。 これはセキュリティ上の脆弱性となる可能性があります。 |
| CA2109 | [CA2109:表示するイベント ハンドラーを確認します](../code-quality/ca2109.md) | パブリックまたはプロテクトのイベント ハンドラー メソッドが検出されました。 イベント ハンドラー メソッドは、絶対に必要な場合を除き公開しないでください。 |
| CA2119 | [CA2119:プライベート インターフェイスを満たすメソッドをシールします](../code-quality/ca2119.md) | 継承可能なパブリック型により、internal ([!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)] では Friend) インターフェイスのオーバーライド可能なメソッド実装が提供されます。 この規則違反を修正するには、アセンブリの外側でメソッドがオーバーライドされないようにします。 |
| CA2153 |[CA2153: 破損状態例外の処理を回避する](../code-quality/ca2153.md) | 破損状態の例外 (CSEs) は、メモリの破損がプロセス内に存在することを示します。 プロセスをクラッシュさせるのではなくこれらの例外をキャッチすることは、攻撃者が破損したメモリ領域にセキュリティ上の弱点を見出すことができた場合に、セキュリティ上の脆弱性となる可能性があります。 |
| CA2200 | [CA2200:スタック詳細を保持するために再度スローします](../code-quality/ca2200.md) | 例外が再スローされ、その例外が throw ステートメントで明示的に指定されています。 throw ステートメントで例外を指定して例外が再スローされると、例外をスローした元のメソッドと現在のメソッドの間で呼び出されたメソッドの一覧は失われます。 |
| CA2201 | [CA2201:予約された例外の種類を発生させません](../code-quality/ca2201.md) | これにより、元のエラーの検出およびデバッグが困難になります。 |
| CA2207 | [CA2207:値型のスタティック フィールドのインラインを初期化します](../code-quality/ca2207.md) | 値型で明示的な静的コンストラクターを宣言しています。 この規則違反を修正するには、静的データが宣言されたとき、および静的コンストラクターを削除するときに、静的データをすべて初期化します。 |
| CA2208 |[CA2208:引数の例外を正しくインスタンス化します](../code-quality/ca2208.md) | ArgumentException またはそのクラスから派生した例外の種類の既定 (パラメーターなし) のコンストラクターに対して呼び出しが行われたか、ArgumentException またはそのクラスから派生した例外の種類のパラメーター付きのコンストラクターに不適切な文字列型の引数が渡されました。 |
| CA2211 |[CA2211:非定数フィールドは表示されません](../code-quality/ca2211.md) | 定数でも読み取り専用でもない静的フィールドは、スレッド セーフではありません。 このようなフィールドへのアクセスは、慎重に制御してください。また、クラス オブジェクトへのアクセスを同期するには、高度なプログラミング技術が必要です。 |
| CA2213 | [CA2213:破棄可能なフィールドは破棄されなければなりません](../code-quality/ca2213.md) | System.IDisposable を実装する型が、IDisposable も実装する型を持つフィールドを宣言しています。 このフィールドの Dispose メソッドは、宣言している型の Dispose メソッドから呼び出されていません。 |
| CA2214 | [CA2214:コンストラクターのオーバーライド可能なメソッドを呼び出しません](../code-quality/ca2214.md) | コンストラクターから仮想メソッドを呼び出すと、メソッドを呼び出すインスタンスのコンストラクターが実行されないことがあります。 |
| CA2215 | [CA2215:Dispose メソッドが基底クラスの Dispose を呼び出す必要があります](../code-quality/ca2215.md) | 型が、破棄できる型から継承している場合、使用している Dispose メソッド内から基本型の Dispose メソッドを呼び出す必要があります。 |
| CA2216 |[CA2216:破棄可能な型はファイナライザーを宣言しなければなりません](../code-quality/ca2216.md) | System.IDisposable を実装し、アンマネージ リソースの使用を提案するフィールドが含まれる型が、Object.Finalize で記述されているようにファイナライザーを実装していません。 |
| CA2217 | [CA2217:列挙型を FlagsAttribute に設定しません](../code-quality/ca2217.md) |外部から参照できる列挙型が FlagsAttribute でマークされ、その列挙型に、2 の累乗でもなく、その列挙型で定義されている他の値の組み合わせでもない値が 1 つ以上含まれています。 |
| CA2219 | [CA2219:exception 句に例外を発生させないでください](../code-quality/ca2219.md) | finally 句または fault 句で例外が発生すると、アクティブな例外が新しい例外によって隠されます。 filter 句で例外が発生すると、ランタイムがその例外を暗黙的にキャッチします。 これにより、元のエラーの検出およびデバッグが困難になります。 |
| CA2225 | [CA2225:演算子オーバーロードには名前付けされた代替が存在します](../code-quality/ca2225.md) |演算子のオーバーロードが検出され、予想される名前の代替メソッドが検出されませんでした。 名前付きの代替メンバーによって、演算子と同じ機能へアクセスできるようになります。また、演算子のオーバーロードをサポートしていない言語でプログラミングする場合でも、その代替メンバーを使用できます。 |
| CA2226 | [CA2226:演算子は対称型オーバーロードを含まなければなりません](../code-quality/ca2226.md) | 型で等値演算子または非等値演算子を実装し、逆の働きをする演算子を実装していません。 |
| CA2227 |[CA2227:Collection プロパティは読み取り専用でなければなりません](../code-quality/ca2227.md) |書き込み可能なコレクション プロパティにより、ユーザーはコレクションを異なるコレクションで置換できます。 読み取り専用プロパティは、コレクションを置換できないようにしますが、個別のメンバーが設定されることは回避できません。 |
| CA2229 | [CA2229:シリアル化コンストラクターを実装します](../code-quality/ca2229.md) | この規則違反を修正するには、シリアル化コンストラクターを実装します。 シールされたクラスの場合、コンストラクターをプライベートにするか、プロテクトにします。 |
| CA2231 | [CA2231:ValueType.Equals のオーバーライドで、演算子 equals をオーバーロードします](../code-quality/ca2231.md) | 値型は、Object.Equals をオーバーライドしていますが、等値演算子を実装していません。 |
| CA2234 | [CA2234:文字列の代わりに System.Uri オブジェクトを渡します](../code-quality/ca2234.md) | "uri"、"URI"、"urn"、"URN"、"url"、または "URL" という名前を持つ文字列パラメーターが指定されているメソッドに対して、呼び出しが行われました。 そのメソッドの型宣言に対応するメソッドのオーバーロードが存在し、それに対して System.Uri パラメーターが指定されています。 |
| CA2235 | [CA2235:すべてのシリアル化不可能なフィールドを設定します](../code-quality/ca2235.md) | シリアル化できない型のインスタンス フィールドが、シリアル化できる型で宣言されています。 |
| CA2237 | [CA2237:ISerializable 型を SerializableAttribute に設定します](../code-quality/ca2237.md) | 型が共通言語ランタイムでシリアル化できると認識されるようにするには、型を SerializableAttribute 属性でマークする必要があります。型が ISerializable インターフェイスの実装を通じてカスタムのシリアル化ルーチンを使用している場合でも、マークする必要があります。 |
| CA2241 | [CA2241:書式設定メソッドに正しい引数を提供](../code-quality/ca2241.md) | System.String.Format に渡される引数 format に、各オブジェクトの引数に対応する書式指定項目が含まれていません (その逆も考えられます)。 |
| CA2242 |[CA2242:NaN に対して正しくテストします](../code-quality/ca2242.md) | この式が Single.Nan または Double.Nan に対して値をテストしています。 値をテストするには、Single.IsNan(Single) または Double.IsNan(Double) を使用します。 |
| CA2243 |[CA2243:属性文字列リテラルは、正しく解析する必要があります](../code-quality/ca2243.md) | 属性のリテラル文字列パラメーターが URL、GUID、またはバージョンとして正しく解析されません。 |
| CA2244 | [CA2244: インデックス付き要素の初期化を重複させません](../code-quality/ca2244.md) | オブジェクト初期化子に、同じ定数インデックスを持つ複数のインデックス付き要素初期化子があります。 最後の初期化子以外はすべて冗長です。 |
| CA2245 | [CA2245: プロパティをそれ自体に割り当てません](../code-quality/ca2245.md) | プロパティが誤ってそれ自体に割り当てられました。 |
| CA2246 | [CA2246: 同じステートメントにシンボルとそのメンバーを割り当てません](../code-quality/ca2246.md) | 同じステートメントで、シンボルとそのメンバー (フィールドまたはプロパティ) を割り当てることは推奨されていません。 メンバーアクセスが、割り当ての前にシンボルの古い値を使用するのか、またはこのステートメントの代入の新しい値を使用するのかは明確ではありません。 |
| CA2247 | [CA2247: task Source コンストラクターに渡される引数は task Ationoptions 列挙型ではなく、Task Options 列挙型にする必要があります。](../code-quality/ca2247.md) | Taskて Source には、タスクに格納されているオブジェクトの状態を取得する、基になるタスクとコンストラクターを制御する Task/Options を受け取るコンストラクターがあります。  Task/options ではなく Task続行 Ationoptions を渡した場合、オプションが状態として扱われます。 |
| CA2248 | [CA2248: 正しい enum 引数を Enum.HasFlag に指定します](../code-quality/ca2248.md) | メソッド呼び出しの引数として渡された列挙型 `HasFlag` が、呼び出し元の列挙型と異なります。 |
| CA2249 | [CA2249:String.IndexOf の代わりに String.Contains を使用することを検討します](../code-quality/ca2249.md) | `string.IndexOf`部分文字列の有無を確認するために結果を使用するの呼び出しは、で置き換えることができ `string.Contains` ます。 |
| CA2300 | [CA2300:安全ではないデシリアライザー BinaryFormatter を使用しないでください](../code-quality/ca2300.md) | 安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。 |
| CA2301 | [CA2301:最初に BinaryFormatter.Binder を設定しないで BinaryFormatter.Deserialize を呼び出さないでください](../code-quality/ca2301.md) | 安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。 |
| CA2302 | [CA2302:BinaryFormatter.Deserialize を呼び出す前に BinaryFormatter.Binder が設定されていることを確認します](../code-quality/ca2302.md) | 安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。 |
| CA2305 | [CA2305:安全ではないデシリアライザー LosFormatter を使用しないでください](../code-quality/ca2305.md) | 安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。 |
| CA2310 | [CA2310:安全ではないデシリアライザー NetDataContractSerializer を使用しないでください](../code-quality/ca2310.md) | 安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。 |
| CA2311 | [CA2311:最初に NetDataContractSerializer.Binder を設定しないで逆シリアル化しないでください](../code-quality/ca2311.md) | 安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。 |
| CA2312 | [CA2312:NetDataContractSerializer.Binder を設定してから逆シリアル化してください](../code-quality/ca2312.md) | 安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。 |
| CA2315 | [CA2315:安全ではないデシリアライザー ObjectStateFormatter を使用しないでください](../code-quality/ca2315.md) | 安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。 |
| CA2321 | [CA2321:SimpleTypeResolver を使って JavaScriptSerializer で逆シリアル化しないでください](../code-quality/ca2321.md) | 安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。 |
| CA2322 | [CA2322:逆シリアル化する前に JavaScriptSerializer が SimpleTypeResolver によって初期化されていないことを確認してください](../code-quality/ca2322.md) | 安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。 |
| CA2326 | [CA2326: None 以外の TypeNameHandling 値は使用しないでください](../code-quality/ca2326.md) | 安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。 |
| CA2327 | [CA2327: 安全でない JsonSerializerSettings を使用しないでください](../code-quality/ca2327.md) | 安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。 |
| CA2328 | [CA2328: JsonSerializerSettings が安全であることを確認してください](../code-quality/ca2328.md) | 安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。 |
| CA2329 | [CA2329: セキュリティで保護されていない構成が JsonSerializer で使用されている場合は、逆シリアル化を行わないでください](../code-quality/ca2329.md) | 安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。 |
| CA2330 | [CA2330: 逆シリアル化の際に、JsonSerializer の構成は確実にセキュリティで保護してください](../code-quality/ca2330.md) | 安全でないデシリアライザーは、信頼できないデータを逆シリアル化するときに脆弱です。 攻撃者は、悪意のある副作用を持つオブジェクトを挿入するために、シリアル化されたデータを変更し、予期しない型を含めることができます。 |
| CA2350 | [CA2350:DataTable.ReadXml() の入力が信頼されていることを確認してください](ca2350.md) | 信頼されていない入力を使用してを逆シリアル化すると <xref:System.Data.DataTable> 、攻撃者は悪意のある入力を行ってサービス拒否攻撃を仕掛けることができます。 不明なリモートコード実行の脆弱性がある可能性があります。 |
| CA2351 | [CA2351:DataSet.ReadXml() の入力が信頼されていることを確認してください](ca2351.md) | 信頼されていない入力を使用してを逆シリアル化すると <xref:System.Data.DataSet> 、攻撃者は悪意のある入力を行ってサービス拒否攻撃を仕掛けることができます。 不明なリモートコード実行の脆弱性がある可能性があります。 |
| CA2352 | [CA2352: 安全でないデータセットまたはシリアル化可能な型の DataTable は、リモートのコード実行攻撃に対して脆弱になる可能性があります](ca2352.md) | でマークされたクラスまたは構造体に、 <xref:System.SerializableAttribute> フィールドまたはプロパティが含まれてい <xref:System.Data.DataSet> ますが、が <xref:System.Data.DataTable> ありません <xref:System.CodeDom.Compiler.GeneratedCodeAttribute> 。 |
| CA2353 | [CA2353: Unsafe データセットまたはシリアル化可能な型の DataTable](ca2353.md) | XML シリアル化属性またはデータコントラクト属性でマークされたクラスまたは構造体に、フィールドまたはプロパティが含まれてい <xref:System.Data.DataSet> <xref:System.Data.DataTable> ます。 |
| CA2354 | [CA2354:逆シリアル化されたオブジェクト グラフの安全でない DataSet または DataTable は、リモート コード実行攻撃に対して脆弱になる可能性があります](ca2354.md) | シリアル化されたを使用して逆シリアル <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> 化すると、キャストされた型のオブジェクトグラフにまたはを含めることができ <xref:System.Data.DataSet> <xref:System.Data.DataTable> ます。 |
| CA2355 | [CA2355:逆シリアル化されたオブジェクト グラフの安全でない DataSet または DataTable](ca2355.md) | キャストまたは指定された型のオブジェクトグラフがまたはを含むことができる場合、逆シリアル化し <xref:System.Data.DataSet> <xref:System.Data.DataTable> ます。 |
| CA2356 | [CA2356: web 逆シリアル化されたオブジェクトグラフ内の安全でないデータセットまたは DataTable](ca2356.md) | またはを持つメソッドには、 <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> またはを参照できるパラメーターがあり <xref:System.Data.DataSet> <xref:System.Data.DataTable> ます。 |
| CA2361 | [CA2361: データセットを含む自動生成されたクラスを確認します。 ReadXml () は信頼されていないデータでは使用されません](ca2361.md) | 信頼されていない入力を使用してを逆シリアル化すると <xref:System.Data.DataSet> 、攻撃者は悪意のある入力を行ってサービス拒否攻撃を仕掛けることができます。 不明なリモートコード実行の脆弱性がある可能性があります。 |
| CA2362 | [CA2362: 自動生成されたシリアル化可能な型の Unsafe データセットまたは DataTable は、リモートのコード実行攻撃に対して脆弱になる可能性があります](ca2362.md) | で信頼できない入力を逆シリアル <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> 化し、逆シリアル化されたオブジェクトグラフにまたはが含まれている場合 <xref:System.Data.DataSet> <xref:System.Data.DataTable> 、攻撃者は悪意のあるペイロードを使用してリモートのコード実行攻撃を行うことができます。 |
| CA3001 | [CA3001:SQL インジェクションの脆弱性のコード レビュー](../code-quality/ca3001.md) | 信頼されていない入力と SQL コマンドを使用する場合は、SQL インジェクション攻撃に注意してください。 SQL インジェクション攻撃によって、悪意のある SQL コマンドを実行し、アプリケーションのセキュリティと整合性を損なう可能性があります。 |
| CA3002 | [CA3002:XSS の脆弱性のコード レビュー](../code-quality/ca3002.md) | Web 要求から信頼されていない入力を処理する場合は、クロスサイトスクリプティング (XSS) 攻撃に注意する必要があります。 XSS 攻撃によって、信頼できない入力が未加工の HTML 出力に挿入され、攻撃者が悪意のあるスクリプトを実行したり、web ページのコンテンツを改ざんしたりする可能性があります。 |
| CA3003 | [CA3003:ファイル パス インジェクションの脆弱性のコード レビュー](../code-quality/ca3003.md) | Web 要求から信頼されていない入力を使用する場合は、ファイルへのパスを指定するときにユーザーが制御する入力を使用することに注意してください。 |
| CA3004 | [CA3004:情報漏えいの脆弱性のコード レビュー](../code-quality/ca3004.md) | 例外情報を公開すると、攻撃者がアプリケーションの内部を調べて、攻撃者が他の脆弱性を悪用するのを支援することができます。 |
| CA3006 | [CA3006:プロセス コマンド インジェクションの脆弱性のコード レビュー](../code-quality/ca3006.md) | 信頼されていない入力を使用する場合は、コマンドインジェクション攻撃に注意してください。 コマンドインジェクション攻撃は、基になるオペレーティングシステムで悪意のあるコマンドを実行し、サーバーのセキュリティと整合性を損なう可能性があります。 |
| CA3007 | [CA3007:オープン リダイレクトの脆弱性のコード レビュー](../code-quality/ca3007.md) | 信頼されていない入力を使用する場合は、開いているリダイレクトの脆弱性に注意してください。 攻撃者は、開いているリダイレクトの脆弱性を悪用して、web サイトを使用して正当な URL を表示することができますが、悪意のあるユーザーをフィッシングやその他の悪意のある web ページにリダイレクトする可能性があります。 |
| CA3008 | [CA3008:XPath インジェクションの脆弱性のコード レビュー](../code-quality/ca3008.md) | 信頼されていない入力を使用する場合は、XPath インジェクション攻撃に注意してください。 信頼されていない入力を使用して XPath クエリを作成すると、攻撃者がクエリを故意に操作して意図しない結果を返すことがあり、場合によってはクエリ対象の XML の内容を開示できます。 |
| CA3009 | [CA3009:XML インジェクションの脆弱性のコード レビュー](../code-quality/ca3009.md) | 信頼されていない入力を使用する場合は、XML インジェクション攻撃に注意してください。 |
| CA3010 | [CA3010:XAML インジェクションの脆弱性のコード レビュー](../code-quality/ca3010.md) | 信頼されていない入力を扱う場合は、XAML インジェクション攻撃に注意してください。 XAML は、オブジェクトのインスタンス化と実行を直接表すマークアップ言語です。 つまり、XAML で作成された要素は、システムリソース (ネットワークアクセスやファイルシステム IO など) とやり取りできます。 |
| CA3011 | [CA3011:DLL インジェクションの脆弱性のコード レビュー](../code-quality/ca3011.md) | 信頼できない入力を使用する場合は、信頼されていないコードを読み込むことに注意してください。 Web アプリケーションが信頼されていないコードを読み込む場合、攻撃者は悪意のある Dll をプロセスに挿入して、悪意のあるコードを実行できる可能性があります。 |
| CA3012 | [CA3012:RegEx インジェクションの脆弱性のコード レビュー](../code-quality/ca3012.md) | 信頼できない入力を使用する場合は、regex インジェクション攻撃に注意してください。 攻撃者は、regex インジェクションを使用して正規表現を故意に変更したり、regex が意図しない結果に一致するようにしたり、regex が過剰な CPU を消費してサービス拒否攻撃を受ける可能性があります。 |
| CA3061 | [CA3061:URL でスキーマを追加しません](../code-quality/ca3061.md) | 危険な外部参照が発生する可能性があるため、Add メソッドの unsafe オーバーロードは使用しないでください。 |
| CA3075 | [CA3075:安全ではない DTD の処理](../code-quality/ca3075.md) | 安全ではない DTDProcessing インスタンスを使用する場合、または外部エンティティ ソースを参照する場合、パーサーは信頼されていない入力を受け入れ、攻撃者に機密情報を漏えいしてしまう可能性があります。 |
| CA3076 | [CA3076:安全ではない XSLT スクリプトの実行](../code-quality/ca3076.md) | .NET アプリケーションで XSLT (拡張可能なスタイルシート言語変換) を実行する場合、プロセッサは、攻撃者に機密情報を開示する可能性がある信頼できない URI 参照を解決し、サービス拒否攻撃やクロスサイト攻撃を安全で可能性があります。 |
| CA3077 | [CA3077:API のデザイン、XML ドキュメント、および XML テキスト リーダーでの安全ではない処理](../code-quality/ca3077.md) | XMLDocument と XMLTextReader から派生する API をデザインする場合、DtdProcessing にご注意ください。 外部エンティティ ソースを参照または解決したり、XML に安全ではない値を設定したりする場合に、安全ではない DTDProcessing インスタンスを使用すると、情報漏えいにつながる可能性があります。 |
| CA3147 | [CA3147:ValidateAntiForgeryToken で動詞ハンドラーをマークします](../code-quality/ca3147.md) | ASP.NET MVC コントローラーを設計するときは、クロスサイトリクエストの偽造攻撃に注意してください。 クロスサイト要求偽造攻撃は、認証されたユーザーから ASP.NET MVC コントローラーに悪意のある要求を送信できます。 |
| CA5350 | [CA5350:脆弱な暗号アルゴリズムを使用しないでください](../code-quality/ca5350.md) | 現在、さまざまな理由で弱い暗号化アルゴリズムとハッシュ関数が使用されていますが、保護対象のデータの機密性や整合性を保証するためにこれらを使用しないでください。 このルールは、コードで TripleDES、SHA1、または RIPEMD160 アルゴリズムが検出されるとトリガーされます。|
| CA5351 | [CA5351 破られた暗号アルゴリズムを使用しないでください](../code-quality/ca5351.md) | 破られた暗号アルゴリズムはセキュアであるとは見なされず、それらを使用しないことを強くお勧めします。 このルールは、コードに MD5 ハッシュ アルゴリズムや、DES か RC2 のいずれかの暗号化アルゴリズムが検出されるとトリガーされます。 |
| CA5358 | [CA5358:安全ではない暗号モードを使用しないでください](../code-quality/ca5358.md) | 安全ではない暗号モードを使用しないでください |
| CA5359 | [CA5359 証明書の検証を無効にしない](../code-quality/ca5359.md) | 証明書は、サーバーの id を認証するのに役立ちます。 クライアントはサーバー証明書を検証して、要求が目的のサーバーに送信されるようにする必要があります。 ServerCertificateValidationCallback が常にを返す場合 `true` 、すべての証明書が検証に合格します。 |
| CA5360 | [CA5360 は、逆シリアル化で危険なメソッドを呼び出さないでください。](../code-quality/ca5360.md) | 安全でない逆シリアル化は、信頼されていないデータを使用してアプリケーションのロジックを不適切に悪用したり、サービス拒否 (DoS) 攻撃を受けたり、逆シリアル化の際に任意のコードを実行したりする場合に発生する脆弱性です。 悪意のあるユーザーが、制御下にある信頼されていないデータを逆シリアル化するときに、これらの逆シリアル化機能を不正使用する可能性があります。 具体的には、逆シリアル化のプロセスで危険なメソッドを呼び出します。 安全に安全でない逆シリアル化攻撃によって、攻撃者は DoS 攻撃、認証バイパス、リモートコード実行などの攻撃を仕掛けることができます。 |
| CA5361 | [CA5361: 強力な暗号の SChannel の使用を無効にしません](../code-quality/ca5361.md) | `Switch.System.Net.DontEnableSchUseStrongCrypto`をに設定すると `true` 、発信トランスポート層セキュリティ (TLS) 接続で使用される暗号化が弱くなります。 弱い暗号化を使用すると、アプリケーションとサーバーの間の通信の機密性が低下する可能性があるため、攻撃者が機微なデータを簡単に盗聴ことができます。 |
| CA5362 | [逆シリアル化されたオブジェクトグラフでの可能性のある参照サイクルの CA5362](../code-quality/ca5362.md) | 信頼されていないデータを逆シリアル化する場合、逆シリアル化されたオブジェクトグラフを処理するコードは、無限ループに入ることなく参照サイクルを処理する必要があります。 これには、逆シリアル化のコールバックの一部であるコードと、逆シリアル化の完了後にオブジェクトグラフを処理するコードの両方が含まれます。 そうしないと、攻撃者は参照サイクルを含む悪意のあるデータを使用してサービス拒否攻撃を実行する可能性があります。 |
| CA5363 | [CA5363:要求の検証を無効にしません](../code-quality/ca5363.md) | 要求の検証は、ASP.NET の機能の1つで、HTTP 要求を調べて、クロスサイトスクリプトを含む注入攻撃につながる可能性がある危険性のあるコンテンツが含まれているかどうかを判断します。 |
| CA5364 | [CA5364: 非推奨のセキュリティ プロトコルを使用しないでください](../code-quality/ca5364.md) | トランスポート層セキュリティ (TLS) は、通常、ハイパーテキスト転送プロトコルセキュア (HTTPS) を使用して、コンピューター間の通信をセキュリティで保護します。 Tls の古いプロトコルバージョンは、TLS 1.2 および TLS 1.3 よりも安全性が低く、新しい脆弱性が発生する可能性が高くなります。 リスクを最小限に抑えるために、古いプロトコルバージョンを避けてください。 |
| CA5365 | [CA5365 で HTTP ヘッダーチェックを無効にしない](../code-quality/ca5365.md) | HTTP ヘッダーチェックでは、応答ヘッダーに含まれる復帰文字と改行文字 (\r と \n) をエンコードできます。 このエンコーディングは、ヘッダーに含まれる信頼されていないデータをエコーするアプリケーションを悪用する注入攻撃を回避するのに役立ちます。 |
| CA5366 | [CA5366 データセット読み取り XML に XmlReader を使用する](../code-quality/ca5366.md) | を使用して <xref:System.Data.DataSet> 信頼できないデータを持つ XML を読み取ると、危険な外部参照が読み込まれる可能性があります。これは、 <xref:System.Xml.XmlReader> セキュリティで保護された競合回避モジュールを使用するか、DTD 処理を無効にして制限する必要があり |
| CA5367 | [CA5367 はポインターフィールドを持つ型をシリアル化しません](../code-quality/ca5367.md) | このルールでは、ポインターフィールドまたはプロパティを持つシリアル化可能なクラスがあるかどうかを確認します。 シリアル化できないメンバーは、静的メンバーまたはでマークされたフィールドなどのポインターにすることができ <xref:System.NonSerializedAttribute> ます。 |
| CA5368 | [ページから派生したクラスの CA5368 Set ViewStateUserKey](../code-quality/ca5368.md) | プロパティを設定する <xref:System.Web.UI.Page.ViewStateUserKey> と、個々のユーザーのビューステート変数に識別子を割り当てて、攻撃者が変数を使用して攻撃を生成できないようにすることで、アプリケーションに対する攻撃を防ぐことができます。 そうしないと、クロスサイト要求の偽造に対する脆弱性が発生します。 |
| CA5369 | [CA5369:逆シリアル化に XmlReader を使用します](../code-quality/ca5369.md) | 信頼されていない DTD と XML スキーマを処理すると、危険な外部参照を読み込むことができます。これは、セキュリティで保護された競合回避モジュールを使用するか、DTD および XML インラインスキーマ処理を無効にして、XmlReader を使用して制限する |
| CA5370 | [CA5370:読み取りの検証に XmlReader を使用します](../code-quality/ca5370.md) | 信頼されていない DTD と XML スキーマを処理すると、危険な外部参照を読み込むことができます。 この危険な読み込みは、セキュリティで保護された競合回避モジュールで XmlReader を使用するか、DTD および XML インラインスキーマ処理を無効にして制限できます。 |
| CA5371 | [CA5371:スキーマの読み取りに XmlReader を使用します](../code-quality/ca5371.md) | 信頼されていない DTD と XML スキーマを処理すると、危険な外部参照を読み込むことができます。 セキュリティで保護された競合回避モジュールで XmlReader を使用するか、DTD および XML インラインスキーマ処理を使用すると、この制限は無効になります。 |
| CA5372 | [CA5372:XPathDocument に XmlReader を使用します](../code-quality/ca5372.md) | 信頼されていないデータから XML を処理すると、危険な外部参照が読み込まれる可能性があります。これは、セキュリティで保護された競合回避モジュールを使用するか、DTD 処理を無効にして、XmlReader |
| CA5373 | [CA5373:廃止されたキー派生関数を使用しません](../code-quality/ca5373.md) | このルールは、弱いキー派生メソッドとの呼び出しを検出し <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> `Rfc2898DeriveBytes.CryptDeriveKey` ます。 <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> 弱いアルゴリズム PBKDF1 が使用されていました。 |
| CA5374 | [CA5374 XslTransform を使用しない](../code-quality/ca5374.md) | このルール <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> では、がコード内でインスタンス化されているかどうかを確認します。 <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> は互換性のために残されているため、使用しないでください。 |
| CA5375 | [CA5375 アカウントの共有アクセス署名を使用しない](../code-quality/ca5375.md) | アカウント SAS は、blob コンテナー、テーブル、キュー、およびサービス SAS で許可されていないファイル共有に対する読み取り、書き込み、および削除操作へのアクセスを委任できます。 ただし、コンテナーレベルのポリシーはサポートされておらず、付与されるアクセス許可をより柔軟に制御することはできません。 悪意のあるユーザーがアクセスすると、ストレージアカウントが簡単に侵害されます。 |
| CA5376 | [CA5376 SharedAccessProtocol HttpsOnly を使用する](../code-quality/ca5376.md) | SAS は、HTTP でプレーンテキストで転送できない機密データです。 |
| CA5377 | [CA5377 コンテナーレベルのアクセスポリシーを使用する](../code-quality/ca5377.md) | コンテナーレベルのアクセスポリシーは、いつでも変更または失効できます。 これにより、付与されるアクセス許可をより柔軟に制御できるようになります。 |
| CA5378 | [CA5378: ServicePointManagerSecurityProtocols を無効にしません](../code-quality/ca5378.md) | `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols`をに設定すると、 `true` Windows Communication Framework の (WCF) Transport Layer SECURITY (tls) 接続が tls 1.0 を使用するように制限されます。 このバージョンの TLS は非推奨とされます。 |
| CA5379 | [CA5379 は、弱いキー派生関数アルゴリズムを使用しません](../code-quality/ca5379.md) | クラスは、 <xref:System.Security.Cryptography.Rfc2898DeriveBytes> 既定でアルゴリズムを使用し <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> ます。 またはそれ以上のコンストラクターの一部のオーバーロードで使用するハッシュアルゴリズムを指定する必要があり <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> ます。 プロパティに <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> はアクセサーのみがあり、 `get` 修飾子はありません `overriden` 。 |
| CA5380 | [CA5380:ルート ストアに証明書を追加しません](../code-quality/ca5380.md) | このルールは、信頼されたルート証明機関の証明書ストアに証明書を追加するコードを検出します。 既定では、信頼されたルート証明機関の証明書ストアは、Microsoft ルート証明書プログラムの要件を満たしている一連のパブリック Ca で構成されます。 |
| CA5381 | [CA5381:証明書がルート ストアに追加されていないことを確認します](../code-quality/ca5381.md) | このルールは、信頼されたルート証明機関の証明書ストアに証明書を追加する可能性のあるコードを検出します。 既定では、信頼されたルート証明機関の証明書ストアは、Microsoft ルート証明書プログラムの要件を満たす公開証明機関 (Ca) のセットを使用して構成されます。 |
| CA5382 | [CA5382 では、セキュリティで保護された cookie を使用 ASP.NET Core](../code-quality/ca5382.md) | HTTPS 経由で使用できるアプリケーションでは、セキュリティで保護された cookie を使用する必要があります。これは、cookie が Secure Sockets Layer (SSL) を使用してのみ送信されることをブラウザーに示すことを示します |
| CA5383 | [CA5383 でセキュリティで保護された cookie を使用することを確認 ASP.NET Core](../code-quality/ca5383.md) | HTTPS 経由で使用できるアプリケーションでは、セキュリティで保護された cookie を使用する必要があります。これは、cookie が Secure Sockets Layer (SSL) を使用してのみ送信されることをブラウザーに示すことを示します |
| CA5384 | [CA5384 デジタル署名アルゴリズム (DSA) を使用しない](../code-quality/ca5384.md) | DSA は、弱い非対称暗号化アルゴリズムです。 |
| CA5385 | [CA5385 Use Rivest – Rivest-shamir-adleman – Rivest-shamir-adleman (RSA) アルゴリズム (十分なキーサイズ)](../code-quality/ca5385.md) | RSA キーが2048ビットより小さい場合は、ブルートフォース攻撃に対して脆弱になります。 |
| CA5386 | [CA5386: SecurityProtocolType 値のハードコードを避けます](../code-quality/ca5386.md) | トランスポート層セキュリティ (TLS) は、通常、ハイパーテキスト転送プロトコルセキュア (HTTPS) を使用して、コンピューター間の通信をセキュリティで保護します。 Tls 1.2 と TLS 1.3 は最新ではありませんが、プロトコルバージョン TLS 1.0 および TLS 1.1 は非推奨とされます。 今後、TLS 1.2 および TLS 1.3 が非推奨とされる可能性があります。 アプリケーションがセキュリティで保護されていることを確認するには、プロトコルバージョンをハードコーディングし、少なくとも .NET Framework v 4.7.1 をターゲットにするようにします。 |
| CA5387 | [CA5387 の反復回数が不十分なため、弱いキー派生関数を使用しない](../code-quality/ca5387.md) | このルールは、によって暗号化キーが生成されたかどうかを、イテレーション数が10万未満であるかどうかを確認 <xref:System.Security.Cryptography.Rfc2898DeriveBytes> します。 反復回数が多いほど、生成された暗号化キーを推測しようとする辞書攻撃に対する軽減に役立ちます。 |
| CA5388 | [CA5388 弱いキー派生関数を使用する場合、十分な反復回数を確保する](../code-quality/ca5388.md) | このルールは、によって暗号化キーが生成されたかどうかを、 <xref:System.Security.Cryptography.Rfc2898DeriveBytes> 10万未満の反復回数で確認します。 反復回数が多いほど、生成された暗号化キーを推測しようとする辞書攻撃に対する軽減に役立ちます。 |
| CA5389 | [CA5389:アーカイブ項目のパスをターゲット ファイル システム パスに追加しません](../code-quality/ca5389.md) | ファイルパスは相対パスにすることができ、予想されるファイルシステムのターゲットパスの外部でファイルシステムにアクセスする可能性があります。これにより、悪意のある構成の変更や、配置と待機の手法を使用したリモートでのコードの実行が可能になります。 |
| CA5390 | [CA5390 暗号化キーをハードコーディングしない](../code-quality/ca5390.md) | 対称アルゴリズムを成功させるには、送信側と受信側だけが秘密キーを認識している必要があります。 キーがハードコーディングされている場合は、簡単に検出できます。 コンパイル済みバイナリでも、悪意のあるユーザーが簡単に抽出できます。 秘密キーが侵害されると、暗号文は直接復号化でき、保護されなくなります。 |
| CA5391 | [CA5391 MVC コントローラー ASP.NET Core での偽造防止トークンの使用](../code-quality/ca5391.md) | 偽造防止 `POST` トークンを検証せずに、、、または要求を処理すると、 `PUT` `PATCH` `DELETE` クロスサイト要求偽造攻撃に対して脆弱になる可能性があります。 クロスサイト要求偽造攻撃は、認証されたユーザーから ASP.NET Core MVC コントローラーに悪意のある要求を送信できます。 |
| CA5392 | [CA5392 P/Invoke の DefaultDllImportSearchPaths 属性を使用します。](../code-quality/ca5392.md) | 既定では、P/Invoke 関数でプローブを使用して、 <xref:System.Runtime.InteropServices.DllImportAttribute> 読み込むライブラリの現在の作業ディレクトリを含む多数のディレクトリが検出されます。 これは、特定のアプリケーションのセキュリティ上の問題であり、DLL のハイジャックにつながる可能性があります。 |
| CA5393 | [CA5393 unsafe DllImportSearchPath 値を使用しない](../code-quality/ca5393.md) | 既定の DLL 検索ディレクトリとアセンブリディレクトリに悪意のある DLL が存在する可能性があります。 または、アプリケーションの実行場所によっては、アプリケーションのディレクトリに悪意のある DLL が存在する可能性があります。 |
| CA5394 | [CA5394 は安全でないランダム性を使用しない](../code-quality/ca5394.md) | 暗号強度の弱い擬似乱数ジェネレーターを使用すると、攻撃者がセキュリティを重視した値が生成されることを予測できます。 |
| CA5395 | [CA5395 がアクションメソッドの HttpVerb 属性を見逃す](../code-quality/ca5395.md) | データの作成、編集、削除、またはその他の変更を行うすべてのアクションメソッドは、クロスサイト要求偽造攻撃からの偽造防止属性で保護する必要があります。 GET 操作の実行は、副作用のない安全な操作であり、永続化されたデータを変更することはありません。 |
| CA5396 | [CA5396 HttpCookie に対して HttpOnly を true に設定します。](../code-quality/ca5396.md) | 多層防御の手段として、セキュリティが重要な HTTP クッキーが HttpOnly としてマークされていることを確認します。 これは、web ブラウザーがスクリプトによる cookie へのアクセスを許可しないことを示します。 挿入された悪意のあるスクリプトは、cookie を盗む一般的な方法です。 |
| CA5397 | [CA5397:非推奨の SslProtocols 値を使用しません](../code-quality/ca5397.md) | トランスポート層セキュリティ (TLS) は、通常、ハイパーテキスト転送プロトコルセキュア (HTTPS) を使用して、コンピューター間の通信をセキュリティで保護します。 Tls の古いプロトコルバージョンは、TLS 1.2 および TLS 1.3 よりも安全性が低く、新しい脆弱性が発生する可能性が高くなります。 リスクを最小限に抑えるために、古いプロトコルバージョンを避けてください。 |
| CA5398 | [CA5398:ハードコーディングされた SslProtocols 値を回避します](../code-quality/ca5398.md) | トランスポート層セキュリティ (TLS) は、通常、ハイパーテキスト転送プロトコルセキュア (HTTPS) を使用して、コンピューター間の通信をセキュリティで保護します。 Tls 1.2 と TLS 1.3 は最新ではありませんが、プロトコルバージョン TLS 1.0 および TLS 1.1 は非推奨とされます。 今後、TLS 1.2 および TLS 1.3 が非推奨とされる可能性があります。 アプリケーションがセキュリティで保護されていることを確認するには、プロトコルバージョンをハードコーディングしないようにします。 |
| CA5399 | [CA5399 は確実に HttpClient 証明書失効リストチェックを無効にする](../code-quality/ca5399.md) | 失効した証明書は信頼されていません。 攻撃者が悪意のあるデータを渡すか、または HTTPS 通信で機微なデータを盗むために使用される可能性があります。 |
| CA5400 | [CA5400 HttpClient 証明書失効リストの確認が無効になっていないことを確認します。](../code-quality/ca5400.md) | 失効した証明書は信頼されていません。 攻撃者が悪意のあるデータを渡すか、または HTTPS 通信で機微なデータを盗むために使用される可能性があります。 |
| CA5401 | [CA5401 既定以外の IV で CreateEncryptor 機能を使用しない](../code-quality/ca5401.md) | 対称暗号化では、ディクショナリ攻撃を防ぐために、常に反復不可能な初期化ベクターを使用する必要があります。 |
| CA5402 | [CA5402 既定の IV で CreateEncryptor 機能を使用する](../code-quality/ca5402.md) | 対称暗号化では、ディクショナリ攻撃を防ぐために、常に反復不可能な初期化ベクターを使用する必要があります。 |
| CA5403 | [CA5403:証明書をハードコーディングしない](../code-quality/ca5403.md) | `data` `rawData` またはコンストラクターのパラメーターまたはパラメーターは <xref:System.Security.Cryptography.X509Certificates.X509Certificate> <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> ハードコーディングされています。 |
| IL3000 | [IL3000 1 つのファイルとして発行するときにアセンブリファイルパスにアクセスしない](../code-quality/il3000.md) | 1つのファイルとして発行するときにアセンブリファイルパスへのアクセスを使用しない |
| IL3001 | [IL3001 を単一ファイルとして発行するときにアセンブリファイルパスにアクセスしないようにする](../code-quality/il3001.md) | 単一ファイルとして発行するときにアセンブリファイルパスにアクセスしない |
