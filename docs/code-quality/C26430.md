---
title: C26430
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26430
helpviewer_keywords:
- C26430
ms.assetid: 3dca2626-8102-4eed-8ff3-73eb3d5c328c
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: efa76e1176eca5598ac7c834491af9413d74a6b2
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/07/2019
ms.locfileid: "72016573"
---
# <a name="c26430-test_on_all_paths"></a>C26430 TEST_ON_ALL_PATHS

"シンボルは、すべてのパスで null 性がテストされていません。"

** C++コアガイドライン**:F. 23:Not_null @ no__t-0T > を使用して、"null" が有効な値でないことを示します。

コードがポインター変数の null をチェックする場合は、これを一貫した方法で検証し、すべてのパスでポインターを検証する必要があります。 場合によっては、複雑な分岐の1つでハードクラッシュが発生する可能性よりも、null 性を過剰にチェックする方が良い場合があります。 このようなコードは、(複数の関数に分割することによって) あまり複雑にならないようにリファクタリングし、gsl:: not_null (ガイドラインサポートライブラリを参照) などのマーカーに依存して、有効なポインター値について安全に想定するアルゴリズムの一部を分離することが理想的です。 ルール TEST_ON_ALL_PATHS を使用すると、null 値のチェックが矛盾している (つまり、推測が必要になる可能性があります) か、または null 値が許容される可能性のある実際のバグ (コードパスの一部では、null 値による推測を回避できる) を見つけることができます。

## <a name="remarks"></a>コメント

- この規則では、null 値のチェック (または null 以外の値の適用) が正当化されるように、コードがポインター変数を逆参照することを想定しています。 逆参照がない場合、ルールは中断されます。
  - 現在の実装では、プレーンポインター (またはそのエイリアス) のみを処理します。また、スマートポインターにも null のチェックが適用されますが、スマートポインターは検出しません。
  - 変数は、次のコンテキストで使用される場合に、null 性のチェック対象としてマークされます。
  - "if (p) {...}" のように、分岐条件のシンボル式として
  - ビット演算以外の論理演算です。
  - 1つのオペランドが0に評価される定数式である比較演算。
  - ルールには完全なデータフロー追跡がありません。間接チェックが使用されている場合 (中間変数が null 値を保持し、後で比較で使用される場合など) に、正しくない結果が生成される可能性があります。
  - 暗黙的な null 性チェックは、ポインター値がから割り当てられている場合に想定されます。
  - スロー演算子 new を使用して実行された割り当て。
  - gsl:: not_null でマークされた型から取得されたポインター。

## <a name="example"></a>例

不整合なテストにより論理エラーが明らかになる

```cpp
void merge_states(const state *left, const state *right) // C26430
{
    if (*left && *right)
        converge(left, right);
    else
    {
        // ...
        if (!left && !right)                            // Logic error!
            discard(left, right);
    }
}
```

不整合なテストにより論理エラーが明らかになりました

```cpp
void merge_states(gsl::not_null<const state *> left, gsl::not_null<const state *> right)
{
    if (*left && *right)
        converge(left, right);
    else
    {
        // ...
        if (*left && *right)
            discard(left, right);
    }
}
```
