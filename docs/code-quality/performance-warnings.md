---
title: パフォーマンスに関する警告
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.performancerules
helpviewer_keywords:
- warnings, performance
- performance warnings
- performance, warnings
- managed code analysis warnings, performance warnings
ms.assetid: e014ac3a-02e6-46d9-942c-3491dd63782f
author: gewarren
ms.author: gewarren
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 29ace36d35b31eeb3635d06d6244ac6fe0897ec2
ms.sourcegitcommit: 034c503ae04e22cf840ccb9770bffd012e40fb2d
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 10/14/2019
ms.locfileid: "72305658"
---
# <a name="performance-warnings"></a>パフォーマンスに関する警告
パフォーマンスの警告は、高パフォーマンスのライブラリとアプリケーションをサポートします。

## <a name="in-this-section"></a>このセクションの内容

| Rule | 説明 |
| - | - |
| [CA1800:不要な @ no__t をキャストしないでください。 | 二重のキャストがあるとパフォーマンスが低下します。特に、小さな繰り返しステートメントでキャストが実行される場合はそうです。 |
| [CA1801:未使用のパラメーターを確認する @ no__t-0 | メソッドのシグネチャに、メソッドの本体で使用されていないパラメーターがあります。 |
| [CA1802:必要に応じてリテラルを使用する @ no__t-0 | フィールドは静的および読み取り専用として宣言されています ([!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)] では Shared と ReadOnly)。このフィールドは、コンパイル時に計算できるという値で初期化されます。 対象フィールドに割り当てられている値は、コンパイル時に計算であるため、宣言を const に変更 (で Const [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)]) の代わりに実行時のコンパイル時に値を計算するためのフィールドします。 |
| [CA1804:未使用のローカルの削除 @ no__t-0 | 使用されていないローカル変数や不要な引数があると、アセンブリのサイズが大きくなり、パフォーマンスが低下します。 |
| [CA1806:メソッドの結果を無視しない @ no__t-0 | 新しいオブジェクトが作成されましたが、使用されていないか、新しい文字列を作成して返すメソッドが呼び出され、新しい文字列が使用されていないか、またはコンポーネントオブジェクトモデル (COM) または P/Invoke メソッドが、使用されていない HRESULT またはエラーコードを返しています。 |
| [CA1809:過度なローカル @ no__t を避けてください。 | パフォーマンス最適化の一般的な方法として、メモリではなくプロセッサのレジスタに値を格納する方法があります。これは "値のレジスタ格納" と呼ばれます。  すべてのローカル変数は、レジスタである可能性を向上させるのには、64 をローカル変数の数を制限します。 |
| [CA1810:参照型の静的フィールドを初期化します。インライン @ no__t-0 | 型で明示的な静的コンストラクターを宣言すると、Just-In-Time (JIT) コンパイラが、静的コンストラクターが呼び出されたことを確認するために、型の静的メソッドと静的インスタンス コンストラクターに個別にチェックを追加します。 静的コンストラクターのチェックによってパフォーマンスが低下することがあります。 |
| [CA1811:呼び出されるプライベートコードを回避する @ no__t-0 | プライベートまたは内部 (アセンブリレベル) のメンバーは、アセンブリ内の呼び出し元を持っていません。また、共通言語ランタイムによって呼び出されず、デリゲートによって呼び出されません。 |
| [CA1812:インスタンス内部クラスの回避 @ no__t-0 | アセンブリ レベルの型のインスタンスが、アセンブリ内のコードから作成されません。 |
| [CA1813:封印されていない属性を避ける @ no__t-0 | .NET には、カスタム属性を取得するためのメソッドが用意されています。 既定では、これらのメソッドで属性の継承階層が検索されます。 属性をシールすると、継承階層の全体が検索されなくなるため、パフォーマンスが向上します。 |
| [CA1814:多次元 @ no__t でジャグ配列を優先します。 | ジャグ配列とは、その要素も配列である配列です。 要素を構成する配列のサイズは異なる可能性があるため、一部のデータセットで無駄な領域が生じる可能性があります。 |
| [CA1815:equals および operator equals を値型でオーバーライドします](../code-quality/ca1815.md)」を参照してください。 | 値型の場合、Equals を継承した実装が Reflection ライブラリを使用して、すべてのフィールドの内容を比較します。 Reflection は計算コストが高いため、場合によってはすべてのフィールドで等値性を比較する必要はありません。 ユーザーがインスタンスの比較または並べ替えを行うことや、ハッシュ テーブル キーとしてインスタンスを使用することが予想される場合には、値型に Equals を実装する必要があります。 |
| [CA1816:GC を呼び出します。Gc.suppressfinalize @ no__t-0 | Dispose の実装であるメソッドは、GC を呼び出しません。Gc.suppressfinalize、または Dispose の実装ではないメソッドは GC を呼び出します。Gc.suppressfinalize、またはメソッドは GC を呼び出します。Gc.suppressfinalize は、この以外のものを渡します ([!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)])。 |
| [CA1819:プロパティは配列を返すことはできません @ no__t-0 | プロパティが読み取り専用の場合でも、プロパティによって返される配列は書き込み禁止になりません。 配列の改ざんを防ぐには、プロパティで配列のコピーを返す必要があります。 一般に、このようなプロパティを呼び出すときのパフォーマンス低下は理解されません。 |
| [CA1820:文字列の長さ @ no__t を使用して空の文字列をテストする | String.Length プロパティまたは String.IsNullOrEmpty メソッドを使用して文字列を比較する方法は、Equals を使用する場合よりもはるかに高速です。 |
| [CA1821: 空のファイナライザーを削除します](../code-quality/ca1821.md) | オブジェクトの有効期間の追跡に関連するパフォーマンス オーバーヘッドが増大するため、ファイナライザーは可能な限り使用しないでください。 空のファイナライザーを使用すると、追加のオーバーヘッドが発生します。 |
| [CA1822:メンバーを静的 @ no__t としてマークする | インスタンス データにアクセスしない、またはインスタンス メソッドを呼び出さないメンバーは、静的 ([!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)] では共有) としてマークできます。 メソッドを静的としてマークすると、コンパイラはこれらのメンバーに対する非仮想呼び出しサイトを出力します。 パフォーマンス重視のコードでは、これにより大きくパフォーマンスを向上できます。 |
| [CA1823:使用されていないプライベートフィールドを回避する @ no__t-0 | アセンブリ内でアクセスされていないと思われるプライベート フィールドが検出されました。 |
| [CA1824:NeutralResourcesLanguageAttribute @ no__t にアセンブリをマークします。 | NeutralResourcesLanguage 属性は、ResourceManager に対し、アセンブリのニュートラル カルチャのリソースを表示するために使用した言語を通知します。 これにより、読み込んだ最初のリソースに対する検索のパフォーマンスが向上し、ワーキング セットを縮小できます。 |
| [CA1825:長さ0の配列割り当てを回避する @ no__t-0 | 長さ0の配列を初期化すると、不要なメモリ割り当てにつながります。 代わりに、<xref:System.Array.Empty%2A?displayProperty=nameWithType> を呼び出すことによって、静的に割り当てられた空の配列インスタンスを使用します。 メモリ割り当ては、このメソッドのすべての呼び出しで共有されます。 |
