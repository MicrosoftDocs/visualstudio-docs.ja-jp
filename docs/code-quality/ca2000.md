---
title: 'CA2000: スコープが失われる前にオブジェクトを破棄します'
ms.date: 05/14/2019
ms.topic: reference
f1_keywords:
- CA2000
- Dispose objects before losing scope
- DisposeObjectsBeforeLosingScope
helpviewer_keywords:
- CA2000
- DisposeObjectsBeforeLosingScope
ms.assetid: 0c3d7d8d-b94d-46e8-aa4c-38df632c1463
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: 387f1c3d763b15cdbf9ff3cc21375958dc213058
ms.sourcegitcommit: 4bcd6abb89feff1cf8251e3ded73fdc30b67e347
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 04/17/2020
ms.locfileid: "81615577"
---
# <a name="ca2000-dispose-objects-before-losing-scope"></a>CA2000: スコープが失われる前にオブジェクトを破棄します

|||
|-|-|
|TypeName|DisposeObjectsBeforeLosingScope|
|CheckId|CA2000|
|カテゴリ|Microsoft.Reliability|
|互換性に影響する変更点|なし|

## <a name="cause"></a>原因

<xref:System.IDisposable>型のローカル オブジェクトが作成されますが、オブジェクトへのすべての参照がスコープ外になる前に、そのオブジェクトは破棄されません。

既定では、このルールはコードベース全体を分析しますが、これは[構成可能](#configurability)です。

## <a name="rule-description"></a>規則の説明

破棄できるオブジェクトに対するすべての参照がスコープ外になる前に、オブジェクトが明示的に破棄されない場合、ガベージ コレクターでオブジェクトのファイナライザーが実行されるときに破棄されますが、タイミングは一定ではありません。 例外的なイベントが発生するとオブジェクトのファイナライザーを実行できないため、オブジェクトは明示的に破棄する必要があります。

### <a name="special-cases"></a>特殊なケース

オブジェクトが破棄されていない場合でも、次の種類のローカル オブジェクトに対してルール CA2000 は起動しません。

- <xref:System.IO.Stream?displayProperty=nameWithType>
- <xref:System.IO.StringReader?displayProperty=nameWithType>
- <xref:System.IO.TextReader?displayProperty=nameWithType>
- <xref:System.IO.TextWriter?displayProperty=nameWithType>
- <xref:System.Resources.IResourceReader?displayProperty=nameWithType>

これらの型のいずれかのオブジェクトをコンストラクターに渡し、フィールドに代入すると、新しく構築された型への*破棄所有権の転送*が示されます。 つまり、新しく構築された型は、オブジェクトの破棄を行うようになりました。 コードがこれらの型のいずれかのオブジェクトをコンストラクターに渡す場合、オブジェクトへのすべての参照がスコープ外になる前にオブジェクトが破棄されない場合でも、規則 CA2000 の違反は発生しません。

## <a name="how-to-fix-violations"></a>違反の修正方法

この規則違反を修正するには、オブジェクトに対するすべての参照がスコープ外になる前に、そのオブジェクトで <xref:System.IDisposable.Dispose%2A> を呼び出します。

[`using`ステートメント](/dotnet/csharp/language-reference/keywords/using-statement)(Visual[`Using`](/dotnet/visual-basic/language-reference/statements/using-statement) Basic) を使用して、 を実装<xref:System.IDisposable>するオブジェクトをラップできます。 この方法でラップされたオブジェクトは、ブロックの最後に自動的に`using`破棄されます。 ただし、以下の状況は`using`ステートメントで処理しないでください。

- 破棄可能なオブジェクトを返すためには、オブジェクトはブロック`try/finally`の外側のブロック`using`で構築する必要があります。

- ステートメントのコンストラクターで、破棄可能オブジェクトのメンバーを`using`初期化しないでください。

- ステートメントの取得部分で 1 つの例外ハンドラーのみによって保護されているコンストラクターが入れ子になっている場合、外側のコンストラクターでエラーが発生すると、入れ子になったコンストラクターによって作成されたオブジェクトが閉じなくなる可能性があります。 [ `using` ](/dotnet/csharp/language-reference/language-specification/statements#the-using-statement) 次の例では、コンストラクターでエラーが<xref:System.IO.StreamReader>発生すると、オブジェクトが<xref:System.IO.FileStream>閉じなくなる可能性があります。 CA2000 は、この場合、規則違反をフラグします。

   ```csharp
   using (StreamReader sr = new StreamReader(new FileStream("C:\myfile.txt", FileMode.Create)))
   { ... }
   ```

- 動的オブジェクトは、シャドウ オブジェクトを使用して、オブジェクトの<xref:System.IDisposable>破棄パターンを実装する必要があります。

## <a name="when-to-suppress-warnings"></a>警告を抑制する場合

次の場合を除き、この規則からの警告を抑制しないでください。

- オブジェクトで、 を呼び出すメソッドを`Dispose`呼び出しました。<xref:System.IO.Stream.Close%2A>
- 警告を発生させたメソッドは、オブジェクト<xref:System.IDisposable>をラップするオブジェクトを返します
- 割り当てメソッドには、破棄所有権がありません。つまり、オブジェクトを破棄する責任は、メソッドで作成された別のオブジェクトまたはラッパーに転送され、呼び出し元に返されます

## <a name="configurability"></a>構成可能の有無

このルールを[FxCop アナライザ](install-fxcop-analyzers.md)から実行している場合 (レガシ分析ではなく)、このルールの分析を構成できます。

### <a name="excluded-symbol-names"></a>除外シンボル名

コードベースのどの部分を分析から除外するかを設定できます。 たとえば、という名前`MyType`の型内のコードでルールを実行しないように指定するには、プロジェクトの .editorconfig ファイルに次のキーと値のペアを追加します。

```ini
dotnet_code_quality.CA2000.excluded_symbol_names = MyType
```

オプション値で使用できるシンボル名の形式 ('|' で区切ります):
  - シンボル名のみ (含まれる型または名前空間に関係なく、名前を持つすべてのシンボルを含む)
  - シンボルの[ドキュメント ID 形式](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)の完全修飾名 。 各シンボル名には、メソッドの "M:" プレフィックス、型の "T:" プレフィックス、名前空間の "N:" プレフィックスなどのシンボルの種類のプレフィックスが必要です。
  - `.ctor`コンストラクターおよび`.cctor`静的コンストラクターの場合

例 :

| オプション値 | まとめ |
| --- | --- |
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType` | コンパイルで 'MyType' という名前のすべてのシンボルに一致します。
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType1|MyType2` | コンパイルで 'MyType1' または 'MyType2' という名前のすべてのシンボルに一致します。
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | 指定された完全修飾署名と特定のメソッド 'MyMethod' を照合します。
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | 特定のメソッド 'MyMethod1' と 'MyMethod2' を、それぞれの完全修飾シグネチャと一致します。

これらのオプションはすべて、このルール、すべてのルール、またはこのカテゴリ (Design) のすべてのルールに対して構成できます。 詳細については、 [FxCop アナライザーの設定](configure-fxcop-analyzers.md)を参照してください。

## <a name="related-rules"></a>関連ルール

- [CA2213: 破棄可能なフィールドは破棄されなければなりません](../code-quality/ca2213.md)
- [CA2202: オブジェクトを複数回破棄しません](../code-quality/ca2202.md)

## <a name="example"></a>例

破棄可能なオブジェクトを返すメソッドを実装する場合は、catch ブロックを使用せずに try/finally ブロックを使用して、オブジェクトが破棄されていることを確認します。 try/finally ブロックを使用することによって、障害点での例外の発生が可能になり、そのオブジェクトが確実に破棄されます。

OpenPort1 メソッドでは、ISerializable オブジェクトの SerialPort を開くための呼び出し、または SomeMethod の呼び出しが失敗する可能性があります。 この実装では CA2000 警告は発生しません。

OpenPort2 メソッドでは、次の 2 つの SerialPort オブジェクトが宣言され、null に設定されます。

- `tempPort`。メソッド操作が成功しているかどうかをテストするのに使用されます。

- `port`メソッドの戻り値に使用されます。

`tempPort` は、`try` ブロックで構築され、開かれます。その他必要な作業も同じ `try` ブロック内で実行されます。 `try` ブロックの最後に、開かれたポートが `port` オブジェクトに割り当てられ、このオブジェクトが返されます。`tempPort` オブジェクトは `null` に設定されます。

`finally` ブロックは `tempPort` 値をチェックします。 null でない場合、メソッド内の操作は失敗しています。`tempPort` は閉じられ、すべてのリソースが解放されます。 返されるオブジェクトには、メソッド操作が成功した場合、開かれた SerialPort オブジェクトが含まれます。メソッドの操作が失敗した場合は null になります。

```csharp
public SerialPort OpenPort1(string portName)
{
   SerialPort port = new SerialPort(portName);
   port.Open();  //CA2000 fires because this might throw
   SomeMethod(); //Other method operations can fail
   return port;
}

public SerialPort OpenPort2(string portName)
{
   SerialPort tempPort = null;
   SerialPort port = null;
   try
   {
      tempPort = new SerialPort(portName);
      tempPort.Open();
      SomeMethod();
      //Add any other methods above this line
      port = tempPort;
      tempPort = null;

   }
   finally
   {
      if (tempPort != null)
      {
         tempPort.Close();
      }
   }
   return port;
}
```

```vb
Public Function OpenPort1(ByVal PortName As String) As SerialPort

   Dim port As New SerialPort(PortName)
   port.Open()    'CA2000 fires because this might throw
   SomeMethod()   'Other method operations can fail
   Return port

End Function

Public Function OpenPort2(ByVal PortName As String) As SerialPort

   Dim tempPort As SerialPort = Nothing
   Dim port As SerialPort = Nothing

   Try
      tempPort = New SerialPort(PortName)
      tempPort.Open()
      SomeMethod()
      'Add any other methods above this line
      port = tempPort
      tempPort = Nothing

   Finally
      If Not tempPort Is Nothing Then
         tempPort.Close()
      End If

   End Try

   Return port

End Function
```

## <a name="example"></a>例

既定では、Visual Basic コンパイラでは、すべての算術演算子でオーバーフローをチェックします。 そのため、いずれかの Visual Basic 算術演算子で <xref:System.OverflowException> がスローされる可能性があります。 これにより、CA2000 のような予期しない規則違反が発生する場合があります。 たとえば、次の CreateReader1 関数では、Visual Basic コンパイラが加算に対するオーバーフロー チェックを実行し、それが例外をスローすると StreamReader が破棄されなくなるので、CA2000 違反が発生します。

これを修正するには、プロジェクトで Visual Basic コンパイラによるオーバーフロー チェックの実施を無効にするか、または次の CreateReader2 関数のようにコードを変更します。

オーバーフロー チェックの出力を無効にするには、ソリューション エクスプローラーでプロジェクト名を右クリックし、[**プロパティ**] をクリックします。 [**コンパイル**] をクリックし、[**詳細コンパイル オプション**]**をクリックします**。

[!code-vb[FxCop.Reliability.CA2000.DisposeObjectsBeforeLosingScope#1](../code-quality/codesnippet/VisualBasic/ca2000-dispose-objects-before-losing-scope-vboverflow_1.vb)]

## <a name="see-also"></a>関連項目

- <xref:System.IDisposable>
- [Dispose パターン](/dotnet/standard/design-guidelines/dispose-pattern)
