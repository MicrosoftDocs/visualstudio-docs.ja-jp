---
title: 'Docker チュートリアル-パート 4: データを保持する'
description: ボリュームをマウントすることによって、データベースのデータを永続化し、ディレクトリをコンテナーに共有する方法について説明します。
ms.date: 08/04/2020
author: nebuk89
ms.author: ghogen
manager: jillfra
ms.technology: vs-azure
ms.topic: conceptual
ms.workload:
- azure
ms.openlocfilehash: 34b3cb9465c1efb946260917d755729e25c4e259
ms.sourcegitcommit: c4212f40df1a16baca1247cac2580ae699f97e4c
ms.translationtype: MT
ms.contentlocale: ja-JP
ms.lasthandoff: 08/31/2020
ms.locfileid: "89176724"
---
# <a name="persist-your-data"></a> データを保持する

メモしていない場合は、コンテナーを起動するたびに todo リストが消去されます。 なぜですか? では、コンテナーがどのように動作しているかを見ていきましょう。

## <a name="the-containers-filesystem"></a>コンテナーのファイルシステム

コンテナーが実行されると、そのファイルシステムのイメージのさまざまなレイヤーが使用されます。 また、各コンテナーは、ファイルを作成、更新、または削除するための独自の "スクラッチ領域" を取得します。 同じイメージを使用して *いる場合でも* 、変更は別のコンテナーに表示されません。

### <a name="see-this-in-practice"></a>実際にこれを見る

これを実際に確認するには、2つのコンテナーを開始し、それぞれにファイルを作成します。 表示されるのは、1つのコンテナーで作成されたファイルを別のコンテナーで使用できないことです。

1. `ubuntu` `/data.txt` 1 から1万の間の乱数を持つという名前のファイルを作成するコンテナーを開始します。

    ```bash
    docker run -d ubuntu bash -c "shuf -i 1-10000 -n 1 -o /data.txt && tail -f /dev/null"
    ```

    コマンドについて興味がある場合は、bash シェルを起動し、2つのコマンド (がある理由) を呼び出してい `&&` ます。 最初の部分は、1つの乱数を取得し、それをに書き込み `/data.txt` ます。 2番目のコマンドは、コンテナーの実行を維持するためにファイルを監視するだけです。

1. を使用して、コンテナーにアクセスすることで出力を確認でき `exec` ます。 これを行うには、VS Code 拡張機能を開き、[ **シェルのアタッチ** ] オプションをクリックします。 これは、を使用して、 `exec` VS Code ターミナル内のコンテナーでシェルを開きます。

    ![Ubuntu コンテナーで CLI を開く VS Code](media/attach_shell.png)

    Ubuntu コンテナーでシェルを実行しているターミナルが表示されます。 次のコマンドを実行して、ファイルの内容を確認し `/data.txt` ます。 このターミナルを再度閉じます。

    ```bash
    cat /data.txt
    ```

    コマンドラインを使用する場合は、コマンドを使用して `docker exec` 同じ操作を行うことができます。 コンテナーの ID を取得し (を使用し `docker ps` て取得)、次のコマンドでコンテンツを取得する必要があります。

    ```bash
    docker exec <container-id> cat /data.txt
    ```

    ランダムな数値が表示できます。

1. 次に、別の `ubuntu` コンテナー (同じイメージ) を起動して、同じファイルがないことを確認します。

    ```bash
    docker run -it ubuntu ls /
    ```

    で、ほら！ ファイルがありません `data.txt` 。 これは、最初のコンテナーに対してのみスクラッチ領域に書き込まれているためです。

1. コマンドを使用して最初のコンテナーを削除し `docker rm -f` ます。

## <a name="container-volumes"></a>コンテナーボリューム

前の実験では、各コンテナーが開始されるたびにイメージ定義から開始されていることがわかりました。 コンテナーはファイルの作成、更新、削除を行うことができますが、コンテナーが削除され、すべての変更がそのコンテナーに分離されると、それらの変更は失われます。 ボリュームを使用すると、このすべてを変更できます。

[ボリューム](https://docs.docker.com/storage/volumes/) は、コンテナーの特定のファイルシステムパスをホストコンピューターに接続する機能を提供します。 コンテナー内のディレクトリがマウントされている場合、そのディレクトリ内の変更もホストコンピューター上に表示されます。 コンテナーを再起動する間に同じディレクトリをマウントすると、同じファイルが表示されます。

ボリュームには主に2つの種類があります。 最終的には両方を使用しますが、 **名前付きボリューム**から開始します。

## <a name="persist-your-todo-data"></a>Todo データを保持する

既定では、todo アプリのデータは、の [SQLite データベース](https://www.sqlite.org/index.html) に格納され `/etc/todos/todo.db` ます。 SQLite を使い慣れていない場合は、心配はありません。 これは単にリレーショナルデータベースであり、すべてのデータが1つのファイルに格納されます。 これは大規模なアプリケーションには最適ではありませんが、小規模なデモでは機能します。 実際のデータベースエンジンへの切り替えについては、後で説明します。

データベースが1つのファイルである場合、ホスト上でそのファイルを保持し、次のコンテナーで使用できるようにすると、最後の1つの場所を取得できるようになります。 ボリュームを作成し、データが格納されているディレクトリにアタッチする (多くの場合、"マウント" と呼ばれます) ことによって、データを保持することができます。 コンテナーがファイルに書き込むと `todo.db` 、ボリューム内のホストに保存されます。

前述のように、 **名前付きボリューム**を使用します。 名前付きボリュームは単なるデータのバケットと考えてください。 Docker はディスク上の物理的な場所を維持し、ボリュームの名前を記憶するだけです。 このボリュームを使用するたびに、Docker は正しいデータが提供されることを確認します。

1. コマンドを使用してボリュームを作成 `docker volume create` します。

    ```bash
    docker volume create todo-db
    ```

1. `docker rm -f <id>`永続ボリュームを使用せずにまだ実行されているため、ダッシュボードまたはでもう一度 todo アプリコンテナーを停止します。

1. Todo アプリコンテナーを起動しますが、 `-v` ボリュームマウントを指定するフラグを追加します。 名前付きボリュームを使用し、にマウントします。これに `/etc/todos` より、パスで作成されたすべてのファイルがキャプチャされます。

    ```bash
    docker run -dp 3000:3000 -v todo-db:/etc/todos getting-started
    ```

1. コンテナーが起動したら、アプリを開き、todo リストにいくつかの項目を追加します。

    ![Todo リストに追加された項目](media/items-added.png)

1. Todo アプリのコンテナーを削除します。 ダッシュボードまたはを使用して `docker ps` ID を取得し、 `docker rm -f <id>` 削除します。

1. 上記と同じコマンドを使用して、新しいコンテナーを開始します。

1. アプリを開きます。 リストに項目がまだ表示されるはずです。

1. リストの確認が完了したら、コンテナーを削除します。

バンザイ! データを永続化する方法について学習しました。

> [!TIP]
> 名前付きボリュームとバインドマウント (1 分で説明します) は、既定の Docker エンジンのインストールでサポートされている2つの主な種類のボリュームですが、NFS、SFTP、NetApp などをサポートするために使用できるボリュームドライバープラグインは多数あります。 これは、クラスター化された環境内の複数のホストでコンテナーの実行を開始した後に特に重要になります。群れや Kubernetes などがあります。

## <a name="dive-into-your-volume"></a>ボリュームについて

多くのユーザーが、"名前付きボリュームを使用すると、Docker は *実際* にデータを保存していますか" という質問を頻繁に行います。 確認するには、コマンドを使用し `docker volume inspect` ます。

```bash
docker volume inspect todo-db
[
    {
        "CreatedAt": "2019-09-26T02:18:36Z",
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/todo-db/_data",
        "Name": "todo-db",
        "Options": {},
        "Scope": "local"
    }
]
```

は、 `Mountpoint` データが格納されるディスク上の実際の場所です。 ほとんどのコンピューターでは、ホストからこのディレクトリにアクセスするにはルートアクセスが必要です。 しかし、それでは、

> [!NOTE]
> **Docker Desktop でのボリュームデータへの直接アクセス** Docker デスクトップで実行されている場合、実際には、Docker コマンドはコンピューター上の小さな VM 内で実行されます。 *マウントポイント*ディレクトリの実際の内容を確認する場合は、最初に VM の内部を取得する必要があります。 WSL 2 では、これは WSL 2 ディストリビューション内にあり、エクスプローラーを使用してアクセスできます。

## <a name="recap"></a>まとめ

この時点で、再起動後も正常に動作するアプリケーションがあります。 これを投資家に見せて、お客様のビジョンを把握できるようにすることができます。

ただし、前に説明したように、すべての変更に対してイメージを再構築するにはかなりの時間がかかります。 変更を加えるには、もっと良い方法がありますか。 Bind マウントでは、より優れた方法があります。 これを見てみましょう。

## <a name="next-steps"></a>次の手順

チュートリアルを続行します。

> [!div class="nextstepaction"]
> [バインドマウントの使用](use-bind-mounts.md)
