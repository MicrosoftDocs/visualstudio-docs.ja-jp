---
title: 'Docker チュートリアル - パート 4: データを保持する'
description: ボリュームをマウントして、データベース内のデータを保持し、ディレクトリをコンテナーに共有する方法について説明します。
ms.date: 08/04/2020
author: nebuk89
ms.author: ghogen
manager: jillfra
ms.technology: vs-azure
ms.topic: conceptual
ms.workload:
- azure
ms.openlocfilehash: 9a4eb5062f8f1b01e8ad5e5165d7ec9ede636124
ms.sourcegitcommit: fb8babf5cd72f1fc2f97ffe4ad7b62d91f325f61
ms.translationtype: HT
ms.contentlocale: ja-JP
ms.lasthandoff: 09/04/2020
ms.locfileid: "89485587"
---
# <a name="persist-your-data"></a> データを保持する

念のため説明すると、コンテナーを起動するたびに、todo リストは完全に消去されます。 なぜですか? コンテナーのしくみを見てみましょう。

## <a name="the-containers-filesystem"></a>コンテナーのファイル システム

コンテナーが実行されると、ファイル システムのイメージからさまざまなレイヤーが使用されます。 各コンテナーには、ファイルを作成、更新、または削除するための独自の "スクラッチ領域" も取得されます。 "*たとえ*" 同じイメージを使用している場合であっても、別のコンテナーでは変更は表示されません。

### <a name="see-this-in-practice"></a>これを実際に確認する

この動作を確認するために、2 つのコンテナーを開始し、それぞれにファイルを作成します。 あるコンテナーで作成されたファイルは別のコンテナーでは使用できないことがわかります。

1. 1 から 10000 の乱数で `/data.txt` という名前のファイルを作成する `ubuntu` コンテナーを開始します。

    ```bash
    docker run -d ubuntu bash -c "shuf -i 1-10000 -n 1 -o /data.txt && tail -f /dev/null"
    ```

    コマンドに興味がある場合は、bash シェルを起動して 2 つのコマンドを呼び出します (`&&` がある理由)。 最初の部分では、1 つの乱数を選択し、それを `/data.txt` に書き込んでいます。 2 つ目のコマンドでは、コンテナーの実行を維持するために単にファイルを監視しています。

1. `exec` を使用してコンテナーにアクセスすることで、出力を表示できることを確認します。 これを行うには、VS Code 拡張機能を開き、 **[Attach Shell]\(シェルのアタッチ\)** オプションをクリックします。 これで `exec` が使用され、VS Code ターミナル内のコンテナーでシェルが開かれます。

    ![ubuntu コンテナーで CLI を開く VS コード](media/attach_shell.png)

    Ubuntu コンテナーでシェルを実行しているターミナルが表示されます。 次のコマンドを実行して、`/data.txt` ファイルの内容を確認します。 後でこのターミナルを再度閉じます。

    ```bash
    cat /data.txt
    ```

    コマンド ラインを使用する場合は、`docker exec` コマンドを使用して同じことができます。 コンテナーの ID を取得し (取得には `docker ps` を使用します)、次のコマンドでコンテンツを取得する必要があります。

    ```bash
    docker exec <container-id> cat /data.txt
    ```

    ランダムな数値が表示されます。

1. ここで、別の `ubuntu` コンテナー (同じイメージ) を開始すると、同じファイルがないことがわかります。

    ```bash
    docker run -it ubuntu ls /
    ```

    ご覧ください。 `data.txt` ファイルがありません。 これは、最初のコンテナーのみのスクラッチ領域に書き込まれたためです。

1. 次に `docker rm -f` コマンドを使用して最初のコンテナーを削除します。

## <a name="container-volumes"></a>コンテナー ボリューム

前の実験では、各コンテナーは、開始されるたびにイメージ定義から開始されることを確認しました。 コンテナーを使用してファイルを作成、更新、および削除できますが、このような変更は、コンテナーが削除されてすべての変更がそのコンテナーに分離されると失われます。 ボリュームを使用すると、このすべてを変更できます。

[[ボリューム]](https://docs.docker.com/storage/volumes/) には、コンテナーの特定のファイル システム パスをホスト マシンに接続する機能があります。 コンテナー内のディレクトリがマウントされている場合、そのディレクトリの変更はホスト マシンでも表示されます。 コンテナーの再起動時にこれと同じディレクトリをマウントすると、同じファイルが表示されます。

ボリュームには、大きく分けて 2 つの種類があります。 最終的には両方を使用しますが、**名前付きボリューム**から始めます。

## <a name="persist-your-todo-data"></a>Todo データを保持する

todo アプリの既定では、そのデータが [SQLite Database](https://www.sqlite.org/index.html) の `/etc/todos/todo.db` に保存されます。 SQLite を使い慣れていない場合でも、心配はいりません。 これは、すべてのデータが 1 つのファイルに格納される単なるリレーショナル データベースです。 これは大規模なアプリケーションには最適ではありませんが、小規模なデモでは機能します。 これを実際のデータベース エンジンに切り替える方法については、後で説明します。

データベースは 1 つのファイルであるため、そのファイルをホスト上に保持しして次のコンテナーで使用できるようにすると、最後に中断したところから再開できます。 ボリュームを作成し、データが格納されているディレクトリにアタッチすることで (多くの場合、"マウント" と呼ばれます)、データを保持できます。 コンテナーによって `todo.db` ファイルに書き込まれると、ボリューム内のホストに保持されます。

前述のように、**名前付きボリューム**を使用します。 名前付きボリュームは単なるデータのバケットと考えてください。 Docker では、ディスク上の物理的な場所が維持されます。必要なことは、ボリュームの名前が記憶することのみです。 ボリュームを使用するたびに、Docker で正しいデータが表示されることを確認します。

1. `docker volume create` コマンドを使用してボリュームを作成します。

    ```bash
    docker volume create todo-db
    ```

1. まだ永続ボリュームを使用しない状態で実行されているため、Docker ビューで (または `docker rm -f <id>` を使用して) todo アプリ コンテナーをもう一度停止します。

1. todo アプリ コンテナーを起動しますが。ただし、ボリューム マウントを指定するには `-v` フラグを追加します。 名前付きボリュームを使用して、それを `/etc/todos` にマウントします。これにより、パスで作成されたすべてのファイルがキャプチャされます。

    ```bash
    docker run -dp 3000:3000 -v todo-db:/etc/todos getting-started
    ```

1. コンテナーが起動したら、アプリを開き、todo リストにいくつかの項目を追加します。

    ![todo リストに追加された項目](media/items-added.png)

1. todo アプリのコンテナーを削除します。 Docker ビューまたは `docker ps` を使用して ID を取得し、`docker rm -f <id>` を使用して削除します。

1. 上記と同じコマンドを使用して、新しいコンテナーを開始します。

1. アプリを開きます。 リストにはまだ項目が表示されます。

1. リストの確認が完了したら、コンテナーを削除します。

おめでとうございます! データを保持する方法について学びました。

> [!TIP]
> 名前付きボリュームとバインド マウント (これについては後で説明します) は、既定の Docker エンジン インストールでサポートされる 2 つの主な種類のボリュームですが、NFS、SFTP、NetApp などをサポートすることができるボリューム ドライバー プラグインが多数あります。 Swarm、Kubernetes などのクラスター環境の複数のホストでコンテナーの実行を開始した後は、これは特に重要になります。

## <a name="dive-into-your-volume"></a>ボリュームを調べる

多くの人から、「名前付きボリュームを使用する場合、Docker で "*実際に*" データが保存されるのはどこですか」とよく質問されます。 確認するには、`docker volume inspect` コマンドを使用できます。

```bash
docker volume inspect todo-db
[
    {
        "CreatedAt": "2019-09-26T02:18:36Z",
        "Driver": "local",
        "Labels": {},
        "Mountpoint": "/var/lib/docker/volumes/todo-db/_data",
        "Name": "todo-db",
        "Options": {},
        "Scope": "local"
    }
]
```

`Mountpoint` は、データが保存されるディスク上の実際の場所です。 ほとんどのマシンでは、ホストからこのディレクトリにアクセスするには、root アクセスが必要であることに注意してください。 ただし、それがこの場所です。

> [!NOTE]
> **Docker Desktop 上のボリューム データに直接アクセスする** Docker Desktop で実行している場合、Docker コマンドは実際にはマシンの小さな VM 内で実行されます。 *Mountpoint* ディレクトリの実際の内容を確認する場合は、まず VM 内を取得する必要があります。 WSL 2 では、これは WSL 2 ディストリビューション内にあり、ファイル エクスプローラーからアクセスできます。

## <a name="recap"></a>まとめ

これで、再起動後も機能するアプリケーションを用意できました。 これを投資家に見せて、ビジョンが理解されることを願っています。

ただし、前に説明したように、変更ごとにイメージを再構築するにはかなりの時間がかかります。 変更を加えるには、もっと良い方法があるのではないでしょうか。 (以前に触れましたが) バインド マウントを使用することをお勧めします。 次はこれを見てみましょう。

## <a name="next-steps"></a>次の手順

チュートリアルを続行します。

> [!div class="nextstepaction"]
> [バインド マウントの使用](use-bind-mounts.md)
